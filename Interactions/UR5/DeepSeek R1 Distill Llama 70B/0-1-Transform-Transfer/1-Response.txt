To solve the inverse kinematicsproblem for both position and orientation, we'll extend the existing position-only solution to include orientation by setting up and solving equations based on rotation matrices.

**Step-by-Step Explanation:**

1. **Understand the Problem:**
   - We need to find joint angles theta1 and theta2 such that the TCP reaches a desired position p and orientation r.

2. **Rotation Matrices:**
   - Define the rotation matrices for each joint:
     - Rz(theta1) for the first joint (Z-axis).
     - Ry(theta2) for the second joint (Y-axis).
   - The total rotation of the TCP is Rz(theta1) * Ry(theta2).

3. **Target Orientation:**
   - Convert the target Euler angles r into a rotation matrix R_target.

4. **Set Up Equations:**
   - Equate the total rotation matrix to R_target:
     Rz(theta1) * Ry(theta2) = R_target.

5. **Solve the Equations:**
   - Use SymPy to solve the system of equations for theta1 and theta2.

6. **Combine with Position Solution:**
   - Use the existing position solution to find initial estimates and ensure both position and orientation are satisfied.

**Answer:**

To solve the inverse kinematics for both position and orientation, we extend the existing solution by incorporating orientation using rotation matrices and solving the resulting equations with SymPy.

```python
import math
import numpy as np
import sympy as sp

def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles theta1 and theta2 to reach the given position p and orientation r.
    
    Args:
        p: A tuple (x, y, z) representing the target position.
        r: A tuple (x, y, z) representing the target orientation in Euler angles (radians).
    
    Returns:
        A tuple (theta1, theta2) in radians.
    """
    # Define the joint angles as symbols
    theta1, theta2 = sp.symbols('theta1 theta2')
    
    # Define the rotation matrices
    Rz = sp.Matrix([
        [sp.cos(theta1), -sp.sin(theta1), 0],
        [sp.sin(theta1), sp.cos(theta1), 0],
        [0, 0, 1]
    ])
    
    Ry = sp.Matrix([
        [sp.cos(theta2), 0, sp.sin(theta2)],
        [0, 1, 0],
        [-sp.sin(theta2), 0, sp.cos(theta2)]
    ])
    
    # Total rotation matrix
    R_total = Rz * Ry
    
    # Convert target Euler angles to rotation matrix
    # Assuming r is (roll, pitch, yaw)
    roll, pitch, yaw = r
    R_target = sp.Matrix([
        [sp.cos(yaw)*sp.cos(pitch), sp.sin(yaw)*sp.cos(pitch), -sp.sin(pitch)],
        [sp.sin(yaw)*sp.cos(pitch), sp.cos(yaw)*sp.cos(pitch), sp.sin(yaw)*sp.sin(pitch)],
        [sp.sin(yaw)*sp.sin(pitch), sp.cos(yaw)*sp.sin(pitch), sp.cos(pitch)]
    ])
    
    # Set up equations by equating corresponding elements
    equations = []
    for i in range(3):
        for j in range(3):
            equations.append(sp.Eq(R_total[i, j], R_target[i, j]))
    
    # Solve the system of equations
    solution = sp.solve(equations, (theta1, theta2))
    
    # Extract the solution (assuming a single solution for simplicity)
    theta1_val = float(solution[theta1])
    theta2_val = float(solution[theta2])
    
    # Ensure the solution is within joint limits
    # (Assuming limits are handled as per the problem statement)
    
    return (theta1_val, theta2_val)
```

This approach systematically combines position and orientation constraints to find the required joint angles, ensuring both are satisfied.