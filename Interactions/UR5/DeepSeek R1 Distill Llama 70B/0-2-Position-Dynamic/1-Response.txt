To solve the inverse kinematicsproblem for the 3-DOF serial manipulator, we need to determine the joint angles \( q_1, q_2, q_3 \) that position the TCP at a desired location \( p = [x, y, z] \). The solution involves solving a system of equations derived from the robot's geometry and transformation matrices.

### Approach
1. **Compute \( q_1 \)**: Using the y-component of the TCP position, we solve for \( q_1 \) by considering the contribution of the first joint's rotation.
2. **Substitute \( q_1 \) into the equations**: With \( q_1 \) known, substitute it into the equations for the x and z components to form a system of two equations with two unknowns (\( q_2 \) and \( q_3 \)).
3. **Solve for \( q_2 \) and \( q_3 \)**: Use trigonometric identities and algebraic manipulation to reduce the system to a solvable form, ultimately finding the angles \( q_2 \) and \( q_3 \).

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the joints to for reaching position "p".
    """
    x, y, z = p
    A = 0.13585  # Length of link 2
    B = 0.1197    # Offset in y from link 2 to link 3
    a = 0.425     # Length of link 3
    b = 0.39225   # Length of TCP

    # Step 1: Solve for q1 using the y-component
    q1 = math.atan2(-x, y + B)

    # Step 2: Compute C and D for the remaining equations
    C = x + A * math.sin(q1)
    D = z

    # Step 3: Calculate cos_phi
    numerator = C**2 + D**2 - a**2 - b**2
    denominator = 2 * a * b
    cos_phi = numerator / denominator
    cos_phi = max(min(cos_phi, 1.0), -1.0)  # Clamp to valid range
    phi = math.acos(cos_phi)

    # Step 4: Compute K and L
    K = a + b * cos_phi
    L = b * math.sin(phi)

    # Step 5: Compute M and theta
    M = math.sqrt(K**2 + L**2)
    if M == 0:
        M = 1e-9  # Avoid division by zero, though theoretically unreachable
    theta = math.atan2(L, K)

    # Step 6: Solve for q2
    argument = D / M
    argument = max(min(argument, 1.0), -1.0)  # Clamp to valid range
    delta = math.acos(argument)
    q2 = theta + delta

    # Step 7: Solve for q3
    q3 = q2 - phi

    return (q1, q2, q3)
```

### Explanation
1. **Compute \( q_1 \)**: Using the arctangent function with adjusted x and y components to account for the first joint's rotation.
2. **Formulate Equations**: Substitute \( q_1 \) into the equations for the x and z components to create a system of equations.
3. **Solve for \( q_2 \) and \( q_3 \)**: Use trigonometric identities to reduce the system, solving for the angles using arccosine and arctangent functions.

This approach ensures that each joint's contribution is systematically considered, allowing the TCP to reach the desired position accurately.