To solve the inverse kinematicsproblem for the given 3-DOF robot arm, we can follow these steps:

1. **Compute θ2** using the z-component of the target position.
2. **Determine sinθ2** based on θ2.
3. **Handle the case where sinθ2 is zero** to avoid division by zero.
4. **Calculate θ1** using the x and y components of the target position.
5. **Set θ3 to zero** as it doesn't affect the TCP's position in this configuration.

Here is the Python function implementing this approach:

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles needed to reach the given position p.
    
    Args:
        p: A tuple (x, y, z) representing the target position.
    
    Returns:
        A tuple (θ1, θ2, θ3) of joint angles in radians.
    """
    x, y, z = p
    
    # Link lengths
    l1 = 0.13585
    l2 = 0.81725  # Combined length from joint 2 to TCP
    
    # Compute θ2
    cosθ2 = z / l2
    θ2 = math.acos(cosθ2)
    sinθ2 = math.sqrt(1 - cosθ2 ** 2) * (1 if θ2 >= 0 else -1)
    
    # Handle division by zero when sinθ2 is near zero
    if abs(sinθ2) < 1e-9:
        # θ2 is 0 or π, compute θ1 from y-component
        cosθ1 = (0.13585 - y) / 0.1197
        θ1 = math.acos(cosθ1)
    else:
        sinθ1 = -x / (l2 * sinθ2)
        cosθ1 = (0.13585 - y) / 0.1197
        θ1 = math.atan2(sinθ1, cosθ1)
    
    θ3 = 0.0  # θ3 does not affect position in this configuration
    
    return (θ1, θ2, θ3)
```

This function calculates the necessary joint angles to reach the specified TCP position by solving the inverse kinematics equations step by step, ensuring that all edge cases are handled appropriately.