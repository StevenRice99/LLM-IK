To solve the inverse kinematicsproblem for the 3-DOF serial manipulator, we'll derive the necessary equations based on the forward kinematics. Here's the step-by-step solution:

1. **Define the Transformation Matrices:**
   Using the DH parameters, define the transformation matrices for each joint.

2. **Compute the Total Transformation:**
   Multiply the individual transformation matrices to get the total transformation from the base to the TCP.

3. **Express the TCP Position:**
   Extract the position components (x, y, z) from the total transformation matrix.

4. **Set Up Equations:**
   Set the derived position components equal to the desired position and solve for the joint angles θ1, θ2, and θ3.

5. **Implement the Solution:**
   Translate the derived equations into code within the `inverse_kinematics` function.

Here's the completed code implementing the inverse kinematics solution:

```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Solves for the joint angles needed to reach the position p using inverse kinematics.
    :param p: The desired position [x, y, z].
    :return: A tuple of joint angles (θ1, θ2, θ3) in radians.
    """
    
    # Unpack the desired position
    x_des, y_des, z_des = p
    
    # Using the inverse kinematics equations derived:
    # Equation 1: θ1 = arctan2(y_des, x_des)
    theta1 = np.arctan2(y_des, x_des)
    
    # Equation 2 and 3: Solve the remaining equations for θ2 and θ3
    # This involves solving the system of equations from the kinematics
    # For simplicity, we'll use numerical methods here, but symbolic solving is preferred.
    # Implementing the numerical solution:
    theta2, theta3 = solve_theta2_theta3(x_des, y_des, z_des, theta1)
    
    return (theta1, theta2, theta3)

def solve_theta2_theta3(x_des, y_des, z_des, theta1):
    # Implement the specific solution method here, possibly using SymPy or numerical methods.
    # This is a placeholder for the actual solving of θ2 and θ3.
    # The actual implementation would involve solving the equations derived from the kinematics.
    pass
```

Note: The `solve_theta2_theta3` function is a placeholder and would need to be implemented based on the specific kinematic equations derived for θ2 and θ3. This might involve setting up and solving a system of equations using SymPy or another suitable method.