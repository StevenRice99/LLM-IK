To solve the inverse kinematicsproblem for the 3-DOF robot arm, we need to determine the joint angles \( q_1, q_2, \) and \( q_3 \) that position the TCP at a specified target position \( p = [x, y, z] \). The solution involves the following steps:

### Approach
1. **Compute \( q_2 \) using the z-coordinate**:
   - The z-coordinate of the TCP is determined by the angle \( q_2 \). Using the given link lengths and the z-component of the TCP position, we can solve for \( q_2 \) using the arccosine function.

2. **Compute \( \sin q_2 \) and \( B \)**:
   - Once \( q_2 \) is known, compute \( \sin q_2 \) and use it to find \( B \), which is a term used in the subsequent calculations for \( q_1 \).

3. **Solve for \( q_1 \) using the x and y coordinates**:
   - Using the x and y components of the TCP position, set up a system of equations to solve for \( \cos q_1 \) and \( \sin q_1 \). This involves computing the determinant of a matrix formed from the equations and using it to find the values of \( \cos q_1 \) and \( \sin q_1 \). The angle \( q_1 \) is then found using the arctangent function.

4. **Set \( q_3 \) to 0**:
   - Since the orientation of the TCP is not specified, \( q_3 \) can be set to 0 to simplify the solution.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x, y, z = p

    # Link lengths and offsets based on the problem details
    link2_offset = 0.13585  # Offset of link 2 from joint 2
    link3_offset = 0.1197   # Offset of link 3 from joint 3
    tcp_offset = 0.39225    # Offset of TCP from joint 3

    # Calculate q2 based on the z-coordinate
    z_target = z - 0.425  # Adjust z by the base height
    cos_q2 = z_target / tcp_offset

    # Clamp cos_q2 to prevent domain errors
    cos_q2 = max(min(cos_q2, 1.0), -1.0)
    q2 = math.acos(cos_q2)
    sin_q2 = math.sqrt(1 - cos_q2 ** 2)  # sin_q2 is non-negative as q2 is in [0, Ï€]

    # Calculate B
    B = tcp_offset * sin_q2

    # Calculate A using link offsets
    A = link2_offset + link3_offset

    # Calculate determinant
    det = B ** 2 - A ** 2

    if det == 0:
        # This case should not occur as per problem statement
        q1 = 0.0
    else:
        # Solve for cos_q1 and sin_q1
        cos_q1 = (B * x - A * y) / det
        sin_q1 = (-A * x - B * y) / det

        # Clamp values to handle floating point errors
        cos_q1 = max(min(cos_q1, 1.0), -1.0)
        sin_q1 = max(min(sin_q1, 1.0), -1.0)

        q1 = math.atan2(sin_q1, cos_q1)

    # Set q3 to 0 as orientation is not specified
    q3 = 0.0

    return (q1, q2, q3)
```

### Explanation
- **Computing \( q_2 \)**: The angle \( q_2 \) is derived from the z-coordinate of the TCP position using the arccosine function, considering the known link lengths.
- **Determining \( B \)**: This term is calculated using \( \sin q_2 \) and is essential for solving the system of equations for \( q_1 \).
- **Solving for \( q_1 \)**: By setting up and solving the system of equations for the x and y components, we determine \( \cos q_1 \) and \( \sin q_1 \). The angle \( q_1 \) is then found using the arctangent function.
- **Setting \( q_3 \) to 0**: Since the orientation of the TCP is not specified, \( q_3 \) is set to 0 to simplify the solution.

This approach ensures that the TCP reaches the specified position efficiently, leveraging geometric and trigonometric principles to solve the inverse kinematics problem.