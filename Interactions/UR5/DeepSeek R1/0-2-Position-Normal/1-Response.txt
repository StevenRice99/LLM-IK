To solve this problem, we need to determine the joint angles (θ1, θ2, θ3) for a 3-DOF robotic arm such that the Tool Center Point (TCP) reaches a specified target position (x, y, z). The solution involves decomposing the problem into rotational components and solving using geometric and trigonometric methods.

### Approach
1. **Determine θ1 (Rotation around Z-axis):** 
   The first joint (θ1) aligns the arm with the target's x-y projection. This is calculated using the arctangent function to find the angle between the x and y coordinates of the target.

2. **Project Target to Rotated Frame:**
   After determining θ1, the problem reduces to a 2D planar problem in the rotated frame. The radial distance (r) from the base to the target in the x-y plane and the adjusted z-coordinate (accounting for the initial offset) are computed.

3. **Solve for θ2 and θ3 (Planar 2R Arm):**
   Using the projected coordinates (r, z), we solve the inverse kinematics for a planar 2R (revolute-revolute) arm. The law of cosines is used to find θ3, and θ2 is derived using geometric relationships.

### Solution Code
```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x_target, y_target, z_target = p
    
    # Calculate theta1 to align with the x-y projection of the target
    theta1 = np.arctan2(y_target, x_target)
    
    # Project the target position into the rotated frame after theta1
    r = np.sqrt(x_target**2 + y_target**2)
    z_rot = z_target - 0.13585  # Adjust for the Y offset of joint 2
    
    # Link lengths from joint 2 to TCP (converted to planar problem)
    l1 = 0.425
    l2 = 0.39225
    
    # Distance from joint 2 to target in the rotated frame
    d = np.hypot(r, z_rot)
    
    # Check if the target is reachable (though problem states it is)
    if d > l1 + l2 or d < np.abs(l1 - l2):
        raise ValueError("Target unreachable")
    
    # Solve for theta3 using the law of cosines
    cos_theta3 = (d**2 - l1**2 - l2**2) / (2 * l1 * l2)
    theta3 = np.arccos(np.clip(cos_theta3, -1.0, 1.0))  # Ensure within valid range
    
    # Two possible solutions for theta3 (elbow up/down)
    theta3_1 = theta3
    theta3_2 = -theta3
    
    # Solve for theta2 using geometric relationships
    gamma = np.arctan2(z_rot, r)
    theta2_1 = gamma - np.arctan2(l2 * np.sin(theta3_1), l1 + l2 * np.cos(theta3_1))
    theta2_2 = gamma - np.arctan2(l2 * np.sin(theta3_2), l1 + l2 * np.cos(theta3_2))
    
    # Select the first solution (can be adjusted based on joint limits)
    theta2 = theta2_1
    theta3 = theta3_1
    
    return (theta1, theta2, theta3)
```

### Explanation
1. **θ1 Calculation:** The angle θ1 is determined using `np.arctan2(y_target, x_target)`, which aligns the arm with the target's x-y projection.
2. **Projection to Rotated Frame:** The target's coordinates are transformed into a rotated frame after θ1, simplifying the problem to 2D.
3. **Planar 2R Arm Solution:** Using the projected coordinates, the inverse kinematics for a planar 2R arm is solved. The law of cosines determines θ3, and geometric relationships yield θ2.

This approach efficiently decomposes the problem into manageable parts, leveraging trigonometric identities and geometric relationships to find the joint angles analytically.