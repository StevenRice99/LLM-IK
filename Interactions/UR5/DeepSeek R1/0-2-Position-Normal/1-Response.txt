To solve this problem, we need to determine the joint angles (θ1, θ2, θ3) for a 3-DOF robotic arm such that the Tool Center Point (TCP) reaches a specified target position (x, y, z). The solution involves deriving the inverse kinematics equations based on the given robot structure and solving them analytically.

### Approach
1. **Problem Analysis**: The robot has three revolute joints. The first joint rotates around the Z-axis, affecting the X and Y coordinates. The second and third joints rotate around the Y-axis, affecting the X and Z coordinates. The goal is to find the joint angles that position the TCP at the target coordinates.

2. **Key Equations**:
   - **θ1**: Determined by projecting the target position onto the XY plane and computing the angle using arctangent.
   - **θ2 and θ3**: Derived using geometric relationships and trigonometric identities to solve for the angles in a planar two-link system formed by the second and third joints.

3. **Steps**:
   - Compute the squared distance from the origin to the target.
   - Calculate the cosine of θ3 using the squared distance and known link lengths.
   - Solve for θ3 using the arccosine function, considering both positive and negative solutions.
   - For each θ3 solution, compute possible values for θ2 and θ1 using trigonometric identities and matrix inversion techniques.

### Solution Code
```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x, y, z = p
    B = 0.01615  # Derived from the 0.01615 offset in the y-component
    L1 = 0.425
    L2 = 0.39225
    
    D = x**2 + y**2 + z**2
    cos_theta3 = (D - 0.334746) / 0.33365625
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)  # Ensure valid arccos input
    
    theta3 = np.arccos(cos_theta3)
    theta3_solutions = [theta3, -theta3]
    
    for theta3 in theta3_solutions:
        A_squared = x**2 + y**2 - B**2
        if A_squared < 0:
            continue
        for A_sign in [1, -1]:
            A = A_sign * np.sqrt(A_squared)
            C = L1 + L2 * np.cos(theta3)
            S = L2 * np.sin(theta3)
            denom = C**2 + S**2
            if denom == 0:
                continue
            sin_theta2 = (C * A - S * z) / denom
            cos_theta2 = (S * A + C * z) / denom
            theta2 = np.arctan2(sin_theta2, cos_theta2)
            
            denom_theta1 = A**2 + B**2
            if denom_theta1 == 0:
                continue
            cos_theta1 = (A * x + B * y) / denom_theta1
            sin_theta1 = (-B * x + A * y) / denom_theta1
            theta1 = np.arctan2(sin_theta1, cos_theta1)
            
            return (theta1, theta2, theta3)
    
    return (0.0, 0.0, 0.0)
```

### Explanation
1. **Distance Calculation**: The squared distance from the origin to the target (D) is computed to determine the cosine of θ3.
2. **θ3 Calculation**: Using the derived formula, we compute the cosine of θ3 and ensure it is within valid bounds. Two solutions (positive and negative) for θ3 are considered.
3. **θ2 and θ1 Calculation**: For each θ3 solution, we compute possible values for θ2 using matrix inversion to solve the system of equations derived from the geometric relationships. θ1 is then determined using the arctangent function based on the target's X and Y coordinates.
4. **Validation**: The solution checks for valid trigonometric values and returns the first valid set of joint angles.

This approach efficiently decouples the problem into manageable parts, leveraging trigonometric identities and geometric relationships to find the joint angles analytically.