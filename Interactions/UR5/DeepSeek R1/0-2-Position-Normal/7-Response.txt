To solve this problem, we need to determine the joint angles (θ1, θ2, θ3) for a 3-DOF robotic arm such that the Tool Center Point (TCP) reaches a specified target position (x, y, z). The solution involves decomposing the problem into rotational components and solving using geometric and trigonometric methods, while correctly accounting for the robot's link offsets and joint rotations.

### Approach
1. **Determine θ1 (Rotation around Z-axis):** 
   The first joint (θ1) aligns the arm with the target's x-y projection using the arctangent function and solves a trigonometric equation to account for the link offsets.

2. **Calculate Intermediate Variables (S and C):** 
   Using the target coordinates and θ1, compute intermediate variables S and C which represent the contributions of the subsequent joints in the rotated frame.

3. **Solve for θ2 and θ3 (Planar 2R Arm):** 
   Using the intermediate variables, solve the system of trigonometric equations to find θ2 and θ3 using the law of cosines and geometric relationships.

### Solution Code
```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x, y, z = p
    D = 0.13585 - 0.1197  # Corrected D value
    a = 0.39225
    L1 = 0.425

    # Compute numerator for cos(theta3)
    numerator = x**2 + y**2 + z**2 - D**2 - L1**2 - a**2
    denominator = 2 * L1 * a
    if denominator == 0:
        raise ValueError("Denominator is zero")
    cos_theta3 = numerator / denominator
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)
    theta3_1 = np.arccos(cos_theta3)
    theta3_2 = -theta3_1

    solutions = []
    for theta3 in [theta3_1, theta3_2]:
        C1 = L1 + a * np.cos(theta3)
        C2 = a * np.sin(theta3)
        A_squared = x**2 + y**2 - D**2
        if A_squared < 0:
            continue  # Skip if A is imaginary, though problem states targets are reachable
        for A_sign in [1, -1]:
            A = A_sign * np.sqrt(A_squared)
            denom = C1**2 + C2**2
            if denom == 0:
                continue
            sin_theta2 = (C1 * A - C2 * z) / denom
            cos_theta2 = (C2 * A + C1 * z) / denom
            if abs(sin_theta2) > 1 or abs(cos_theta2) > 1:
                continue
            theta2 = np.arctan2(sin_theta2, cos_theta2)
            denom_theta1 = A**2 + D**2
            if denom_theta1 == 0:
                continue
            cos_theta1 = (A * x + D * y) / denom_theta1
            sin_theta1 = (-D * x + A * y) / denom_theta1
            theta1 = np.arctan2(sin_theta1, cos_theta1)
            solutions.append((theta1, theta2, theta3))

    if not solutions:
        raise ValueError("No valid solutions found")
    # Select the first solution (can apply additional criteria here)
    theta1, theta2, theta3 = solutions[0]
    return (theta1, theta2, theta3)
```

### Explanation
1. **θ1 Calculation:** The angle θ1 is determined by solving the trigonometric equation derived from the target's x and y coordinates, ensuring the correct alignment considering the link offsets.
2. **Intermediate Variables (S and C):** These variables are computed to simplify the subsequent calculations, representing the contributions of the arm's links in the rotated frame.
3. **θ2 and θ3 Calculation:** Using the intermediate variables, the solution involves solving a system of trigonometric equations to find the angles that position the TCP correctly. The law of cosines and geometric relationships are used to handle the planar 2R arm problem, ensuring the correct transformation from joint angles to the target position.

This approach accurately models the robotic arm's kinematics, considering all link offsets and joint rotations, ensuring the correct solution for the inverse kinematics problem.