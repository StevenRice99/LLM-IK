To solve the inverse kinematics for the 4-DOF manipulator, we first determine the joint angles using geometric decomposition. The first joint (θ₁) is solved using the existing code to align the arm in the x-y plane. The remaining joints (θ₂, θ₃, θ₄) are solved by transforming the target position into the plane of the subsequent joints and applying the existing planar solution for the 2-link arm formed by joints 3 and 4.

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    px, py, pz = p

    # Solve theta1 using existing code 1
    theta1 = math.atan2(-px, py)

    # Compute position relative to Revolute 2's origin
    x_r2 = -0.13585 * math.sin(theta1)
    y_r2 = 0.13585 * math.cos(theta1)
    dx = px - x_r2
    dy = py - y_r2
    dz = pz

    # Project into the plane for Revolute 2's Y rotation (x-z plane)
    r = math.hypot(dx, dy)
    target_planar = (r, 0, dz)

    # Solve for theta3 and theta4 using existing code 2 (treated as theta2 and theta3 here)
    theta3, theta4, _ = _existing_code2_solver(target_planar)

    # Compute theta2 to align the planar target
    theta2 = math.atan2(dz, r) - (theta3 + theta4)

    return (theta1, theta2, theta3, theta4)

def _existing_code2_solver(p):
    # Adapted from existing code 2 to solve for theta3 and theta4
    x_p, _, z_p = p
    A = 0.425
    B = 0.39225
    numerator = x_p**2 + z_p**2 - A**2 - B**2
    denominator = 2 * A * B
    cosθ2 = numerator / denominator
    cosθ2 = max(min(cosθ2, 1.0), -1.0)
    θ2_1 = math.acos(cosθ2)
    θ2_2 = -θ2_1
    solutions = []
    for θ2 in [θ2_1, θ2_2]:
        C = A + B * math.cos(θ2)
        D = B * math.sin(θ2)
        denominator_θ1 = x_p**2 + z_p**2
        if denominator_θ1 == 0:
            continue
        sinθ1 = (C * x_p - D * z_p) / denominator_θ1
        cosθ1 = (D * x_p + C * z_p) / denominator_θ1
        θ1 = math.atan2(sinθ1, cosθ1)
        x = A * math.sin(θ1) + B * math.sin(θ1 + θ2)
        z = A * math.cos(θ1) + B * math.cos(θ1 + θ2)
        error = (x - x_p)**2 + (z - z_p)**2
        solutions.append((error, θ1, θ2))
    solutions.sort()
    best_θ1, best_θ2 = (solutions[0][1], solutions[0][2]) if solutions else (0.0, 0.0)
    return (best_θ1, best_θ2, 0.0)
```