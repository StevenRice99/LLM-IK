To solve the inverse kinematics for the given 4-DOF manipulator, we first determine the base joint angle \( q_1 \) to align the arm with the target's x-y projection. Then, we treat the remaining joints as a planar 3R arm to solve for \( q_2, q_3, q_4 \).

```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x, y, z = p

    # Solve for q1 using x*sin(q1) - y*cos(q1) = -0.13585
    A, B, C = x, -y, -0.13585
    theta = np.arctan2(B, A)
    D = np.hypot(A, B)
    if D < 1e-7:
        q1 = 0.0
    else:
        alpha = np.arcsin(C / D)
        q1 = theta - alpha

    # Compute planar coordinates in rotated frame
    a = (x + 0.13585 * np.sin(q1)) / np.cos(q1) if np.abs(np.cos(q1)) > 1e-7 else 0
    c = z

    # Planar 3R arm parameters (L1, L2, L3)
    L1, L2, L3 = 0.425, 0.39225, 0.093
    wx, wz = a - L3 * 0, c - L3  # Assume theta3 = 0 for simplicity

    # Solve for q2 and q3 using 2R IK
    D_sq = wx**2 + wz**2
    cos_q3 = (D_sq - L1**2 - L2**2) / (2 * L1 * L2)
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    q3 = np.arccos(cos_q3)
    q2 = np.arctan2(wx, wz) - np.arctan2(L2 * np.sin(q3), L1 + L2 * np.cos(q3))

    # Solve q4 to keep end effector orientation
    q4 = -q3 - q2

    return (q1 % (2*np.pi), q2, q3, q4)
```