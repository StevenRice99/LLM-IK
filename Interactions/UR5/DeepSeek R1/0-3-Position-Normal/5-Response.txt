To solve the inverse kinematics for the 4-DOF manipulator, we need to accurately compute the joint angles to reach the target position. The key corrections involve deriving the correct equation for the first joint and properly handling the planar arm parameters.

### Approach
1. **Correct First Joint Calculation (q1):** The first joint angle is determined by ensuring the target's projection onto the XY plane is reachable by the subsequent planar arm. The correct equation is derived using geometric constraints.
2. **Planar Arm Parameters:** The lengths of the links in the planar arm are adjusted to include the end effector's offset, simplifying the problem to a 2R inverse kinematics problem.
3. **Multiple Solutions Handling:** Both possible solutions for the third joint (elbow-up and elbow-down) are considered to ensure the correct configuration is selected.
4. **Orientation Maintenance:** The fourth joint angle is set to maintain the end effector's orientation by ensuring the sum of the joint angles (q2 + q3 + q4) is zero.

### Solution Code
```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x, y, z = p

    # Correct equation for q1 derived from geometric constraints
    # Solve: -x*sin(q1) + y*cos(q1) = 0.13585*(cos(2*q1))
    # Using substitution and trigonometric identities to find closed-form solution
    a = 0.13585
    numerator = a**2 - x**2 - y**2
    denominator = 2 * a * y
    if abs(denominator) < 1e-7:
        q1 = np.pi/2 if y > 0 else -np.pi/2
    else:
        q1 = 2 * np.arctan((x + np.sqrt(x**2 + y**2 - a**2)) / (y + a))
    
    # Ensure q1 is within the correct quadrant
    q1 = np.arctan2(np.sin(q1), np.cos(q1))  # Normalize angle

    # Transform target to Revolute 2's coordinate system
    dx = (x * np.cos(q1) + y * np.sin(q1) - a) / np.cos(q1) if abs(np.cos(q1)) > 1e-7 else 0
    dz = z

    # Planar arm parameters including TCP offset
    L1 = 0.425
    L2 = 0.39225 + 0.093  # Combine L2 and TCP offset

    # Solve 2R IK for planar arm
    D_sq = dx**2 + dz**2
    cos_q3 = (D_sq - L1**2 - L2**2) / (2 * L1 * L2)
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    q3 = np.arccos(cos_q3)

    # Two possible solutions for q3
    q3_neg = -q3

    # Calculate corresponding q2 for both solutions
    angle_offset_pos = np.arctan2(L2 * np.sin(q3), L1 + L2 * np.cos(q3))
    q2_pos = np.arctan2(dx, dz) - angle_offset_pos

    angle_offset_neg = np.arctan2(L2 * np.sin(q3_neg), L1 + L2 * np.cos(q3_neg))
    q2_neg = np.arctan2(dx, dz) - angle_offset_neg

    # Select solution based on feasibility (elbow up/down)
    if L1 + L2 * np.cos(q3_neg) >= 0:
        q2, q3 = q2_neg, q3_neg
    else:
        q2, q3 = q2_pos, q3

    # Adjust q4 to maintain end effector orientation
    q4 = - (q2 + q3)

    return (q1 % (2 * np.pi), q2, q3, q4)
```

### Explanation
1. **First Joint (q1):** The angle is calculated using a derived equation that ensures the target's projection is within the reachable workspace of the planar arm. This involves solving a trigonometric equation using substitution and normalization to handle different quadrants.
2. **Planar Arm Calculation:** The problem is simplified to a 2R inverse kinematics problem by combining the lengths of the last two links and the end effector. This allows solving for the second and third joints using geometric methods.
3. **Multiple Solutions Handling:** Both possible solutions for the third joint are considered, and the appropriate solution is selected based on geometric feasibility to avoid singularities.
4. **Orientation Maintenance:** The fourth joint angle is determined to ensure the end effector's orientation remains consistent by balancing the sum of the joint angles.

This approach addresses the issues in the previous solution by correctly deriving the first joint angle equation and properly handling the planar arm parameters, ensuring accurate and feasible joint configurations for all reachable targets.