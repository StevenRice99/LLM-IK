To solve the inverse kinematics for the 4-DOF manipulator, we need to accurately compute the joint angles to reach a target position by considering the geometric configuration of the links and their respective transformations.

### Approach
1. **Base Rotation (θ₁)**: Calculate the rotation around the Z-axis to align the arm with the target's x-y direction using `atan2(y, x)`.
2. **Planar Adjustment**: Convert the target position into the rotated coordinate system and adjust for the height of the second joint.
3. **Geometric Solution**: Use the law of cosines and trigonometric identities to solve for the remaining joint angles (θ₂, θ₃, θ₄) in the Y-Z plane, considering the link lengths and TCP offset.

### Solution Code
```python
import numpy as np
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x, y, z = p
    # Calculate θ₁ to align with target's x-y direction
    theta1 = math.atan2(y, x)
    
    # Radial distance in x-y plane after θ₁ rotation
    r = math.hypot(x, y)
    
    # Adjust target to the rotated frame (Y-Z plane) and joint2's position
    z_rel = z - 0.13585  # Joint2's Z offset is 0.13585
    
    # Effective link lengths (from URDF data)
    L1 = math.hypot(0.1197, 0.425)  # Joint2 to Joint3
    L2 = 0.39225                    # Joint3 to Joint4
    L3 = 0.093                       # Joint4 to TCP
    L_total = L1 + L2 + L3          # Maximum reach
    
    # Distance from joint2 to target in the Y-Z plane
    d = math.hypot(r, z_rel)
    
    # Check if target is within reach (though problem states it's reachable)
    if d > L_total or d < abs(L1 - (L2 + L3)):
        raise ValueError("Target out of reach")  # Should not happen per problem statement
    
    # Law of cosines to find angle between L1 and (L2 + L3)
    cos_theta3 = (L1**2 + (L2 + L3)**2 - d**2) / (2 * L1 * (L2 + L3))
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)
    theta3 = -math.acos(cos_theta3)  # Negative due to joint direction
    
    # Angle from joint2 to target
    alpha = math.atan2(z_rel, r)
    
    # Angle between L1 and the line to target
    beta = math.asin(((L2 + L3) * math.sin(-theta3)) / d)
    theta2 = alpha - beta
    
    # Theta4 is determined to align TCP's Y offset (simplified to zero for planar)
    theta4 = - (theta2 + theta3)  # Maintain orientation
    
    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Base Rotation**: The first joint (θ₁) aligns the arm with the target's x-y projection.
2. **Planar Adjustment**: The target's position is adjusted to the coordinate system after θ₁ rotation, considering the height of the second joint.
3. **Geometric Solution**: Using the law of cosines, the angles θ₂ and θ₃ are computed to position the links such that the TCP reaches the target. The angle θ₄ is adjusted to maintain the correct orientation, ensuring the TCP's offset is accounted for.

This approach ensures that all joint angles are computed accurately while adhering to the manipulator's geometric constraints.