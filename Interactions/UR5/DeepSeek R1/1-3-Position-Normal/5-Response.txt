To solve this problem, we need to determine the joint angles (θ1, θ2, θ3) for a 3-DOF serial manipulator such that the Tool Center Point (TCP) reaches a specified target position (x, y, z). The key challenge is to correctly compute the joint angles using inverse kinematics, considering both possible configurations (elbow-up and elbow-down) to ensure the correct solution is chosen.

### Approach
1. **Problem Analysis**: The robot's structure involves three revolute joints rotating around the Y-axis. The TCP's position is derived from the forward kinematics, which involves transformations through each joint. The third joint's rotation does not affect the TCP's position, simplifying the problem to solving for θ1 and θ2.
2. **Key Equations**: Using geometric and trigonometric relationships, we derive equations for θ1 and θ2 based on the target position (x, z). The y-coordinate is fixed due to the robot's structure.
3. **Solution Strategy**: 
   - Use the Law of Cosines to solve for θ2, considering both possible solutions (elbow-up and elbow-down).
   - Use trigonometric identities to solve for θ1 based on each θ2 solution.
   - Compute the forward kinematics for each (θ1, θ2) pair to determine which configuration reaches the target position accurately.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x_p, y_p, z_p = p
    A = 0.425  # Length from Revolute1 to Revolute2
    B = 0.39225  # Length from Revolute2 to Revolute3

    # Calculate cosθ2 using the law of cosines
    numerator = x_p**2 + z_p**2 - A**2 - B**2
    denominator = 2 * A * B
    if denominator == 0:
        return (0.0, 0.0, 0.0)
    cosθ2 = numerator / denominator
    cosθ2 = max(min(cosθ2, 1.0), -1.0)  # Clamp to avoid domain error

    # Compute both possible θ2 solutions
    θ2_1 = math.acos(cosθ2)
    θ2_2 = -θ2_1

    solutions = []
    for θ2 in [θ2_1, θ2_2]:
        C = A + B * math.cos(θ2)
        D = B * math.sin(θ2)

        denominator_θ1 = x_p**2 + z_p**2
        if denominator_θ1 == 0:
            continue

        sinθ1 = (C * x_p - D * z_p) / denominator_θ1
        cosθ1 = (D * x_p + C * z_p) / denominator_θ1

        θ1 = math.atan2(sinθ1, cosθ1)

        # Compute expected position using forward kinematics
        x = A * math.sin(θ1) + B * math.sin(θ1 + θ2)
        z = A * math.cos(θ1) + B * math.cos(θ1 + θ2)

        error = (x - x_p)**2 + (z - z_p)**2
        solutions.append((error, θ1, θ2))

    if not solutions:
        return (0.0, 0.0, 0.0)

    # Select the solution with the smallest error
    solutions.sort()
    best_θ1, best_θ2 = solutions[0][1], solutions[0][2]

    return (best_θ1, best_θ2, 0.0)
```

### Explanation
1. **Law of Cosines for θ2**: The target position's x and z coordinates are used to compute the angle θ2 using the Law of Cosines, which relates the lengths of the robot's links to the target position. This gives two possible solutions for θ2 (elbow-up and elbow-down).
2. **Trigonometric Solution for θ1**: For each θ2 solution, we compute θ1 using trigonometric identities. This involves solving a system of linear equations derived from the forward kinematics equations.
3. **Validation via Forward Kinematics**: Each (θ1, θ2) pair is used to compute the expected TCP position using forward kinematics. The solution with the smallest error between the computed and target positions is selected, ensuring accuracy.

This approach efficiently solves the inverse kinematics problem by considering both possible configurations and validating them through forward kinematics, ensuring the correct solution is chosen.