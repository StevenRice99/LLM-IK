To solve this problem, we need to determine the joint angles for a 4-DOF robotic arm to reach a given target position (x, y, z). The solution involves calculating the angles for the first three joints (theta1, theta2, theta3) to position the end-effector correctly, while the fourth joint (theta4) does not affect the position and can be set to zero.

### Approach
1. **Adjust Target Position**: The target position (x, z) is adjusted to account for the offset from the end-effector to the fourth joint. This adjustment helps in solving the inverse kinematics for the first three joints.
2. **Inverse Kinematics for First Two Joints**: Using trigonometric identities and the law of cosines, we compute the angles for the first two joints (theta1, theta2) to reach the adjusted target position.
3. **Calculate Theta3**: The angle theta3 is determined to ensure the cumulative rotation from the first three joints aligns the end-effector's offset correctly with the target position.
4. **Fourth Joint**: Since the fourth joint's rotation does not affect the position, its angle (theta4) is set to zero.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p
    L1 = 0.425
    L2 = 0.39225
    L3 = 0.09465  # TCP offset from Revolute4

    # Compute the adjusted target for Revolute3
    D = math.hypot(x_target, z_target)
    if D == 0:
        # Target is at the origin; handle as a special case
        theta1 = 0.0
        theta2 = 0.0
        theta3 = 0.0
    else:
        scale = (D - L3) / D
        x_eff = x_target * scale
        z_eff = z_target * scale

        # Solve for theta1 and theta2 using the adjusted target
        r = math.hypot(x_eff, z_eff)
        cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)
        cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
        theta2 = math.acos(cos_theta2)
        beta = math.atan2(x_eff, z_eff)
        alpha = math.atan2(L2 * math.sin(theta2), L1 + L2 * math.cos(theta2))
        theta1 = beta - alpha

        # Compute Revolute3's position
        x3 = L1 * math.sin(theta1) + L2 * math.sin(theta1 + theta2)
        z3 = L1 * math.cos(theta1) + L2 * math.cos(theta1 + theta2)

        # Compute theta3 to align TCP's offset
        dx = x_target - x3
        dz = z_target - z3
        gamma = math.atan2(dx, dz)
        theta3 = gamma - (theta1 + theta2)

    # Theta4 does not affect the position, set to 0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Adjust Target Position**: The target position (x, z) is scaled towards the base by a factor of (D - L3)/D, where D is the distance from the base to the target. This adjustment ensures that the third joint (Revolute3) is positioned such that the end-effector's offset (L3) can reach the target.
2. **Inverse Kinematics for Theta1 and Theta2**: Using the adjusted target, the angles theta1 and theta2 are computed using trigonometric methods and the law of cosines. This involves solving a 2-link inverse kinematics problem.
3. **Calculate Theta3**: The position of Revolute3 is computed using theta1 and theta2. The angle gamma, which is the direction from Revolute3 to the target, is then used to determine theta3, ensuring the end-effector's offset aligns with the target.
4. **Theta4**: Since the fourth joint's rotation does not affect the position, it is set to zero. This joint could be used for orientation if needed, but for position control, it remains zero.

This approach efficiently computes the required joint angles using closed-form solutions, ensuring the robotic arm reaches the desired position.