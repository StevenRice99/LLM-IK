To solve this problem, we need to determine the joint angles (theta1, theta2, theta3, theta4) for a 4-DOF robotic arm to position its end-effector (TCP) at a given target position (x, y, z). The solution involves decomposing the problem into two parts: positioning the first two joints to reach a point that allows the third joint to adjust to the target, and then calculating the third joint angle to reach the exact target.

### Approach
1. **Adjust Target for Third Link**: Compute an intermediate target position (x_j3, z_j3) that is a fixed distance away from the actual target, accounting for the length of the third link and the TCP.
2. **Solve Two-Link Inverse Kinematics**: Use the intermediate target to solve for the first two joint angles (theta1 and theta2) using a two-link inverse kinematics solution.
3. **Calculate Third Joint Angle**: Determine the angle needed for the third joint to adjust from the intermediate position to the actual target.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p
    A = 0.425      # Length of the first link (Revolute 2)
    B = 0.39225    # Length of the second link (Revolute 3)
    C = 0.09465    # Length from Revolute 4 to TCP
    
    # Calculate the intermediate target (x_j3, z_j3) which is C units away from the actual target
    D = math.hypot(x_target, z_target)
    if D < 1e-6:
        # Handle the case where the target is at the origin
        theta1 = 0.0
        theta2 = 0.0
        theta3 = 0.0
    else:
        # Direction to the target
        dir_target = math.atan2(x_target, z_target)
        # Intermediate target is C units behind the actual target along the direction
        x_j3 = x_target - C * math.sin(dir_target)
        z_j3 = z_target - C * math.cos(dir_target)
        
        # Solve two-link inverse kinematics for the intermediate target
        dx = x_j3
        dz = z_j3
        d_sq = dx ** 2 + dz ** 2
        cos_theta2 = (d_sq - A**2 - B**2) / (2 * A * B)
        cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
        theta2 = math.acos(cos_theta2)
        
        gamma = math.atan2(dx, dz)
        delta = math.atan2(B * math.sin(theta2), A + B * math.cos(theta2))
        theta1 = gamma - delta
        
        # Calculate the angle needed for the third joint to reach the actual target
        # Current direction after theta1 and theta2
        current_angle = theta1 + theta2
        # Desired direction from intermediate to target
        desired_angle = math.atan2(x_target - x_j3, z_target - z_j3)
        theta3 = desired_angle - current_angle
    
    # Theta4 is 0 as per the test cases
    theta4 = 0.0
    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Intermediate Target Calculation**: The intermediate target (x_j3, z_j3) is computed by moving a fixed distance (C) away from the actual target along the line connecting the base to the target. This ensures that the third link can adjust to reach the target.
2. **Two-Link Inverse Kinematics**: The first two joint angles (theta1 and theta2) are determined using the intermediate target. This involves solving a two-link inverse kinematics problem using geometric methods (Law of Cosines and Arctangent functions).
3. **Third Joint Adjustment**: The third joint angle (theta3) is calculated as the difference between the desired direction from the intermediate target to the actual target and the current direction after the first two joints. This adjustment ensures the TCP reaches the exact target position.

This approach efficiently combines geometric calculations and inverse kinematics principles to solve the problem for a 4-DOF robotic arm, ensuring the end-effector reaches the desired target position.