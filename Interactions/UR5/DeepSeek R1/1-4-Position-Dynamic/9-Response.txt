To solve this problem, we need to determine the joint angles (theta1, theta2, theta3, theta4) for a 4-DOF robotic arm to position its end-effector (TCP) at a given target position (x, y, z). The solution involves decomposing the problem into two parts: positioning the first two joints to reach an intermediate target and adjusting the third joint to reach the exact target.

### Approach
1. **Adjust Target for Third Link**: Compute an intermediate target position (x', z') by subtracting the contribution of the third link (0.18765 units) in the direction of the target.
2. **Solve Two-Link Inverse Kinematics**: Use the intermediate target to solve for the first two joint angles (theta1 and theta2) using a two-link inverse kinematics solution, considering both elbow-up and elbow-down configurations.
3. **Calculate Third Joint Angle**: Determine the angle needed for the third joint (theta3) to align the third link from the intermediate position to the actual target.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p
    a = 0.425       # Length of the first link (Revolute 1 to Revolute 2)
    b = 0.39225     # Length of the second link (Revolute 2 to Revolute 3)
    c = 0.18765     # Combined length of Revolute 3 to Revolute 4 and TCP
    
    # Calculate the direction to the target
    phi = math.atan2(x_target, z_target)
    
    # Adjust target by c in the direction of phi to get intermediate target
    x_prime = x_target - c * math.sin(phi)
    z_prime = z_target - c * math.cos(phi)
    
    # Solve two-link inverse kinematics for the adjusted target
    dx = x_prime
    dz = z_prime
    d_sq = dx ** 2 + dz ** 2
    
    # Compute theta2 with both possible signs (elbow-up and elbow-down)
    cos_theta2 = (d_sq - a**2 - b**2) / (2 * a * b)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_positive = math.acos(cos_theta2)
    theta2_negative = -theta2_positive
    
    # Calculate possible solutions for theta1 and theta3
    gamma = math.atan2(dx, dz)
    
    # Elbow-up solution
    delta_up = math.atan2(b * math.sin(theta2_positive), a + b * math.cos(theta2_positive))
    theta1_up = gamma - delta_up
    theta3_up = phi - (theta1_up + theta2_positive)
    
    # Elbow-down solution
    delta_down = math.atan2(b * math.sin(theta2_negative), a + b * math.cos(theta2_negative))
    theta1_down = gamma - delta_down
    theta3_down = phi - (theta1_down + theta2_negative)
    
    # Select the solution that minimizes the absolute value of theta3
    if abs(theta3_up) <= abs(theta3_down):
        theta1, theta2, theta3 = theta1_up, theta2_positive, theta3_up
    else:
        theta1, theta2, theta3 = theta1_down, theta2_negative, theta3_down
    
    # Theta4 is 0 as per the test cases
    theta4 = 0.0
    
    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Intermediate Target Calculation**: The intermediate target (x', z') is computed by moving a fixed distance (c) away from the actual target along the line connecting the base to the target. This ensures that the third link can adjust to reach the target.
2. **Two-Link Inverse Kinematics**: The first two joint angles (theta1 and theta2) are determined using the intermediate target. This involves solving a two-link inverse kinematics problem using geometric methods (Law of Cosines and Arctangent functions), considering both elbow-up and elbow-down configurations to find the optimal solution.
3. **Third Joint Adjustment**: The third joint angle (theta3) is calculated as the difference between the desired direction from the intermediate target to the actual target and the current direction after the first two joints. This adjustment ensures the TCP reaches the exact target position.

This approach efficiently combines geometric calculations and inverse kinematics principles to solve the problem for a 4-DOF robotic arm, ensuring the end-effector reaches the desired target position.