To solve this problem, we need to determine the joint angles for a 4-DOF robotic arm to reach a specified target position. The solution involves extending an existing 3-DOF inverse kinematics solution to include the fourth joint and adjusting for the TCP's offset.

### Approach
1. **Existing 3-DOF Solution**: The provided code solves the inverse kinematics for the first three joints (theta1, theta2, theta3) to position the end of the third link. This solution is based on the planar geometry of the first three links.
2. **Fourth Joint Adjustment**: The fourth joint (theta4) rotates around the Z-axis and affects the orientation of the TCP. However, since the TCP's position is offset along the Z-axis of the fourth link's frame, the fourth joint's rotation does not affect the TCP's position in the X and Z directions. The Y-component of the TCP's position is adjusted using the fourth joint's rotation.
3. **Y-Component Adjustment**: The Y-component of the TCP's position is influenced by the fourth joint's rotation. We compute theta4 to adjust the Y-component to match the target position.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p

    # Existing solution for the first three joints (theta1, theta2, theta3=0)
    l1 = 0.425
    l2 = 0.39225
    r = math.sqrt(x_target ** 2 + z_target ** 2)
    cos_theta2 = (r ** 2 - l1 ** 2 - l2 ** 2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_target, z_target)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha
    theta3 = 0.0

    # Calculate theta_sum for the first three joints
    theta_sum = theta1 + theta2 + theta3
    sin_theta_sum = math.sin(theta_sum)

    # Compute theta4 to adjust the Y component
    y_offset = y_target + 0.0267  # Adjust for Revolute 4's origin y position
    if abs(sin_theta_sum) < 1e-6:
        theta4 = 0.0  # Singularity case, assume theta4 has no effect
    else:
        scaled_y = y_offset / (0.09465 * sin_theta_sum)
        scaled_y = max(min(scaled_y, 1.0), -1.0)
        theta4 = math.asin(scaled_y)

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Existing 3-DOF Solution**: The code first computes theta1 and theta2 using geometric inverse kinematics for the planar arm formed by the first three links. The third joint (theta3) is set to zero as per the existing solution.
2. **Theta Sum Calculation**: The sum of the first three joint angles (theta_sum) is used to determine the orientation of the third link.
3. **Fourth Joint Adjustment**: The fourth joint angle (theta4) is computed to adjust the Y-component of the TCP's position. This is done by solving for theta4 such that the Y-component of the TCP's position matches the target, considering the offset from Revolute 4's origin.

This approach leverages the existing solution for the first three joints and extends it to include the fourth joint, ensuring the TCP reaches the desired position by adjusting the Y-component using the fourth joint's rotation.