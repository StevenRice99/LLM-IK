To solve this problem, we need to determine the joint angles for a 4-DOF robotic arm to reach a specified target position. The solution involves extending an existing 3-DOF inverse kinematics solution to include the fourth joint and adjusting for the TCP's offset.

### Approach
1. **Existing 3-DOF Solution**: The provided code solves the inverse kinematics for the first three joints (theta1, theta2, theta3) to position the end of the third link. This solution is based on the planar geometry of the first three links.
2. **Fourth Joint Adjustment**: The fourth joint (theta4) rotates around the Z-axis and affects the orientation of the TCP. However, since the TCP's position is offset along the Z-axis of the fourth link's frame, the fourth joint's rotation does not affect the TCP's position in the X and Z directions. The Y-component of the TCP's position is fixed due to the cumulative Y offsets of the links.
3. **Y-Component Adjustment**: The Y-component of the TCP's position is fixed at -0.0267, which is determined by the link offsets. Therefore, the target Y-component must be -0.0267, and the code does not need to adjust for it.
4. **Three-Joint Solution**: The first three joints (theta1, theta2, theta3) are solved using a 3R planar arm inverse kinematics approach, considering the TCP's offset.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p

    # Link lengths
    l1 = 0.425
    l2 = 0.39225
    l3 = 0.09465  # TCP's offset along Revolute4's Z-axis

    # Calculate the target angle for the TCP's offset direction
    theta_sum = math.atan2(x_target, z_target)

    # Adjusted target for the first two links (Revolute4's origin)
    x_adj = x_target - l3 * math.sin(theta_sum)
    z_adj = z_target - l3 * math.cos(theta_sum)

    # Solve for theta1 and theta2 using the adjusted target
    r_adj = math.sqrt(x_adj**2 + z_adj**2)
    cos_theta2 = (r_adj**2 - l1**2 - l2**2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_adj, z_adj)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha

    # Compute theta3 to account for the TCP's offset
    theta3 = theta_sum - theta1 - theta2

    # Theta4 does not affect position, set to 0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Target Adjustment**: The target position is adjusted to account for the TCP's offset. This adjustment is based on the angle `theta_sum`, which represents the direction from the base to the target.
2. **Two-Joint Solution**: The first two joints (theta1 and theta2) are solved using the adjusted target position, which positions Revolute4's origin such that the TCP's offset will reach the target.
3. **Third Joint Adjustment**: The third joint (theta3) is computed to align the TCP's offset with the target position.
4. **Fourth Joint**: The fourth joint (theta4) does not affect the position and is set to zero.

This approach ensures that all three joints (theta1, theta2, theta3) are used to position the TCP correctly, while theta4 is set to zero as it does not influence the position.