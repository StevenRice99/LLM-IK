To solve this problem, we need to determine the joint angles for a 4-DOF robotic arm to reach a specified target position. The solution involves extending an existing 3-DOF inverse kinematics solution to include the fourth joint and adjusting for the TCP's offset.

### Approach
1. **Existing 3-DOF Solution**: The provided code solves the inverse kinematics for the first three joints (theta1, theta2, theta3) to position the end of the third link. This solution is based on the planar geometry of the first three links.
2. **Fourth Joint Adjustment**: The fourth joint (theta4) rotates around the Z-axis and affects the orientation of the TCP. However, since the TCP's position is offset along the Z-axis of the fourth link's frame, the fourth joint's rotation does not affect the TCP's position in the X and Z directions. The Y-component of the TCP's position is fixed due to the cumulative Y offsets of the links.
3. **Three-Joint Solution**: The first three joints (theta1, theta2, theta3) are solved using a 3R planar arm inverse kinematics approach, considering the TCP's offset. The target position is adjusted by subtracting the contribution of the third link's offset, and the first two joints are solved to reach this adjusted target. The third joint angle is computed based on the remaining angle to align the TCP with the target.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p

    # Link lengths
    A = 0.425
    B = 0.39225
    C = 0.09465  # TCP's offset

    # Calculate the angle to the target
    theta_target = math.atan2(x_target, z_target)

    # Adjust the target by subtracting the TCP's offset contribution
    x_adj = x_target - C * math.sin(theta_target)
    z_adj = z_target - C * math.cos(theta_target)

    # Solve for the first two joints using the adjusted target
    r_adj = math.sqrt(x_adj**2 + z_adj**2)
    cos_theta2 = (r_adj**2 - A**2 - B**2) / (2 * A * B)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_adj, z_adj)
    alpha = math.atan2(B * math.sin(theta2), A + B * math.cos(theta2))
    theta1 = beta - alpha

    # Compute theta3 to align the TCP with the target
    theta3 = theta_target - (theta1 + theta2)

    # Theta4 does not affect position, set to 0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Target Adjustment**: The target position is adjusted by subtracting the contribution of the TCP's offset in the direction of the target. This adjustment ensures that the first two joints position the third joint's origin such that the third link can reach the target.
2. **Two-Joint Solution**: The first two joints (theta1 and theta2) are solved using the adjusted target position, which positions Revolute3's origin such that the TCP's offset will reach the target.
3. **Third Joint Adjustment**: The third joint (theta3) is computed as the difference between the target angle and the sum of the first two joint angles, ensuring the TCP's offset aligns with the target.
4. **Fourth Joint**: The fourth joint (theta4) does not affect the position and is set to zero.

This approach ensures that all three joints (theta1, theta2, theta3) are used to position the TCP correctly, while theta4 is set to zero as it does not influence the position.