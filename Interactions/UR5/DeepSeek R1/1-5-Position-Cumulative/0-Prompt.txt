<INSTRUCTIONS>
You are tasked with producing a closed-form analytical solution for the inverse kinematics of the 5 degrees-of-freedom serial manipulator solving for the position of the TCP as detailed in the "DETAILS" section by completing the Python function provided in the "CODE" section. The "Position" and "Orientation" columns represent link coordinates in local space relative to their parent link. The positions are from the "xyz" attribute and the orientations are the "rpy" attribute from each link's "origin" element parsed from the URDF. The "Axis" column in the table represents the rotational axis of the revolute links; return their values in radians and their limits are in radians. Do not write any code to run or test the method, as this will be handled for you. Assume all targets given as inputs to the method will be reachable, and as such do not write code to check if the target is reachable. You may use any methods included in Python, NumPy, and SymPy to write your solution except for any optimization methods. To help you, solutions for sub-chains have been provided in the "EXISTING" sections. Each code solved a sub-link assuming their last link was the target being solved for. You can use these solutions as a starting point to extend for the entire chain.
Existing code 1 solved joint 2.
Existing code 2 solved joints 2 to 3.
Existing code 3 solved joints 2 to 4.
Existing code 4 solved joint 3.
Existing code 5 solved joints 3 to 4.
Existing code 6 solved joints 3 to 5.
Existing code 7 solved joints 3 to 6.
Existing code 8 solved joint 4.
Existing code 9 solved joints 4 to 5.
Existing code 10 solved joints 4 to 6.
Existing code 11 solved joint 5.
Existing code 12 solved joints 5 to 6.
Existing code 13 solved joint 6.
 You may respond by either completing the inverse kinematics method or calling either of the two provided functions in the "FUNCTIONS" section to help you develop your solution. If you call a function, you will be provided another response and chance to complete the inverse kinematics method. You may only call a single function per response.
</INSTRUCTIONS>
<DETAILS>
 Link       | Position            | Orientation         | Axis   | Limits
------------+---------------------+---------------------+--------+-------------------------
 Revolute 1 | [0, 0, 0]           | [0, 0, 0]           | Y      | [-6.2831853, 6.2831853]
 Revolute 2 | [0, -0.1197, 0.425] | [0, 0, 0]           | Y      | [-6.2831853, 6.2831853]
 Revolute 3 | [0, 0, 0.39225]     | [0, 0, 0]           | Y      | [-6.2831853, 6.2831853]
 Revolute 4 | [0, 0.093, 0]       | [0, 0, 0]           | Z      | [-6.2831853, 6.2831853]
 Revolute 5 | [0, 0, 0.09465]     | [0, 0, 0]           | Y      | [-6.2831853, 6.2831853]
 TCP        | [0, 0.0823, 0]      | [0, 0, 1.570796325] |        |
</DETAILS>
<CODE>
def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
</CODE>
<EXISTING 1>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> float:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set the link to for reaching position "p".
    """
    x_target = p[0]
    z_target = p[2]
    theta = -math.atan2(-x_target, z_target)
    return theta
</EXISTING 1>
<EXISTING 2>
import math
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x_target = p[0]
    y_target = p[1]
    z_target = p[2]
    l1 = 0.425
    l2 = 0.39225
    y_offset = -0.1197
    r = math.sqrt(x_target ** 2 + z_target ** 2)
    cos_theta2 = (r ** 2 - l1 ** 2 - l2 ** 2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_target, z_target)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha
    return (theta1, theta2)
</EXISTING 2>
<EXISTING 3>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x_target, y_target, z_target = p
    l1 = 0.425
    l2 = 0.39225
    r = math.sqrt(x_target ** 2 + z_target ** 2)
    cos_theta2 = (r ** 2 - l1 ** 2 - l2 ** 2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_target, z_target)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha
    theta3 = 0.0
    return (theta1, theta2, theta3)
</EXISTING 3>
<EXISTING 4>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> float:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set the link to for reaching position "p".
    """
    x, y, z = p
    theta = math.atan2(x, z)
    return theta
</EXISTING 4>
<EXISTING 5>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the joints to for reaching position "p".
    """
    x, y, z = p
    theta1 = math.atan2(x, z)
    theta2 = 0.0
    return (theta1, theta2)
</EXISTING 5>
<EXISTING 6>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    x, y, z = p
    a = 0.39225
    b = 0.09465
    d_sq = x ** 2 + z ** 2
    cos_theta2 = (d_sq - a ** 2 - b ** 2) / (2 * a * b)
    cos_theta2 = max(min(cos_theta2, 1), -1)
    theta2 = math.acos(cos_theta2)
    gamma = math.atan2(x, z)
    delta = math.atan2(b * math.sin(theta2), a + b * math.cos(theta2))
    theta1 = gamma - delta
    theta3 = 0.0
    return (theta1, theta2, theta3)
</EXISTING 6>
<EXISTING 7>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p
    y_offset = y_target - 0.093
    if abs(y_offset) > 0.0823:
        raise ValueError('Target y is out of reach')
    theta3 = math.acos(y_offset / 0.0823)
    sin_theta3 = math.sin(theta3)
    cos_theta3 = math.cos(theta3)
    A = 0.39225
    B = 0.09465
    C = 0.0823 * sin_theta3
    M_val = B * x_target + C * z_target
    N_val = B * z_target - C * x_target
    K_val = (x_target ** 2 + z_target ** 2 + B ** 2 + C ** 2 - A ** 2) / 2
    denominator = math.hypot(M_val, N_val)
    if abs(K_val) > denominator:
        raise ValueError('Target xz is out of reach')
    phi = math.atan2(N_val, M_val)
    theta_sum = math.asin(K_val / denominator) - phi
    theta_sum1 = theta_sum
    theta_sum2 = math.pi - theta_sum - 2 * phi
    sin_theta_sum1 = math.sin(theta_sum1)
    cos_theta_sum1 = math.cos(theta_sum1)
    D1 = B * sin_theta_sum1 - C * cos_theta_sum1
    E1 = B * cos_theta_sum1 + C * sin_theta_sum1
    sin_theta1_1 = (x_target - D1) / A
    cos_theta1_1 = (z_target - E1) / A
    sin_theta_sum2 = math.sin(theta_sum2)
    cos_theta_sum2 = math.cos(theta_sum2)
    D2 = B * sin_theta_sum2 - C * cos_theta_sum2
    E2 = B * cos_theta_sum2 + C * sin_theta_sum2
    sin_theta1_2 = (x_target - D2) / A
    cos_theta1_2 = (z_target - E2) / A
    valid1 = abs(sin_theta1_1 ** 2 + cos_theta1_1 ** 2 - 1) < 1e-06
    valid2 = abs(sin_theta1_2 ** 2 + cos_theta1_2 ** 2 - 1) < 1e-06
    if valid1 and valid2:
        theta1_1 = math.atan2(sin_theta1_1, cos_theta1_1)
        theta1_2 = math.atan2(sin_theta1_2, cos_theta1_2)
        theta1 = theta1_1
        theta_sum = theta_sum1
    elif valid1:
        theta1 = math.atan2(sin_theta1_1, cos_theta1_1)
        theta_sum = theta_sum1
    elif valid2:
        theta1 = math.atan2(sin_theta1_2, cos_theta1_2)
        theta_sum = theta_sum2
    else:
        raise ValueError('No valid solution found')
    theta2 = theta_sum - theta1
    theta4 = 0.0
    return (theta1, theta2, theta3, theta4)
</EXISTING 7>
<EXISTING 8>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> float:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set the link to for reaching position "p".
    """
    px, py, pz = p
    theta = math.atan2(px, pz)
    return theta
</EXISTING 8>
<EXISTING 9>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the joints to for reaching position "p".
    """
    x, y, z = p
    A = 0.093
    B = 0.09465
    cosθ2 = y / A
    sinθ2 = math.sqrt(1 - cosθ2 ** 2)
    M = [[-A * sinθ2, B], [B, A * sinθ2]]
    det_M = -A * sinθ2 * (A * sinθ2) - B * B
    if det_M == 0:
        raise ValueError('Matrix is singular; target position is not reachable.')
    inv_det_M = 1.0 / det_M
    inv_M = [[inv_det_M * (A * sinθ2), -inv_det_M * B], [-inv_det_M * B, inv_det_M * (-A * sinθ2)]]
    cosθ1 = inv_M[0][0] * x + inv_M[0][1] * z
    sinθ1 = inv_M[1][0] * x + inv_M[1][1] * z
    cosθ1 = max(min(cosθ1, 1.0), -1.0)
    sinθ1 = max(min(sinθ1, 1.0), -1.0)
    θ1 = math.atan2(sinθ1, cosθ1)
    θ2 = math.acos(cosθ2)
    return (θ1, θ2)
</EXISTING 9>
<EXISTING 10>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the joints to for reaching position "p".
    """
    x, y, z = p
    A = 0.09465
    B = 0.0823
    cosθ2 = (y - 0.093) / 0.0823
    θ2 = math.acos(cosθ2)
    sinθ2 = math.sin(θ2)
    M = [[A, -B * sinθ2], [B * sinθ2, A]]
    det_M = M[0][0] * M[1][1] - M[0][1] * M[1][0]
    if det_M == 0:
        raise ValueError('Matrix is singular; target position is not reachable.')
    inv_det_M = 1.0 / det_M
    inv_M = [[inv_det_M * M[1][1], -inv_det_M * M[0][1]], [-inv_det_M * M[1][0], inv_det_M * M[0][0]]]
    sinθ1 = inv_M[0][0] * x + inv_M[0][1] * z
    cosθ1 = inv_M[1][0] * x + inv_M[1][1] * z
    sinθ1 = max(min(sinθ1, 1.0), -1.0)
    cosθ1 = max(min(cosθ1, 1.0), -1.0)
    θ1 = math.atan2(sinθ1, cosθ1)
    θ3 = 0.0
    return (θ1, θ2, θ3)
</EXISTING 10>
<EXISTING 11>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> float:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set the link to for reaching position "p".
    """
    x, y, z = p
    theta = math.atan2(x, y)
    return theta
</EXISTING 11>
<EXISTING 12>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    L1 = 0.09465
    L2 = 0.0823
    theta1 = math.atan2(-x, y)
    theta2 = 0
    return (theta1, theta2)
</EXISTING 12>
<EXISTING 13>
import math

def inverse_kinematics(p: tuple[float, float, float]) -> float:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set the link to for reaching position "p".
    """
    x, y, z = p
    theta = math.atan2(-z, x)
    return theta
</EXISTING 13>
<FUNCTIONS>
	<USAGE>
	To use a function, response with the format denoted in the "FORMAT" section of the function.
	</USAGE>
	<FORWARD_KINEMATICS>
		<FORMAT>
		FORWARD_KINEMATICS joint2 joint3 joint4 joint5 joint6
		</FORMAT>
		<DESCRIPTION>
		Test the forward kinematics of the robot, returning the position and orientation of all links in world space after setting the joint values where "joint1", "joint3", "joint4", "joint5", and "joint5" are the joint values as floats.
		</DESCRIPTION>
	</FORWARD_KINEMATICS>
	<TEST_SOLUTION>
		<FORMAT>
		TEST_SOLUTION positionX positionY positionZ
		</FORMAT>
		<DESCRIPTION>
		Returns the position and orientation of all links in world space after testing your current inverse kinematics solution code where "positionX", "positionY", and "positionZ" are the target position.
		</DESCRIPTION>
	</TEST_SOLUTION>
</FUNCTIONS>