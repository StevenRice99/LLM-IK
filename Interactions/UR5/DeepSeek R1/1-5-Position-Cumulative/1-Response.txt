To solve the inverse kinematics for the 5-DOF manipulator, we break down the problem into positioning the wrist (Revolute 4) and adjusting the end-effector (TCP) using the remaining joints. The solution involves geometric calculations and trigonometric equations to determine the joint angles.

### Approach
1. **Position the Wrist (Revolute 4)**:
   - Use the first three joints (theta1, theta2, theta3) to position Revolute 4 such that the TCP can reach the target. Theta3 is set to zero as it doesn't affect the X-Z position of Revolute 4.
   
2. **Adjust TCP Position**:
   - Compute the vector from Revolute 4 to the target (d) and solve for theta4 and theta5 using trigonometric identities to align the TCP with the target.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    x_target, y_target, z_target = p

    # Fixed Y-coordinate of Revolute 4
    y_revolute4 = -0.0267
    d_y = y_target - y_revolute4

    # Check if the y component is reachable
    if abs(d_y) > 0.0823:
        raise ValueError("Target y is out of reach")

    # Solve for theta5 using the y component of d
    theta5 = math.acos(d_y / 0.0823)
    sin_theta5 = math.sin(theta5)
    cos_theta5 = math.cos(theta5)

    # Parameters for the x and z components
    A = 0.09465  # Length from Revolute 4 to Revolute 5
    B = 0.0823   # Length from Revolute 5 to TCP
    C = B * sin_theta5

    # Compute terms for x and z components
    M = A * x_target + C * (z_target - 0.09465)
    N = A * (z_target - 0.09465) - C * x_target
    K = (x_target**2 + (z_target - 0.09465)**2 + A**2 + C**2 - B**2) / 2

    denominator = math.hypot(M, N)
    if abs(K) > denominator:
        raise ValueError("Target xz is out of reach")

    phi = math.atan2(N, M)
    theta_sum = math.asin(K / denominator) - phi

    # Two possible solutions for theta_sum
    theta_sum1 = theta_sum
    theta_sum2 = math.pi - theta_sum - 2 * phi

    # Check validity for both solutions
    valid1 = False
    valid2 = False

    # Solution 1
    sin_theta_sum1 = math.sin(theta_sum1)
    cos_theta_sum1 = math.cos(theta_sum1)
    x_sol1 = A * cos_theta_sum1 + C * sin_theta_sum1
    z_sol1 = A * sin_theta_sum1 - C * cos_theta_sum1
    theta1_1 = math.atan2(x_target - x_sol1, (z_target - 0.09465) - z_sol1)
    valid1 = abs(math.hypot(x_target - x_sol1, (z_target - 0.09465) - z_sol1) - B) < 1e-6

    # Solution 2
    sin_theta_sum2 = math.sin(theta_sum2)
    cos_theta_sum2 = math.cos(theta_sum2)
    x_sol2 = A * cos_theta_sum2 + C * sin_theta_sum2
    z_sol2 = A * sin_theta_sum2 - C * cos_theta_sum2
    theta1_2 = math.atan2(x_target - x_sol2, (z_target - 0.09465) - z_sol2)
    valid2 = abs(math.hypot(x_target - x_sol2, (z_target - 0.09465) - z_sol2) - B) < 1e-6

    # Select valid solution
    if valid1 and valid2:
        theta1 = theta1_1
        theta_sum = theta_sum1
    elif valid1:
        theta1 = theta1_1
        theta_sum = theta_sum1
    elif valid2:
        theta1 = theta1_2
        theta_sum = theta_sum2
    else:
        raise ValueError("No valid solution found")

    theta2 = theta_sum - theta1

    # Theta3 is set to 0 as it doesn't affect the position
    theta3 = 0.0

    # Compute theta4 based on the x and y components of d
    d_x = x_target - (0.425 * math.sin(theta1) + 0.39225 * math.sin(theta1 + theta2))
    theta4 = math.atan2(d_y, d_x) if (d_x != 0 or d_y != 0) else 0.0

    return (theta1, theta2, theta3, theta4, theta5)
```

### Explanation
1. **Y-Coordinate Check**: The Y-coordinate of Revolute 4 is fixed. The target's Y-coordinate is adjusted to check if it's within the reachable range.
2. **Theta5 Calculation**: Using the Y-component of the vector from Revolute 4 to the target, theta5 is computed.
3. **X and Z Components**: Trigonometric equations are used to solve for theta1 and theta2, positioning Revolute 4.
4. **Theta4 Calculation**: The angle theta4 is determined based on the X and Y components of the vector from Revolute 4 to the target.
5. **Theta3**: Set to zero as it doesn't affect the position of Revolute 4 in the X-Z plane.

This approach ensures that the target position is reached by decomposing the problem into manageable parts, leveraging geometric and trigonometric principles.