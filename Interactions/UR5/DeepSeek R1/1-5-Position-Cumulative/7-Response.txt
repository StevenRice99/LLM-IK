To solve this problem, we need to determine the joint angles for a 5-DOF manipulator to reach a target position in 3D space. The solution involves positioning the wrist (Revolute 4) using the first three joints and adjusting the end-effector (TCP) using the last two joints, considering the 3D geometry and joint constraints.

### Approach
1. **Position the Wrist (Revolute 4)**:
   - Use the first two joints (theta1 and theta2) to position Revolute 4 in the X-Z plane using geometric calculations.
   
2. **Adjust TCP Position**:
   - Compute the displacement vector from Revolute 4 to the target (dx, dy, dz) in 3D space.
   - Check if the target is within reach considering the lengths of the last two links and the 3D geometry.
   - Solve for theta4 and theta5 using trigonometric identities and matrix operations to align the TCP with the target.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    x_target, y_target, z_target = p

    # Check if y is within reachable range
    y_min = -0.109  # -0.0267 - 0.0823
    y_max = 0.0556  # -0.0267 + 0.0823
    if not (y_min <= y_target <= y_max):
        raise ValueError("Target y is out of reach")

    # Solve for theta4 based on y component
    y_revolute4 = -0.0267  # -0.1197 + 0.093
    cos_theta4 = (y_target - y_revolute4) / 0.0823
    cos_theta4 = max(min(cos_theta4, 1.0), -1.0)
    theta4 = math.acos(cos_theta4)
    sin_theta4 = math.sin(theta4)

    # Solve for theta1 and theta2 to position Revolute 4 in X-Z
    l1 = 0.425
    l2 = 0.39225
    r = math.hypot(x_target, z_target)
    cos_theta2 = (r**2 - l1**2 - l2**2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_target, z_target)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha

    # Compute Revolute 4's position in X-Z
    x_j4 = l1 * math.sin(theta1) + l2 * math.sin(theta1 + theta2)
    z_j4 = l1 * math.cos(theta1) + l2 * math.cos(theta1 + theta2)

    # Displacement from Revolute 4 to target in X-Z
    dx = x_target - x_j4
    dz = z_target - z_j4

    # Solve for theta5 using the displacement
    A = 0.09465
    B = 0.0823
    distance = math.hypot(dx, dz)
    if distance < abs(A - B) or distance > (A + B):
        raise ValueError("Target xz is out of reach")

    # Law of cosines to find theta5
    cos_theta5 = (A**2 + B**2 - distance**2) / (2 * A * B)
    cos_theta5 = max(min(cos_theta5, 1.0), -1.0)
    theta5 = math.acos(cos_theta5)

    # Theta3 is set to 0 as per the problem's existing solutions
    theta3 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)
```

### Explanation
1. **Y-Coordinate Check**: The Y-coordinate of the target is checked against the reachable range determined by the manipulator's link lengths and joint constraints.
2. **Theta4 Calculation**: The angle theta4 is computed based on the Y-component of the target position to ensure the TCP can reach the desired height.
3. **Theta1 and Theta2 Calculation**: Using geometric principles, the first two joint angles are determined to position Revolute 4 in the X-Z plane.
4. **Displacement Calculation**: The displacement from Revolute 4 to the target in the X-Z plane is computed.
5. **Theta5 Calculation**: The law of cosines is used to determine theta5 based on the displacement, ensuring the TCP can reach the target position in the X-Z plane.

This approach ensures that the target position is reached by decomposing the problem into manageable parts, leveraging geometric and trigonometric principles while adhering to the manipulator's kinematic constraints.