To solve the inverse kinematics for the 5-DOF manipulator, we need to accurately compute the joint angles considering the 3D geometry of the links and joints. The solution involves positioning the wrist (Revolute 4) and adjusting the end-effector (TCP) using trigonometric and matrix operations.

### Approach
1. **Position Revolute 4**: Use the first two joints (theta1 and theta2) to position Revolute 4 in the X-Z plane using geometric calculations.
2. **Calculate Displacement**: Determine the 3D displacement vector from Revolute 4 to the target.
3. **Solve for Theta5**: Use the Z-component of the displacement to compute theta5.
4. **Solve for Theta4**: Use matrix inversion to solve the system of equations derived from the X and Y components of the displacement.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    x_target, y_target, z_target = p

    # Link lengths and offsets
    l1 = 0.425
    l2 = 0.39225
    A = 0.09465  # Revolute 5's Z offset
    B_tcp = 0.0823  # TCP's X offset

    # Calculate Revolute 4's position using theta1 and theta2
    r = math.hypot(x_target, z_target)
    cos_theta2 = (r**2 - l1**2 - l2**2) / (2 * l1 * l2)
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    beta = math.atan2(x_target, z_target)
    alpha = math.atan2(l2 * math.sin(theta2), l1 + l2 * math.cos(theta2))
    theta1 = beta - alpha

    # Revolute 4's position in base frame
    x_j4 = l1 * math.sin(theta1) + l2 * math.sin(theta1 + theta2)
    z_j4 = l1 * math.cos(theta1) + l2 * math.cos(theta1 + theta2)
    y_j4 = -0.1197 + 0.093  # Sum of Y offsets from Revolute 2 to Revolute 4

    # Displacement from Revolute 4 to target
    dx = x_target - x_j4
    dy = y_target - y_j4
    dz = z_target - z_j4

    # Solve for theta5 using dz
    if abs(dz) > B_tcp:
        raise ValueError("Target z is out of reach")
    theta5 = -math.asin(dz / B_tcp)
    cos_theta5 = math.cos(theta5)
    B = B_tcp * cos_theta5

    # Solve for theta4 using dx and dy
    a = 0.09465
    denominator = a**2 - B**2
    if abs(denominator) < 1e-9:
        raise ValueError("Singular matrix; target xyz is out of reach")

    sin_theta4 = (a * dx - B * dy) / denominator
    cos_theta4 = (-B * dx + a * dy) / denominator

    # Normalize to handle numerical inaccuracies
    norm = math.hypot(sin_theta4, cos_theta4)
    sin_theta4 /= norm
    cos_theta4 /= norm

    theta4 = math.atan2(sin_theta4, cos_theta4)

    # Theta3 is set to 0 as per the problem's existing solutions
    theta3 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)
```

### Explanation
1. **Positioning Revolute 4**: The first two joints (theta1 and theta2) are calculated using geometric principles to position Revolute 4 in the X-Z plane.
2. **Displacement Calculation**: The 3D displacement vector from Revolute 4 to the target is computed.
3. **Theta5 Calculation**: The Z-component of the displacement is used to determine theta5, ensuring the target is within the reachable range.
4. **Theta4 Calculation**: Matrix inversion solves the system of equations derived from the X and Y components of the displacement, providing theta4.
5. **Normalization**: Ensures numerical stability by normalizing the sine and cosine values of theta4.

This approach accurately models the 3D geometry of the manipulator, ensuring the target position is reachable and correctly computing the joint angles.