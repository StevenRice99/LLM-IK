To solve this problem, we need to determine the joint angles (theta1, theta2, theta3, theta4) for a 4-DOF manipulator such that the Tool Center Point (TCP) reaches a specified position (x, y, z). The solution involves breaking down the problem into manageable parts using geometric and trigonometric methods.

### Approach
1. **Determine theta3 from the y-coordinate**: The y-coordinate of the target position is used to compute theta3 using the inverse cosine function, as the vertical offset from the third joint to the TCP is known.
2. **Solve for theta2 using x and z coordinates**: The x and z coordinates are used to form a trigonometric equation involving theta2, which is solved using linear trigonometric methods.
3. **Compute theta1 using matrix inversion**: Once theta2 and theta3 are known, theta1 is determined by solving a system of linear equations derived from the forward kinematics.
4. **Set theta4 to zero**: Since theta4 does not affect the position of the TCP, it is set to zero, assuming the orientation is not a constraint for this problem.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p

    # Calculate theta3 from the y-coordinate
    y_offset = y_target - 0.093
    if abs(y_offset) > 0.0823:
        raise ValueError("Target y is out of reach")
    theta3 = math.acos(y_offset / 0.0823)

    # Calculate constants for theta2 equation
    sin_theta3 = math.sin(theta3)
    C = (0.0823**2) * (sin_theta3**2) + (0.09465**2) + (0.39225**2)
    K = x_target**2 + z_target**2 - C

    a = 2 * 0.09465 * 0.39225
    b = 2 * 0.0823 * 0.39225 * sin_theta3

    # Solve a*cos(theta2) + b*sin(theta2) = K
    norm = math.hypot(a, b)
    if abs(K) > norm:
        raise ValueError("Target xz is out of reach")

    phi = math.atan2(b, a)
    acos_term = math.acos(K / norm)
    theta2 = phi + acos_term  # Choosing the first solution

    # Calculate A and B for theta1
    sin_theta2 = math.sin(theta2)
    cos_theta2 = math.cos(theta2)
    A = -0.0823 * sin_theta3 * cos_theta2 + 0.09465 * sin_theta2
    B = 0.0823 * sin_theta3 * sin_theta2 + 0.09465 * cos_theta2 + 0.39225

    # Calculate theta1 using the matrix inversion method
    denominator = A**2 + B**2
    if denominator == 0:
        raise ValueError("Denominator is zero in theta1 calculation")

    cos_theta1 = (A * x_target - B * z_target) / denominator
    sin_theta1 = (B * x_target + A * z_target) / denominator

    # Clamp to handle numerical inaccuracies
    cos_theta1 = max(min(cos_theta1, 1.0), -1.0)
    sin_theta1 = max(min(sin_theta1, 1.0), -1.0)

    theta1 = math.atan2(sin_theta1, cos_theta1)

    # Theta4 does not affect position, set to 0.0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Theta3 Calculation**: The y-coordinate of the target position is adjusted by the known offset from the third joint, and theta3 is computed using the inverse cosine function.
2. **Theta2 Calculation**: The x and z coordinates are used to form a trigonometric equation. This equation is solved using the method of linear trigonometric equations, considering the geometric constraints of the manipulator.
3. **Theta1 Calculation**: Using the previously computed angles, a system of linear equations derived from the forward kinematics is solved using matrix inversion to determine theta1.
4. **Theta4 Setting**: Since theta4 does not influence the position of the TCP, it is set to zero, assuming the orientation is not a constraint for this specific problem.

This approach efficiently decouples the problem into solvable parts, leveraging geometric and trigonometric principles to find the joint angles required to position the TCP at the target coordinates.