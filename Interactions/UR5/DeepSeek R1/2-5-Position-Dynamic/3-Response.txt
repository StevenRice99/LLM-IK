To solve this problem, we need to determine the joint angles (theta1, theta2, theta3, theta4) for a 4-DOF manipulator such that the Tool Center Point (TCP) reaches a specified position (x, y, z). The solution involves breaking down the problem into manageable parts using geometric and trigonometric methods, correctly accounting for the rotations and translations of each joint.

### Approach
1. **Determine theta3 from the y-coordinate**: The y-coordinate of the target position is used to compute theta3 using the inverse cosine function, as the vertical offset from the third joint to the TCP is known.
2. **Formulate the x and z equations**: Correctly model the x and z coordinates of the TCP considering the rotations and translations of all joints, including the effect of theta3.
3. **Solve for theta1 and theta_sum (theta1 + theta2)**: Use trigonometric identities and matrix methods to solve the system of equations derived from the forward kinematics.
4. **Compute theta2 from theta_sum**: Once theta_sum is found, compute theta2 as the difference between theta_sum and theta1.
5. **Set theta4 to zero**: Since theta4 does not affect the position of the TCP, it is set to zero.

### Solution Code
```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    x_target, y_target, z_target = p

    # Calculate theta3 from the y-coordinate
    y_offset = y_target - 0.093
    if abs(y_offset) > 0.0823:
        raise ValueError("Target y is out of reach")
    theta3 = math.acos(y_offset / 0.0823)
    sin_theta3 = math.sin(theta3)
    cos_theta3 = math.cos(theta3)

    # Constants based on the manipulator's dimensions
    A = 0.39225  # Revolute2's z-offset
    B = 0.09465  # Revolute4's z-offset
    C = 0.0823 * sin_theta3  # Term from TCP's y-offset and theta3

    # Formulate the equation M*sin(theta_sum) + N*cos(theta_sum) = K
    M_val = B * x_target + C * z_target
    N_val = B * z_target - C * x_target
    K_val = (x_target**2 + z_target**2 + B**2 + C**2 - A**2) / 2

    # Solve M*sin(theta_sum) + N*cos(theta_sum) = K
    denominator = math.hypot(M_val, N_val)
    if abs(K_val) > denominator:
        raise ValueError("Target xz is out of reach")

    phi = math.atan2(N_val, M_val)
    theta_sum = math.asin(K_val / denominator) - phi

    # Two possible solutions for theta_sum
    theta_sum1 = theta_sum
    theta_sum2 = math.pi - theta_sum - 2 * phi

    # Calculate theta1 for both theta_sum solutions
    sin_theta_sum1 = math.sin(theta_sum1)
    cos_theta_sum1 = math.cos(theta_sum1)
    D1 = B * sin_theta_sum1 - C * cos_theta_sum1
    E1 = B * cos_theta_sum1 + C * sin_theta_sum1
    sin_theta1_1 = (x_target - D1) / A
    cos_theta1_1 = (z_target - E1) / A

    sin_theta_sum2 = math.sin(theta_sum2)
    cos_theta_sum2 = math.cos(theta_sum2)
    D2 = B * sin_theta_sum2 - C * cos_theta_sum2
    E2 = B * cos_theta_sum2 + C * sin_theta_sum2
    sin_theta1_2 = (x_target - D2) / A
    cos_theta1_2 = (z_target - E2) / A

    # Check which solution is valid
    valid1 = abs(sin_theta1_1**2 + cos_theta1_1**2 - 1) < 1e-6
    valid2 = abs(sin_theta1_2**2 + cos_theta1_2**2 - 1) < 1e-6

    if valid1 and valid2:
        # Choose the solution that minimizes the angle (or other criteria)
        theta1_1 = math.atan2(sin_theta1_1, cos_theta1_1)
        theta1_2 = math.atan2(sin_theta1_2, cos_theta1_2)
        # Select the solution based on joint limits or other criteria
        theta1 = theta1_1
        theta_sum = theta_sum1
    elif valid1:
        theta1 = math.atan2(sin_theta1_1, cos_theta1_1)
        theta_sum = theta_sum1
    elif valid2:
        theta1 = math.atan2(sin_theta1_2, cos_theta1_2)
        theta_sum = theta_sum2
    else:
        raise ValueError("No valid solution found")

    # Calculate theta2
    theta2 = theta_sum - theta1

    # Theta4 does not affect position, set to 0.0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)
```

### Explanation
1. **Theta3 Calculation**: The y-coordinate of the target position is adjusted by the known offset from the third joint, and theta3 is computed using the inverse cosine function.
2. **Formulating Equations**: The x and z coordinates are derived considering the cumulative rotations and translations of all joints, including the effect of theta3.
3. **Solving for Theta1 and Theta_sum**: The system of equations is solved using trigonometric identities and matrix methods to find valid solutions for theta1 and theta_sum (theta1 + theta2).
4. **Computing Theta2**: Theta2 is derived from theta_sum and theta1, ensuring the correct joint angles to reach the target position.
5. **Theta4 Setting**: Since theta4 does not influence the position of the TCP, it is set to zero, assuming the orientation is not a constraint for this specific problem.

This approach efficiently decouples the problem into solvable parts, leveraging geometric and trigonometric principles to find the joint angles required to position the TCP at the target coordinates.