To solve the inverse kinematics for the 3 degrees-of-freedom serial manipulator, we need to determine the joint angles (joint1, joint2, joint3) that will position the TCP at the desired position `p = (x, y, z)`. We can use the existing solutions as a starting point and extend them to solve for the entire chain.

### Step-by-Step Solution

1. **Solve for Joint 1 (θ1):**
   - The first joint rotates around the Z-axis. The position of the TCP in the XY plane is influenced by this rotation.
   - We can use the existing code 1 to solve for θ1.

2. **Solve for Joint 2 (θ2) and Joint 3 (θ3):**
   - After determining θ1, we can transform the target position into the coordinate system of the second joint.
   - We then solve for θ2 and θ3 using geometric relationships and the lengths of the links.

### Implementation

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Solve for joint1 (θ1)
    theta1 = math.atan2(-x, y)
    
    # Transform the target position to the coordinate system of joint2
    # The position of joint2 is [0, 0.13585, 0]
    # The position of joint3 is [0, -0.1197, 0.425]
    # The position of TCP is [0, 0, 0.39225]
    
    # Calculate the position of the TCP relative to joint2
    # The vector from joint2 to TCP is [0, -0.1197, 0.425] + [0, 0, 0.39225] = [0, -0.1197, 0.81725]
    # We need to rotate this vector by -θ1 around the Z-axis to get it into the joint2 coordinate system
    # The rotation matrix around Z-axis is:
    # [cos(θ1), -sin(θ1), 0]
    # [sin(θ1), cos(θ1), 0]
    # [0, 0, 1]
    
    cos_theta1 = math.cos(theta1)
    sin_theta1 = math.sin(theta1)
    
    # Rotate the vector [0, -0.1197, 0.81725] by -θ1
    x_rot = 0 * cos_theta1 - (-0.1197) * sin_theta1
    y_rot = 0 * sin_theta1 + (-0.1197) * cos_theta1
    z_rot = 0.81725
    
    # Now, we have the position of the TCP relative to joint2 in the joint2 coordinate system
    # We can now solve for θ2 and θ3 using the lengths of the links
    # The length from joint2 to joint3 is 0.425
    # The length from joint3 to TCP is 0.39225
    
    # The distance from joint2 to TCP is sqrt(x_rot^2 + y_rot^2 + z_rot^2)
    distance = math.sqrt(x_rot**2 + y_rot**2 + z_rot**2)
    
    # Using the law of cosines to solve for θ3
    a = 0.425
    b = 0.39225
    c = distance
    
    cos_theta3 = (a**2 + b**2 - c**2) / (2 * a * b)
    theta3 = math.acos(cos_theta3)
    
    # Using the law of sines to solve for θ2
    sin_theta3 = math.sin(theta3)
    theta2 = math.asin((b * sin_theta3) / c)
    
    return theta1, theta2, theta3
```

### Explanation

1. **θ1 Calculation:**
   - We use `atan2(-x, y)` to determine the angle of rotation around the Z-axis to align the TCP with the target position in the XY plane.

2. **Transformation to Joint2 Coordinate System:**
   - We rotate the vector from joint2 to TCP by -θ1 to get the position in the joint2 coordinate system.

3. **θ2 and θ3 Calculation:**
   - We use the law of cosines and the law of sines to solve for θ2 and θ3 based on the lengths of the links and the distance from joint2 to the TCP.

This solution assumes that the target position is reachable and does not include any checks for unreachable positions.