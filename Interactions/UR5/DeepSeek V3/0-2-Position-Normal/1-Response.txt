To solve the inverse kinematics for the given 3 degrees-of-freedom serial manipulator, we need to determine the joint angles (θ1, θ2, θ3) that will position the end-effector (TCP) at the desired position p = (x, y, z). The manipulator consists of three revolute joints with the following properties:

1. **Revolute 1**: Rotates around the Z-axis.
2. **Revolute 2**: Rotates around the Y-axis.
3. **Revolute 3**: Rotates around the Y-axis.

Given the positions and orientations of the links, we can derive the forward kinematics equations and then invert them to find the joint angles.

### Step 1: Forward Kinematics

The forward kinematics equations can be derived using the Denavit-Hartenberg (D-H) parameters or by directly using the transformation matrices. For simplicity, we'll use the transformation matrices approach.

The transformation matrix for each joint can be represented as:

- **Joint 1**: Rotation around Z-axis by θ1.
- **Joint 2**: Translation along Y-axis by 0.13585, then rotation around Y-axis by θ2.
- **Joint 3**: Translation along Y-axis by -0.1197 and Z-axis by 0.425, then rotation around Y-axis by θ3.
- **TCP**: Translation along Z-axis by 0.39225.

The overall transformation matrix from the base to the TCP can be computed by multiplying the individual transformation matrices.

### Step 2: Inverse Kinematics

To find the inverse kinematics, we need to solve for θ1, θ2, and θ3 given the desired position p = (x, y, z).

1. **Solve for θ1**:
   - θ1 can be found using the atan2 function: θ1 = atan2(y, x).

2. **Solve for θ2 and θ3**:
   - After determining θ1, we can project the desired position onto the plane defined by θ1.
   - We then solve for θ2 and θ3 using the projected coordinates.

### Step 3: Implementing the Solution

We'll implement the solution in the `inverse_kinematics` function.

```python
import numpy as np
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Solve for θ1
    theta1 = math.atan2(y, x)
    
    # Project the desired position onto the plane defined by θ1
    r = math.sqrt(x**2 + y**2)
    z_prime = z - 0.39225  # Adjust for TCP offset
    
    # Solve for θ2 and θ3 using the projected coordinates
    # Using the law of cosines
    L1 = 0.13585
    L2 = math.sqrt((-0.1197)**2 + 0.425**2)
    
    D = (r**2 + z_prime**2 - L1**2 - L2**2) / (2 * L1 * L2)
    theta3 = math.atan2(math.sqrt(1 - D**2), D)
    
    theta2 = math.atan2(z_prime, r) - math.atan2(L2 * math.sin(theta3), L1 + L2 * math.cos(theta3))
    
    return (theta1, theta2, theta3)
```

### Explanation

1. **θ1 Calculation**: We use `atan2(y, x)` to find the angle that aligns the end-effector with the desired x and y coordinates.
2. **Projection**: We project the desired position onto the plane defined by θ1 to simplify the problem to a 2D plane.
3. **θ2 and θ3 Calculation**: We use the law of cosines to solve for θ3 and then use the projected coordinates to solve for θ2.

This solution assumes that the target position is reachable and does not handle cases where the target is out of the manipulator's workspace.