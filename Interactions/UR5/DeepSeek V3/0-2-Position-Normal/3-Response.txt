The error occurs because the value of `D` in the expression `math.sqrt(1 - D ** 2)` is outside the range [-1, 1], leading to a negative value inside the square root, which is not allowed. This can happen due to numerical inaccuracies or if the target position is not reachable (even though we assumed it is).

To handle this, we need to ensure that `D` is within the valid range before computing the square root. We can clamp `D` to the range [-1, 1] to avoid this issue.

Let's update the code to handle this:

```python
import numpy as np
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Solve for θ1
    theta1 = math.atan2(y, x)
    
    # Project the desired position onto the plane defined by θ1
    r = math.sqrt(x**2 + y**2)
    z_prime = z - 0.39225  # Adjust for TCP offset
    
    # Solve for θ2 and θ3 using the projected coordinates
    # Using the law of cosines
    L1 = 0.13585
    L2 = math.sqrt((-0.1197)**2 + 0.425**2)
    
    D = (r**2 + z_prime**2 - L1**2 - L2**2) / (2 * L1 * L2)
    
    # Clamp D to the range [-1, 1] to avoid numerical inaccuracies
    D = max(-1.0, min(D, 1.0))
    
    theta3 = math.atan2(math.sqrt(1 - D**2), D)
    
    theta2 = math.atan2(z_prime, r) - math.atan2(L2 * math.sin(theta3), L1 + L2 * math.cos(theta3))
    
    return (theta1, theta2, theta3)
```

### Explanation

1. **Clamping `D`**: We ensure that `D` is within the range [-1, 1] by using `max(-1.0, min(D, 1.0))`. This prevents the square root from receiving an invalid input.
2. **Rest of the Code**: The rest of the code remains the same, ensuring that we correctly compute the joint angles.

This should resolve the `ValueError` and allow the function to handle valid inputs correctly.