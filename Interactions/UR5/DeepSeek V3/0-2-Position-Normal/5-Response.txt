The forward kinematics results show that the provided joint angles \([-1.220992809070487, -0.645501250021244, -1.6035372146378641]\) correctly position the TCP at \([-0.17712975942839437, 0.5326692315114319, 0.09338175440585356]\). This confirms that the joint angles are valid for reaching the target position.

Given this, let's re-examine the inverse kinematics solution to identify and correct the issues. The main problems seem to be:

1. **Incorrect Calculation of Joint3**: The current method for calculating `joint3` using the law of cosines may not account for all possible configurations, leading to incorrect or `nan` values.

2. **Incorrect Calculation of Joint2**: The method for calculating `joint2` may not correctly handle the geometric relationships, especially when the target position is in certain quadrants.

3. **Handling of Multiple Solutions**: The inverse kinematics problem can have multiple solutions, and the current method may not always select the correct one.

Let's revise the `inverse_kinematics` function to address these issues:

```python
import numpy as np

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Calculate joint1
    joint1 = np.arctan2(y, x)
    
    # Project the target position onto the plane defined by joint2 and joint3
    r = np.sqrt(x**2 + y**2)
    s = z - 0.13585  # Adjust for the position of joint2
    
    # Lengths of the links
    l1 = 0.425  # Length from joint2 to joint3
    l2 = 0.39225  # Length from joint3 to TCP
    
    # Calculate joint3 using the law of cosines
    D = (r**2 + s**2 - l1**2 - l2**2) / (2 * l1 * l2)
    if D > 1 or D < -1:
        # Handle the case where the target is out of reach
        return np.nan, np.nan, np.nan
    joint3 = np.arctan2(np.sqrt(1 - D**2), D)
    
    # Calculate joint2
    alpha = np.arctan2(s, r)
    beta = np.arctan2(l2 * np.sin(joint3), l1 + l2 * np.cos(joint3))
    joint2 = alpha - beta
    
    return joint1, joint2, joint3
```

### Key Changes:
1. **Handling Out-of-Reach Targets**: Added a check to return `nan` if the target is out of reach.
2. **Correct Calculation of Joint3**: Ensured that `joint3` is calculated correctly using the law of cosines.
3. **Correct Calculation of Joint2**: Adjusted the calculation of `joint2` to handle the geometric relationships more accurately.

This revised function should handle the inverse kinematics problem more robustly. Let's test it with the provided target positions to verify its correctness.