To solve the inverse kinematics for the 3 degrees-of-freedom serial manipulator, we need to determine the joint angles (joint1, joint2, joint3) that will position the TCP at the desired target position \( p = (x, y, z) \).

Given the details of the manipulator, we can break down the problem into the following steps:

1. **Calculate joint1**: This joint rotates around the Y-axis. The angle can be determined by the x and z coordinates of the target position.
2. **Calculate joint2**: This joint also rotates around the Y-axis. The angle can be determined by the y coordinate and the distance in the x-z plane.
3. **Calculate joint3**: This joint rotates around the Y-axis. The angle can be determined by the remaining distance to the target position after accounting for the positions of joint1 and joint2.

Let's start by calculating joint1 using the existing code provided in EXISTING 1.

### Step 1: Calculate joint1

We will use the existing code to calculate joint1 based on the x and z coordinates of the target position.

```python
import math

def calculate_joint1(p: tuple[float, float, float]) -> float:
    """
    Gets the joint1 value needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: The value to set joint1 to for reaching position "p".
    """
    x_target = p[0]
    z_target = p[2]
    theta = -math.atan2(-x_target, z_target)
    return theta
```

### Step 2: Calculate joint2

Next, we need to calculate joint2. This involves determining the angle based on the y coordinate and the distance in the x-z plane.

```python
def calculate_joint2(p: tuple[float, float, float], joint1: float) -> float:
    """
    Gets the joint2 value needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :param joint1: The value of joint1.
    :return: The value to set joint2 to for reaching position "p".
    """
    x, y, z = p
    # Calculate the distance in the x-z plane after accounting for joint1
    distance_xz = math.sqrt(x**2 + z**2)
    # Calculate the angle for joint2
    theta = math.atan2(y, distance_xz)
    return theta
```

### Step 3: Calculate joint3

Finally, we need to calculate joint3. This involves determining the angle based on the remaining distance to the target position after accounting for the positions of joint1 and joint2.

```python
def calculate_joint3(p: tuple[float, float, float], joint1: float, joint2: float) -> float:
    """
    Gets the joint3 value needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :param joint1: The value of joint1.
    :param joint2: The value of joint2.
    :return: The value to set joint3 to for reaching position "p".
    """
    x, y, z = p
    # Calculate the remaining distance after accounting for joint1 and joint2
    remaining_distance = math.sqrt(x**2 + y**2 + z**2) - (0.1197 + 0.425 + 0.39225)
    # Calculate the angle for joint3
    theta = math.atan2(remaining_distance, 0.093)
    return theta
```

### Complete Inverse Kinematics Function

Now, we can combine these steps into the complete inverse kinematics function.

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    joint1 = calculate_joint1(p)
    joint2 = calculate_joint2(p, joint1)
    joint3 = calculate_joint3(p, joint1, joint2)
    return (joint1, joint2, joint3)
```

This function will calculate the required joint angles to position the TCP at the desired target position.