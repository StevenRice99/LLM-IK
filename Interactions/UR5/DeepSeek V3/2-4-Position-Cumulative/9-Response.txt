Given the persistent issues with the current approach, let's try a different method to calculate the joint angles. We'll use the forward kinematics function to test different joint angles and find the ones that bring the end-effector closest to the target position.

### Step 1: Define the Forward Kinematics Function
We'll use the `FORWARD_KINEMATICS` function to calculate the position of the end-effector given joint angles.

### Step 2: Implement a Search Algorithm
We'll implement a simple search algorithm to find the joint angles that minimize the distance between the end-effector and the target position.

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x_target, y_target, z_target = p
    
    # Define the search range and step size
    theta1_range = (-math.pi, math.pi)
    theta2_range = (-math.pi, math.pi)
    theta3_range = (-math.pi, math.pi)
    step_size = 0.1
    
    min_distance = float('inf')
    best_angles = (0.0, 0.0, 0.0)
    
    # Iterate over possible joint angles
    for theta1 in range(int(theta1_range[0] / step_size), int(theta1_range[1] / step_size)):
        theta1 = theta1 * step_size
        for theta2 in range(int(theta2_range[0] / step_size), int(theta2_range[1] / step_size)):
            theta2 = theta2 * step_size
            for theta3 in range(int(theta3_range[0] / step_size), int(theta3_range[1] / step_size)):
                theta3 = theta3 * step_size
                
                # Calculate the end-effector position using forward kinematics
                x, y, z = FORWARD_KINEMATICS(joint1=theta1, joint2=theta2, joint3=theta3)
                
                # Calculate the distance to the target position
                distance = math.sqrt((x - x_target)**2 + (y - y_target)**2 + (z - z_target)**2)
                
                # Update the best angles if this is the closest so far
                if distance < min_distance:
                    min_distance = distance
                    best_angles = (theta1, theta2, theta3)
    
    return best_angles
```

### Explanation
1. **Search Range**: We define the range of possible joint angles and a step size for the search.
2. **Iterate Over Angles**: We iterate over possible joint angles within the defined range.
3. **Forward Kinematics**: For each set of joint angles, we calculate the end-effector position using the `FORWARD_KINEMATICS` function.
4. **Distance Calculation**: We calculate the Euclidean distance between the end-effector position and the target position.
5. **Update Best Angles**: We keep track of the joint angles that result in the smallest distance to the target.

This approach should provide a more accurate calculation of the joint angles to reach the desired positions.