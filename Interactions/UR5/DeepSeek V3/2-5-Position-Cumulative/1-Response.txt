To solve the inverse kinematics for the 4 degrees-of-freedom serial manipulator, we need to determine the joint angles that will position the end-effector (TCP) at the desired position \( p = (x, y, z) \). We will use the existing solutions as a starting point and extend them to solve for all four joints.

### Step-by-Step Solution:

1. **Joint 1 (Revolute 1):**
   - The first joint rotates around the Y-axis.
   - We can use the existing solution from **Existing 1** to solve for Joint 1.
   - The angle \( \theta_1 \) can be calculated using the `atan2` function with the x and z coordinates of the target position.

2. **Joint 2 (Revolute 2):**
   - The second joint also rotates around the Y-axis.
   - We need to consider the position of the second joint relative to the first joint.
   - We can use the existing solution from **Existing 4** to solve for Joint 2.

3. **Joint 3 (Revolute 3):**
   - The third joint rotates around the Z-axis.
   - We can use the existing solution from **Existing 5** to solve for Joint 3.

4. **Joint 4 (Revolute 4):**
   - The fourth joint rotates around the Y-axis.
   - We can use the existing solution from **Existing 7** to solve for Joint 4.

### Implementation:

We will now implement the inverse kinematics function by combining the solutions from the existing code snippets.

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Joint 1: Revolute 1 (Y-axis)
    theta1 = math.atan2(x, z)
    
    # Joint 2: Revolute 2 (Y-axis)
    A = 0.093
    B = 0.09465
    cosθ2 = y / A
    sinθ2 = math.sqrt(1 - cosθ2 ** 2)
    M = [[-A * sinθ2, B], [B, A * sinθ2]]
    det_M = -A * sinθ2 * (A * sinθ2) - B * B
    if det_M == 0:
        raise ValueError('Matrix is singular; target position is not reachable.')
    inv_det_M = 1.0 / det_M
    inv_M = [[inv_det_M * (A * sinθ2), -inv_det_M * B], [-inv_det_M * B, inv_det_M * (-A * sinθ2)]]
    cosθ1 = inv_M[0][0] * x + inv_M[0][1] * z
    sinθ1 = inv_M[1][0] * x + inv_M[1][1] * z
    cosθ1 = max(min(cosθ1, 1.0), -1.0)
    sinθ1 = max(min(sinθ1, 1.0), -1.0)
    theta2 = math.atan2(sinθ1, cosθ1)
    
    # Joint 3: Revolute 3 (Z-axis)
    A = 0.09465
    B = 0.0823
    cosθ3 = (y - 0.093) / 0.0823
    theta3 = math.acos(cosθ3)
    
    # Joint 4: Revolute 4 (Y-axis)
    theta4 = math.atan2(-z, x)
    
    return (theta1, theta2, theta3, theta4)
```

### Explanation:

- **Joint 1:** We calculate \( \theta_1 \) using the `atan2` function with the x and z coordinates of the target position.
- **Joint 2:** We use the existing solution from **Existing 4** to calculate \( \theta_2 \).
- **Joint 3:** We use the existing solution from **Existing 5** to calculate \( \theta_3 \).
- **Joint 4:** We use the existing solution from **Existing 7** to calculate \( \theta_4 \).

This function will return the joint angles needed to position the end-effector at the desired position \( p \).