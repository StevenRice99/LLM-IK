To solve the inverse kinematics for the 4 degrees-of-freedom serial manipulator, we need to determine the joint angles that will position the end-effector (TCP) at the desired position \( p = (x, y, z) \). We will use the existing solutions as a starting point and extend them to solve for all four joints.

### Step-by-Step Solution

1. **Joint 3 (θ3)**:
   - From the existing code 1, we can solve for θ3 using the atan2 function:
     \[
     \theta_3 = \text{atan2}(x, z)
     \]

2. **Joints 1 and 2 (θ1 and θ2)**:
   - From the existing code 2, we can solve for θ1 and θ2 using the provided method. This involves calculating the cosine and sine of θ2 and then using matrix inversion to solve for θ1.

3. **Joint 4 (θ4)**:
   - The orientation of the TCP is given as [0, 0, 1.570796325] in RPY (Roll, Pitch, Yaw) format. This corresponds to a 90-degree rotation around the Z-axis. Since the TCP is the end-effector, θ4 will be directly related to this orientation.

### Implementation

We will now implement the inverse kinematics function using the above steps.

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Solve for θ3 using existing code 1
    theta3 = math.atan2(x, z)
    
    # Solve for θ1 and θ2 using existing code 2
    A = 0.09465
    B = 0.0823
    cos_theta2 = (y - 0.093) / B
    theta2 = math.acos(cos_theta2)
    sin_theta2 = math.sin(theta2)
    
    M = [[A, -B * sin_theta2], [B * sin_theta2, A]]
    det_M = M[0][0] * M[1][1] - M[0][1] * M[1][0]
    if det_M == 0:
        raise ValueError('Matrix is singular; target position is not reachable.')
    inv_det_M = 1.0 / det_M
    inv_M = [[inv_det_M * M[1][1], -inv_det_M * M[0][1]], [-inv_det_M * M[1][0], inv_det_M * M[0][0]]]
    
    sin_theta1 = inv_M[0][0] * x + inv_M[0][1] * z
    cos_theta1 = inv_M[1][0] * x + inv_M[1][1] * z
    sin_theta1 = max(min(sin_theta1, 1.0), -1.0)
    cos_theta1 = max(min(cos_theta1, 1.0), -1.0)
    theta1 = math.atan2(sin_theta1, cos_theta1)
    
    # Solve for θ4 based on the orientation of the TCP
    theta4 = 1.570796325  # 90 degrees in radians
    
    return (theta1, theta2, theta3, theta4)
```

### Explanation

- **θ3**: We use the `atan2` function to determine the angle based on the x and z coordinates.
- **θ1 and θ2**: We use the matrix inversion method from existing code 2 to solve for these angles.
- **θ4**: We set θ4 to 1.570796325 radians (90 degrees) based on the orientation of the TCP.

This function will return the joint angles needed to position the end-effector at the desired position \( p \).