The errors indicate that the target positions are being deemed unreachable, even though they are valid inputs. This suggests that the reachability check or the calculation of `D` might be too restrictive. Let's refine the approach to ensure that we correctly handle the reachability and the calculation of joint angles.

### Revised Approach

1. **Reachability Check**:
   - Instead of raising an error immediately, we should consider the possibility of multiple solutions or configurations that might reach the target position.

2. **Calculate Joint Angles**:
   - We need to ensure that the calculation of `D` and the subsequent angles are handled correctly, considering the geometry of the manipulator.

### Revised Implementation

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
    x, y, z = p
    
    # Link lengths
    L1 = 0.39225
    L2 = 0.093
    L3 = 0.09465
    L4 = 0.0823
    
    # Solve for θ1
    theta1 = math.atan2(y, x)
    
    # Solve for θ2 and θ3
    r = math.sqrt(x**2 + y**2)
    s = z - L1
    D_numerator = r**2 + s**2 - L2**2 - L3**2
    D_denominator = 2 * L2 * L3
    D = D_numerator / D_denominator
    
    # Check if D is within the valid range
    if abs(D) > 1:
        # Try the other configuration (elbow up/down)
        D = -D
        if abs(D) > 1:
            raise ValueError("Target position is not reachable.")
    
    theta3 = math.atan2(math.sqrt(1 - D**2), D)
    
    theta2 = math.atan2(s, r) - math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    
    # Solve for θ4 based on the orientation of the TCP
    theta4 = 0.0  # Assuming no rotation around the Z-axis for simplicity
    
    return (theta1, theta2, theta3, theta4)
```

### Explanation

- **θ1**: We use the `atan2(y, x)` function to determine the angle based on the x and y coordinates.
- **θ2 and θ3**: We calculate `D` and check if it is within the valid range [-1, 1]. If not, we try the other configuration (elbow up/down) by negating `D`. If `D` is still outside the range, we raise a `ValueError`. If `D` is valid, we proceed to calculate `theta3` and `theta2`.
- **θ4**: We set θ4 to 0.0 radians for simplicity, assuming no rotation around the Z-axis.

This revised function should handle the reachability check more robustly and provide a more accurate solution for the inverse kinematics of the 4 degrees-of-freedom serial manipulator.