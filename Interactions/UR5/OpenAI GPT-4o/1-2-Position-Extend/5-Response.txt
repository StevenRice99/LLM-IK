To solve the inverse kinematics for the 2-DOF manipulator, we need to determine the joint angles \( \theta_1 \) and \( \theta_2 \) that position the TCP (Tool Center Point) at the target position \( p = (x, y, z) \). Here's the step-by-step breakdown:

### Step 1: Define the problem
The manipulator consists of two revolute joints:
1. Revolute 1 rotates about the Y-axis and affects the position of Revolute 2.
2. Revolute 2 rotates about the Y-axis and affects the position of the TCP.

The TCP position is given by:
\[
\text{TCP} = [0, -0.1197, 0.81725]
\]
The target position \( p = (x, y, z) \) is the desired position for the TCP.

### Step 2: Use geometry to solve for joint angles
The manipulator's structure can be visualized as a planar 2D problem in the XZ-plane. The Y-coordinate is constant and does not affect the joint angles.

#### Step 2.1: Solve for \( \theta_2 \)
The second joint's rotation determines the relative position of the TCP along the link. Using the law of cosines, we can calculate \( \theta_2 \) based on the distance between the base and the target position.

#### Step 2.2: Solve for \( \theta_1 \)
The first joint's rotation determines the orientation of the second link. Using trigonometry, we can calculate \( \theta_1 \) based on the target position and the position of the second joint.

### Step 3: Write the solution
We will now complete the Python function to calculate \( \theta_1 \) and \( \theta_2 \).

```python
import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p: The position to reach in the form [x, y, z].
    :return: A tuple of the values to set the links to for reaching position "p".
    """
    # Target position
    x_target, y_target, z_target = p

    # Link lengths
    l1 = 0.425  # Length of the first link
    l2 = 0.39225  # Length of the second link

    # Distance from the base to the target in the XZ-plane
    r = math.sqrt(x_target**2 + z_target**2)

    # Solve for theta2 using the law of cosines
    cos_theta2 = (r**2 - l1**2 - l2**2) / (2 * l1 * l2)
    theta2 = math.acos(cos_theta2)

    # Solve for theta1 using trigonometry
    phi = math.atan2(z_target, x_target)
    sin_theta2 = math.sqrt(1 - cos_theta2**2)  # sin(theta2) from Pythagorean identity
    k1 = l1 + l2 * cos_theta2
    k2 = l2 * sin_theta2
    theta1 = phi - math.atan2(k2, k1)

    return theta1, theta2
```

### Explanation of the Code
1. **Input Parsing**: The target position \( p = (x, y, z) \) is extracted into \( x_{\text{target}}, y_{\text{target}}, z_{\text{target}} \).
2. **Link Lengths**: The lengths of the links are defined as \( l_1 \) and \( l_2 \).
3. **Distance Calculation**: The distance \( r \) from the base to the target in the XZ-plane is calculated.
4. **Law of Cosines**: The angle \( \theta_2 \) is calculated using the law of cosines.
5. **Trigonometry**: The angle \( \theta_1 \) is calculated using trigonometric relationships.

This function will return the joint angles \( \theta_1 \) and \( \theta_2 \) in radians.