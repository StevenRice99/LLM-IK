def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for a 2-DOF serial manipulator with:
      - Joint 1: Revolute about the Z-axis (base) 
      - Joint 2: Revolute about the Y-axis (after a fixed translation)
    The forward kinematics are given by:
      
      TCP = Rz(theta1) * ( [0, 0.13585, 0] + (Ry(theta2) * [0, -0.1197, 0.425]) )
      
    This simplifies (after performing the rotation about Y for the second link) to:
      
      TCP = Rz(theta1) * [ 0.425*sin(theta2), 0.13585 - 0.1197, 0.425*cos(theta2) ]
          = Rz(theta1) * [ A, B, 0.425*cos(theta2) ]
    
    where:
      A = 0.425*sin(theta2)
      B = 0.13585 - 0.1197 = 0.01615

    Since Rz(theta1) affects only the x and y components, we have:
      pz = 0.425*cos(theta2)   ->   theta2 = arccos(pz/0.425)
      and the projection on the xy–plane is
      [px, py] = Rz(theta1)*[A, B]
      
    Let:
      φ = atan2(py, px)   and   δ = atan2(B, A)
    then:
      theta1 = φ - δ

    The desired orientation r (given as [roll, pitch, yaw]) is assumed to satisfy:
      roll  = 0,  pitch = theta2,  yaw = theta1.
    We select the branch of theta2 based on the sign of the desired pitch.
    
    :param p: The target TCP position in the base frame as (px, py, pz)
    :param r: The target TCP orientation in rpy (radians) as (roll, pitch, yaw)
    :return: A tuple (theta1, theta2) representing joint angles (in radians)
    """
    import math

    # Unpack position and orientation
    px, py, pz = p
    # The desired orientation is assumed to be [roll, pitch, yaw] = [0, theta2, theta1]
    desired_pitch = r[1]  # should equal theta2
    # Compute theta2 from the z-coordinate relation:
    # pz = 0.425*cos(theta2)  =>  theta2 = arccos(pz/0.425)
    ratio = pz / 0.425
    # Clamp ratio to the valid range [-1, 1] to avoid numerical issues.
    ratio = max(min(ratio, 1.0), -1.0)
    theta2_candidate = math.acos(ratio)
    # Use the desired pitch to choose the proper branch for theta2.
    theta2 = theta2_candidate if desired_pitch >= 0 else -theta2_candidate

    # Compute the intermediate variables:
    A = 0.425 * math.sin(theta2)  # contribution along x in joint-1's frame
    B = 0.13585 - 0.1197          # this equals 0.01615, contribution along y

    # Compute delta: the intrinsic angle of the vector [A, B] in joint-1 frame.
    delta = math.atan2(B, A)
    # Compute the polar angle phi of the (px, py) projection.
    phi = math.atan2(py, px)
    # Then theta1 is given by removing delta: theta1 = phi - delta.
    theta1 = phi - delta

    return (theta1, theta2)