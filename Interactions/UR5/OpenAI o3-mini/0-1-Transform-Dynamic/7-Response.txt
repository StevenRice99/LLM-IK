def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for a 2-DOF serial manipulator with:
      - Joint 1: Revolute about the Z-axis (base)
      - Joint 2: Revolute about the Y-axis (after a fixed translation)
      
    The forward kinematics are specified as:
      TCP = Rz(theta1) * ( [0, 0.13585, 0] + (Ry(theta2) * [0, -0.1197, 0.425]) )
      
    When the vector [0, -0.1197, 0.425] is rotated about Y by theta2, it becomes:
      [0.425*sin(theta2), -0.1197, 0.425*cos(theta2)]
      
    Adding the fixed translation [0, 0.13585, 0] gives an intermediate point (in the joint-1 frame):
      w = [0.425*sin(theta2), 0.13585 - 0.1197, 0.425*cos(theta2)]
        = [A, B, 0.425*cos(theta2)]   where A = 0.425*sin(theta2) and B = 0.01615.
      
    Since the base joint rotates this point about Z, the final TCP position is:
      p = Rz(theta1) * w
    which means:
      • p_z = 0.425*cos(theta2)   →   theta2 = arccos(p_z/0.425)
      • The (x,y) components satisfy: [p_x, p_y] = Rz(theta1)*[A, B].
    If we denote:
      φ = atan2(p_y, p_x)     and     δ = atan2(B, A)
    then we have:
      φ = theta1 + δ     →     theta1 = φ - δ
      
    Moreover, the desired TCP orientation is given in roll-pitch-yaw (rpy) as:
      r = [roll, pitch, yaw] = [0, theta2, theta1]
    (The roll is unused since there is no roll degree-of-freedom.)
    
    Note: We select the sign of theta2 based on the given rpy pitch.
    
    :param p: The target TCP position as (p_x, p_y, p_z)
    :param r: The target TCP orientation (rpy in radians) as (roll, pitch, yaw)
              where pitch should equal theta2 and yaw should equal theta1.
    :return: A tuple (theta1, theta2) of joint angles (in radians)
    """
    import math

    # Unpack TCP position and orientation (rpy)
    px, py, pz = p
    desired_pitch = r[1]  # expected to equal theta2
    # desired_yaw = r[2]   # expected to equal theta1 (can be used for consistency check)

    # Compute theta2 from the z-coordinate.
    # pz = 0.425*cos(theta2)  →  theta2 = arccos(pz/0.425).
    ratio = pz / 0.425
    # Clamp the ratio to the valid domain of arccos.
    ratio = max(min(ratio, 1.0), -1.0)
    theta2_candidate = math.acos(ratio)
    # Choose the branch consistent with the desired pitch.
    theta2 = theta2_candidate if desired_pitch >= 0 else -theta2_candidate

    # Compute intermediate parameters:
    A = 0.425 * math.sin(theta2)  # contribution in the "x" direction (before base rotation)
    B = 0.13585 - 0.1197          # equals 0.01615, contribution in the "y" direction

    # The (x,y) components of the intermediate vector in joint-1 frame are [A, B].
    # After rotation by theta1 (Rz(theta1)), the xy components become:
    #   [p_x, p_y] = Rz(theta1)*[A, B]
    # Let φ = atan2(p_y, p_x) be the polar angle of p's xy projection.
    # Also, let δ = atan2(B, A) be the intrinsic angle of [A, B].
    # Then, φ = theta1 + δ  →  theta1 = φ - δ.
    phi = math.atan2(py, px)
    delta = math.atan2(B, A)
    theta1 = phi - delta

    return (theta1, theta2)