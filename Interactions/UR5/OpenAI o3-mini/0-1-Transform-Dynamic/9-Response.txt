def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for the 2-DOF serial manipulator.
    
    The forward kinematics are defined as:
      TCP = Rz(theta1) * ( [0, 0.13585, 0] + (Ry(theta2) * [0, -0.1197, 0.425]) )
      
    When [0, -0.1197, 0.425] is rotated about Y by theta2, it becomes:
      [0.425*sin(theta2), -0.1197, 0.425*cos(theta2)]
      
    Adding the fixed translation [0, 0.13585, 0] produces an intermediate point w:
      w = [0.425*sin(theta2), 0.13585 - 0.1197, 0.425*cos(theta2)]
        = [A, B, 0.425*cos(theta2)]
    where A = 0.425*sin(theta2) and B = 0.01615.
    
    Then the base rotation Rz(theta1) yields the TCP position:
      [p_x, p_y, p_z] = Rz(theta1) * [A, B, 0.425*cos(theta2)]
    
    Notice:
      - p_z is unaffected by theta1 so: p_z = 0.425*cos(theta2), leading to:
            theta2 = arccos(p_z/0.425)
      - The (p_x, p_y) components satisfy:
            [p_x, p_y] = Rz(theta1) * [A, B]
        Let φ = atan2(p_y, p_x) be the polar angle of the target (p_x, p_y) and δ = atan2(B, A)
        be the intrinsic angle of [A, B]. Then we have:
            φ = theta1 + δ   →   theta1 = φ - δ.
    
    The desired TCP orientation is given as rpy: r = [roll, pitch, yaw] which is assumed 
    to be [0, theta2, theta1]. We use the sign of the given pitch (r[1]) to pick the correct branch.
    
    :param p: The target TCP position as (p_x, p_y, p_z)
    :param r: The target TCP orientation in rpy (radians) as (roll, pitch, yaw)
    :return: A tuple (theta1, theta2) with the joint angles in radians.
    """
    import math

    # Unpack target TCP position and orientation
    px, py, pz = p
    desired_pitch = r[1]  # Expected to be theta2 (pitch)
    
    # Compute theta2 from the z-component:
    # pz = 0.425*cos(theta2)  -->  theta2 = arccos(pz/0.425)
    ratio = pz / 0.425
    # Clamp the ratio to ensure it lies within [-1, 1] for arccos
    ratio = max(min(ratio, 1.0), -1.0)
    theta2_candidate = math.acos(ratio)
    # Select the branch for theta2 based on the sign of desired_pitch.
    theta2 = theta2_candidate if desired_pitch >= 0 else -theta2_candidate

    # Compute the intermediate parameters:
    A = 0.425 * math.sin(theta2)  # X contribution of the rotated vector
    B = 0.13585 - 0.1197          # This equals 0.01615 (Y contribution)
    
    # Calculate the angle from the target's (px,py) components.
    phi = math.atan2(py, px)
    # Determine the intrinsic angle of the vector [A, B] in joint-1's frame.
    delta = math.atan2(B, A)
    # Compute theta1 as the difference between the overall polar angle and the intrinsic offset.
    theta1 = phi - delta

    return (theta1, theta2)