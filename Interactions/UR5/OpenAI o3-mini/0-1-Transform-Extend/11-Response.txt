def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    import math
    # Unpack the target TCP position
    p_x, p_y, p_z = p

    # Chain constants (from the URDF):
    # • The translation from Revolute 1 to Revolute 2 is [0, 0.13585, 0].
    # • The TCP offset relative to Revolute 2 is [0, -0.1197, 0.425].
    # Combining the y components gives an effective offset:
    offset = 0.13585 - 0.1197  # equals 0.01615
    # The z-offset from Revolute 2 to TCP is:
    L = 0.425

    # In the forward kinematics, the TCP position is given by:
    #   p_x = cos(q1) * (L*sin(q2)) - sin(q1) * (offset)
    #   p_y = sin(q1) * (L*sin(q2)) + cos(q1) * (offset)
    #   p_z = L*cos(q2)
    #
    # Step 1: Solve for q2 from the z component:
    #   p_z = L*cos(q2)  =>  q2 = acos(p_z / L)
    q2 = math.acos(p_z / L)
    
    # Step 2: Invert the x-y equations.
    # These can be rewritten as:
    #   [p_x, p_y] = Rz(q1) * [L*sin(q2), offset]
    # Where the “base” vector [L*sin(q2), offset] in the second link’s frame is rotated by q1.
    # Compute the angle of this fixed vector:
    fixed_angle = math.atan2(offset, L * math.sin(q2))
    # Compute the polar angle of the target projection in the base frame:
    target_angle = math.atan2(p_y, p_x)
    # Then, the joint angle of Revolute 1 is the difference:
    q1 = target_angle - fixed_angle

    return (q1, q2)