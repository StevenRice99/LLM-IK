def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Solves the inverse kinematics for a 2-DOF serial manipulator with:
      - Revolute Joint 1 rotating about the Z axis.
      - Revolute Joint 2 rotating about the Y axis.
      
    The chain is defined by:
      • Link from Joint 1 to Joint 2 origin at [0, 0.13585, 0] with no rotation.
      • TCP offset relative to Joint 2 (local frame) of [0, -0.1197, 0.425].
      
    Thus, the effective TCP position in the base frame is:
         p_x = cos(q1) * (L*sin(q2)) - sin(q1) * (offset)
         p_y = sin(q1) * (L*sin(q2)) + cos(q1) * (offset)
         p_z = L*cos(q2)
      with:
         L = 0.425         (the Z-offset from TCP)
         offset = 0.13585 - 0.1197  = 0.01615  (the effective offset in Y)

    The procedure to solve for the joint angles is:
      1. Solve for q2 from the z equation:
              q2 = acos(p_z / L)
         (This is valid since targets are assumed reachable.)
      
      2. The x and y equations can be written in matrix form as:
              [ p_x ] = Rz(q1) • [ L*sin(q2) ]
              [ p_y ]             [   offset  ]
         which implies that the vector [L*sin(q2); offset] (in the second link's local XY plane)
         is rotated by q1 to form the target vector [p_x; p_y].
         
         Let:
              base_angle = atan2(offset, L*sin(q2))
              target_angle = atan2(p_y, p_x)
         Then:
              q1 = target_angle - base_angle

    Note: The orientation parameter "r" is provided for compatibility but is not used in this 2-DOF solution.
    
    :param p: The desired TCP position as (x, y, z).
    :param r: The desired TCP orientation as (roll, pitch, yaw) (unused here).
    :return: A tuple (q1, q2) of joint angles in radians.
    """
    import math

    # Unpack target position
    x, y, z = p

    # Define chain constants.
    L = 0.425  # Z-offset from TCP relative to joint 2
    offset = 0.13585 - 0.1197  # = 0.01615; effective Y-offset after combining link translation and TCP offset

    # Invert the z-component to find joint angle q2.
    q2 = math.acos(z / L)

    # For the x, y components, observe that:
    #   [p_x; p_y] = Rz(q1) * [L*sin(q2); offset]
    #
    # Compute the angles of the target vector and the base vector.
    target_angle = math.atan2(y, x)
    base_angle = math.atan2(offset, L * math.sin(q2))

    # The first joint angle is given by the difference.
    q1 = target_angle - base_angle

    return (q1, q2)