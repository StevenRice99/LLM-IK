def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Solves the inverse kinematics for a 2-DOF serial manipulator with:
      • Revolute Joint 1: rotates about the Z-axis.
      • Revolute Joint 2: rotates about the Y-axis.

    Chain details:
      - The origin of Revolute 2 is at [0, 0.13585, 0] (in the base frame).
      - The TCP is offset relative to Revolute 2 by [0, -0.1197, 0.425].

    These yield an effective TCP position:
      p_x = cos(q1) * (L*sin(q2)) - sin(q1) * (offset)
      p_y = sin(q1) * (L*sin(q2)) + cos(q1) * (offset)
      p_z = L*cos(q2)
    where:
      L      = 0.425      (from the z-offset of the TCP)
      offset = 0.13585 - 0.1197 = 0.01615  (net offset in y)

    Inverting these equations:
      1. From p_z = L*cos(q2): 
              q2 = acos(p_z / L)
      2. The (p_x, p_y) components satisfy:
              [p_x; p_y] = Rz(q1) * [L*sin(q2); offset]
         so that:
              fixed_angle = atan2(offset, L*sin(q2))
              target_angle = atan2(p_y, p_x)
         and:
              q1 = target_angle - fixed_angle

    The orientation argument r is provided for interface compatibility, but is not used
    because a 2-DOF manipulator can only dictate position.

    :param p: The target TCP position (x, y, z).
    :param r: The target TCP orientation (roll, pitch, yaw) – not used.
    :return: A tuple (q1, q2) of joint angles in radians.
    """
    import math

    # Unpack the target position.
    p_x, p_y, p_z = p

    # Define chain constants.
    L = 0.425
    offset = 0.13585 - 0.1197  # equals 0.01615

    # Step 1: Solve for joint 2 angle using the z-component.
    q2 = math.acos(p_z / L)

    # Step 2: Solve for joint 1 angle using the x-y plane.
    # The unrotated vector (before q1 rotation) is:
    #   [L*sin(q2); offset]
    fixed_angle = math.atan2(offset, L * math.sin(q2))
    target_angle = math.atan2(p_y, p_x)
    q1 = target_angle - fixed_angle

    return (q1, q2)