def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    import math
    # Constants from the URDF (in meters)
    l_tcp = 0.425              # TCP offset along local z after joint 2 rotation
    offset_joint2 = 0.13585     # Translation from Joint 1 to Joint 2 (local y of Joint1)
    offset_tcp = 0.1197         # TCP offset (magnitude along negative y of Joint2)
    # The effective offset in the y-direction after combining translations:
    offset_y = offset_joint2 - offset_tcp  # equals 0.01615

    # Step 1: Solve for theta2 from the z coordinate of the TCP:
    # p_z = l_tcp * cos(theta2)  =>  cos(theta2) = p_z/l_tcp
    cos_theta2 = p[2] / l_tcp
    # Clamp the value to avoid numerical issues:
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_candidate = math.acos(cos_theta2)
    # Select the branch based on the desired pitch (r[1]):
    theta2 = -theta2_candidate if r[1] < 0 else theta2_candidate

    # Step 2: Solve for theta1 from the xy-plane coordinates.
    # The rotated offset vector before applying theta1 is:
    # [l_tcp*sin(theta2), offset_y]
    A = l_tcp * math.sin(theta2)
    B = offset_y
    # After rotation by theta1, we have:
    # [p_x, p_y] = [ cos(theta1)*A - sin(theta1)*B, sin(theta1)*A + cos(theta1)*B ]
    # So, the required rotation satisfies:
    # theta1 = atan2(p_y, p_x) - atan2(B, A)
    phi = math.atan2(p[1], p[0])
    alpha = math.atan2(B, A)
    theta1 = phi - alpha

    return (theta1, theta2)