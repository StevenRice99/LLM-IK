def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles for a 2 DOF manipulator to reach the specified TCP (tool center point)
    position p = (p_x, p_y, p_z) and orientation r = (roll, pitch, yaw) in radians.
    
    Robot description:
      - Revolute Joint 1 rotates about Z (base joint) and is located at [0, 0, 0].
      - Revolute Joint 2 rotates about Y and its origin (in the base frame) is at [0, 0.13585, 0].
      - The TCP is offset from Joint 2 by [0, -0.1197, 0.425] (in the local frame of Joint 2).
    
    The forward kinematics for the TCP position are:
         p = Rz(theta1) * ([A, B, 0.425*cos(theta2)]^T)
    where:
         A = 0.425*sin(theta2)
         B = 0.13585 - 0.1197   (which equals 0.01615)
    and Rz(theta1) is the rotation about the Z-axis.
    
    The inverse kinematics solution proceeds in two steps:
      1. Determine theta2 from the z-coordinate:
             p_z = 0.425*cos(theta2)   =>   cos(theta2) = p_z/0.425
         Since cosine is even, there are two candidate solutions. The desired pitch (r[1])
         is used to select the branch: if r[1] is negative, choose the negative theta2 solution.
      
      2. With theta2 known, the projection onto the xy-plane is:
             [p_x, p_y]^T = Rz(theta1) * [A, B]^T
         which implies:
             theta1 = atan2(p_y, p_x) - atan2(B, A)
    
    :param p: A tuple (p_x, p_y, p_z) for the TCP position.
    :param r: A tuple (roll, pitch, yaw) for the TCP orientation (in radians).
    :return: A tuple (theta1, theta2) with the calculated joint angles (in radians).
    """
    import math

    # Constant offset in the y-direction: from Joint1 to Joint2 plus the TCP y offset.
    offset = 0.13585 - 0.1197  # Equals 0.01615

    # Step 1: Solve for theta2 using the z-coordinate: p_z = 0.425*cos(theta2)
    cos_theta2 = p[2] / 0.425
    # Clamp the value to the valid range [-1, 1] to be safe against floating-point errors.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_candidate = math.acos(cos_theta2)
    # Choose the branch based on the desired TCP pitch (r[1])
    theta2 = -theta2_candidate if r[1] < 0 else theta2_candidate

    # Step 2: Solve for theta1 using the projection onto the xy-plane.
    A = 0.425 * math.sin(theta2)
    B = offset  # This equals 0.01615
    # The desired direction of the TCP in the xy-plane:
    phi = math.atan2(p[1], p[0])
    # The intrinsic angle of the vector [A, B]:
    alpha = math.atan2(B, A)
    theta1 = phi - alpha

    return (theta1, theta2)