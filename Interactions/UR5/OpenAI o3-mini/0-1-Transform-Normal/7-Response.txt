def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes and returns the joint angles (theta1, theta2) for a 2 DOF serial manipulator,
    given the target TCP position p = (p_x, p_y, p_z) and orientation r = (roll, pitch, yaw)
    in radians.

    Robot details (derived from its URDF):
      - Revolute Joint 1:
          * Position: [0, 0, 0]
          * Orientation: [0, 0, 0] with joint axis about Z.
      - Revolute Joint 2:
          * Position: [0, 0.13585, 0] (relative to Joint 1)
          * Orientation: [0, 0, 0] with joint axis about Y.
      - TCP (Tool Center Point):
          * Offset (relative to Joint 2): [0, -0.1197, 0.425]
    
    The forward kinematics chain is:
      1. Joint 1 rotates by theta1 about Z.
      2. Joint 2’s frame is translated by [0, 0.13585, 0] (in Joint 1 frame), then rotated by theta2 about Y.
      3. The TCP is offset in Joint 2’s frame by [0, -0.1197, 0.425].
    
    This results in the TCP position being:
      p = Rz(theta1) * ( [0.425*sin(theta2),
                           0.13585 - 0.1197,
                           0.425*cos(theta2)] )
        = Rz(theta1) * ( [0.425*sin(theta2),
                           0.01615,
                           0.425*cos(theta2)] ).
    
    In consequence:
      • The z–component gives:
            p_z = 0.425*cos(theta2)   -->   cos(theta2) = p_z/0.425,
         so that theta2 = acos(p_z/0.425) or theta2 = -acos(p_z/0.425).
         We choose the sign to match the desired pitch r[1] (i.e. if r[1] is negative, use the negative solution).

      • The xy–components satisfy:
            [p_x, p_y] = Rz(theta1) * [0.425*sin(theta2), 0.01615],
         which means:
            theta1 = atan2(p_y, p_x) - atan2(0.01615, 0.425*sin(theta2)).
         
    Note: The TCP’s final orientation (in roll-pitch-yaw) becomes [0, theta2, theta1]
          meaning that the desired r should be consistent (roll=0, pitch=theta2, yaw=theta1).

    Assumptions:
      - All targets (p, r) are reachable.
      - No need to check joint limits since provided limits are ±6.2831853.
    
    :param p: Target TCP position as a tuple (p_x, p_y, p_z).
    :param r: Target TCP orientation as a tuple (roll, pitch, yaw) in radians.
    :return: A tuple (theta1, theta2) of joint angles in radians.
    """
    import math

    # -------------------------------------------------------------------------
    # Step 1: Determine theta2 from the z-coordinate.
    # p_z = 0.425*cos(theta2)  -->  theta2 = acos(p_z/0.425)  (or its negative)
    cos_theta2 = p[2] / 0.425
    # Clamp the value to the domain [-1, 1] to account for floating point inaccuracies.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_candidate = math.acos(cos_theta2)
    # Choose the candidate based on the desired TCP pitch (r[1]).
    theta2 = -theta2_candidate if r[1] < 0 else theta2_candidate

    # -------------------------------------------------------------------------
    # Step 2: Solve for theta1 using the projection onto the xy-plane.
    # Let:
    #   A = 0.425*sin(theta2)
    #   B = (0.13585 - 0.1197) = 0.01615
    # Since after rotating by theta1:
    #   [p_x, p_y] = [A*cos(theta1) - B*sin(theta1),  A*sin(theta1) + B*cos(theta1)],
    # the angle that [A, B] makes is: atan2(B, A).
    # And the desired angle for [p_x, p_y] is: phi = atan2(p_y, p_x).
    # Thus, we deduce:
    #   theta1 = phi - atan2(B, A)
    A = 0.425 * math.sin(theta2)
    B = 0.13585 - 0.1197  # equals 0.01615
    phi = math.atan2(p[1], p[0])
    angle_offset = math.atan2(B, A)
    theta1 = phi - angle_offset

    return (theta1, theta2)