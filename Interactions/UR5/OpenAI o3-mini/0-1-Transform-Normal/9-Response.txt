def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the inverse kinematics for a 2 DOF serial manipulator.

    The robot consists of:
      - Revolute joint 1 at [0, 0, 0] with rotation about the Z-axis by theta1.
      - Revolute joint 2 located at [0, 0.13585, 0] relative to joint 1 with rotation about the Y-axis by theta2.
      - A TCP (tool center point) offset from joint 2 by [0, -0.1197, 0.425].

    From the URDF details, the TCP position with respect to the base can be expressed as:
         p = Rz(theta1) * [0.425*sin(theta2), (0.13585 - 0.1197), 0.425*cos(theta2)]áµ€
       where Rz(theta1) is the rotation around the Z-axis.
       
    This yields:
         p_x = cos(theta1)*(0.425*sin(theta2)) - sin(theta1)*(0.13585 - 0.1197)
         p_y = sin(theta1)*(0.425*sin(theta2)) + cos(theta1)*(0.13585 - 0.1197)
         p_z = 0.425*cos(theta2)

    The corresponding TCP orientation (expressed in roll-pitch-yaw) is:
         [0, theta2, theta1].
    
    Inverse kinematics steps:
      1. Solve for theta2 from the z-component:
            p_z = 0.425*cos(theta2)  =>  theta2 = acos(p_z/0.425)  or its negative.
         Choose the sign of theta2 based on the target pitch r[1]:
            if r[1] < 0, then theta2 = -acos(p_z/0.425)
            else, theta2 =  acos(p_z/0.425)
    
      2. With theta2 determined, let:
             A = 0.425*sin(theta2)
             B = (0.13585 - 0.1197)  (which equals 0.01615)
         The projection in the xy-plane is then:
             [p_x, p_y] = Rz(theta1)*[A, B].
         So we can solve for theta1 as:
             theta1 = atan2(p_y, p_x) - atan2(B, A)

    Assumptions:
      - All inputs are reachable.
      - Joint angles are unconstrained aside from provided limits.
    
    :param p: A tuple (p_x, p_y, p_z) representing the target TCP position.
    :param r: A tuple (roll, pitch, yaw) representing the target TCP orientation in radians.
    :return: A tuple (theta1, theta2) containing the computed joint angles in radians.
    """
    import math

    # Offset in the y direction from joint 1 to joint 2 and then TCP offset
    offset = 0.13585 - 0.1197  # equals 0.01615

    # Step 1: Determine theta2 from the z coordinate.
    # p_z = 0.425*cos(theta2)  -->  theta2 = acos(p_z/0.425) or -acos(p_z/0.425)
    cos_theta2 = p[2] / 0.425
    # Clamp value to [-1, 1] to avoid domain errors due to rounding.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_candidate = math.acos(cos_theta2)
    # Select the sign based on the desired pitch (r[1]) from the orientation.
    theta2 = -theta2_candidate if r[1] < 0 else theta2_candidate

    # Step 2: Solve for theta1 using the projected xy-plane coordinates.
    A = 0.425 * math.sin(theta2)
    B = offset
    # The angle of the vector [p_x, p_y] in the base frame.
    phi = math.atan2(p[1], p[0])
    # The intrinsic angle of the offset vector [A, B] before rotation by theta1.
    alpha = math.atan2(B, A)
    theta1 = phi - alpha

    return (theta1, theta2)