def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for a 2-DOF serial manipulator 
    to achieve the desired TCP position and orientation.

    The forward kinematics of the manipulator are defined as follows:
      TCP_position = [ 0.425*sin(theta2)*cos(theta1) - 0.01615*sin(theta1),
                       0.425*sin(theta2)*sin(theta1) + 0.01615*cos(theta1),
                       0.425*cos(theta2) ]
      TCP_orientation (rpy) = [ 0, theta2, theta1 ]
    
    Given a target pose with position p = [x, y, z] and orientation r = [roll, pitch, yaw],
    the TCP must have roll = 0 and its pitch and yaw correspond to theta2 and theta1, respectively.
    Thus, we set:
         theta2 = r[1]
    and the following holds in the x–y plane:
         x + i*y = (A + i*B) * exp(i*theta1)
    where:
         A = 0.425*sin(theta2)
         B = 0.01615
         
    Solving for theta1 yields:
         theta1 = atan2(y, x) - atan2(B, A)
    
    We assume the target pose is consistent, i.e. z ≈ 0.425*cos(theta2).

    :param p: The desired TCP position as a tuple (x, y, z).
    :param r: The desired TCP orientation in roll-pitch-yaw (radians) as (roll, pitch, yaw).
              (Note: roll must be zero.)
    :return: A tuple (theta1, theta2) containing the joint angles (in radians).
    """
    import math

    # Extract target position and orientation.
    x, y, z = p
    roll, pitch, yaw = r  # Expected: roll == 0

    # Set joint 2 using the target pitch.
    theta2 = pitch

    # Define the effective x–y coefficients.
    A = 0.425 * math.sin(theta2)
    B = 0.01615

    # Solve for theta1 using the relation:
    #      angle(x + i*y) = theta1 + angle(A + i*B)
    theta1 = math.atan2(y, x) - math.atan2(B, A)

    return (theta1, theta2)