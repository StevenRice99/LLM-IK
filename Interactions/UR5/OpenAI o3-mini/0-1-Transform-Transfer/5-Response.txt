def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint values for the 2-DOF serial manipulator that achieve
    the desired TCP position and orientation.
    
    The forward kinematics for this manipulator are given by:
    
      TCP position = [ 0.425*sin(theta2)*cos(theta1) - 0.01615*sin(theta1),
                       0.425*sin(theta2)*sin(theta1) + 0.01615*cos(theta1),
                       0.425*cos(theta2) ]
                       
      TCP orientation (rpy) = [ 0, theta2, theta1 ]
    
    Thus the target TCP orientation must have zero roll and its pitch and yaw
    correspond exactly to joint angles theta2 and theta1, respectively.
    
    Given a target pose:
       p = [x, y, z] and r = [roll, pitch, yaw]  (with roll == 0),
    one valid inverse kinematics solution is to choose:
    
       theta2 = r[1]           (as the pitch must match)
    
    and then extract theta1 from the x–y position equations.
    Recognizing that the x–y mapping can be combined into a complex equation:
    
       p_x + i*p_y = (A + i*B) * exp(i*theta1)
       
    where
       A = 0.425*sin(theta2)
       B = 0.01615   (a constant offset).
       
    It follows that:
    
       theta1 = atan2(p_y, p_x) - atan2(B, A)
    
    Note:
      - We assume that the provided target pose (p, r) is reachable,
        i.e. that z == 0.425*cos(theta2) holds within numerical tolerance.
      
    :param p: The target position [x, y, z].
    :param r: The target orientation in rpy [roll, pitch, yaw] (roll must be 0).
    :return: A tuple (theta1, theta2) in radians for the two joints.
    """
    import math

    # Unpack target position and orientation.
    x, y, z = p
    roll, pitch, yaw = r

    # For this manipulator, the TCP roll is always zero.
    # We use the target pitch to set joint 2.
    theta2 = pitch  # Expecting that z is 0.425*cos(theta2)

    # Compute the effective coefficients in the x-y plane.
    A = 0.425 * math.sin(theta2)
    B = 0.01615   # fixed offset from the TCP definition

    # Combine the x and y equations as a complex number: 
    #   p_x + i*p_y = (A + i*B) * exp(i*theta1).
    # Solve for theta1:
    theta1 = math.atan2(y, x) - math.atan2(B, A)

    return (theta1, theta2)