def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for a 2-DOF serial manipulator to reach
    a desired TCP pose (position and orientation).

    The manipulator's kinematics are defined by:
      TCP position = [ 0.425*sin(theta2)*cos(theta1) - 0.01615*sin(theta1),
                       0.425*sin(theta2)*sin(theta1) + 0.01615*cos(theta1),
                       0.425*cos(theta2) ]
                       
      TCP orientation (rpy) = [ 0, theta2, theta1 ]

    Given a target TCP pose with:
        p = [x, y, z] and r = [roll, pitch, yaw]
    the configuration must satisfy roll == 0 and the TCP's pitch and yaw are directly
    the joint angles theta2 and theta1, respectively.

    The inverse kinematics are solved by:
      (1) Choosing theta2 from the target pitch:
             theta2 = r[1]
      (2) Using the x-y equations and combining them into a complex representation,
          we have:
             x + i*y = (A + i*B)*exp(i*theta1)
          where:
             A = 0.425*sin(theta2)   and   B = 0.01615.
          Thus, theta1 is obtained as:
             theta1 = atan2(y, x) - atan2(B, A)
    
    We assume that the provided target pose is consistent (i.e. z â‰ˆ 0.425*cos(theta2)).
    
    :param p: The target position as a tuple (x, y, z).
    :param r: The target orientation in roll-pitch-yaw (radians) as (roll, pitch, yaw).
              The roll should be zero.
    :return: A tuple (theta1, theta2) with the joint angles in radians.
    """
    import math

    # Unpack the target position and orientation.
    x, y, z = p
    roll, pitch, yaw = r

    # In our manipulator, the TCP roll is always zero, and the target pitch and yaw
    # directly correspond to the joint angles theta2 and theta1 (modulo the x-y offset).
    theta2 = pitch  # Use the target pitch as joint 2 angle.
    
    # Compute the effective coefficients for the combined x-y equations.
    A = 0.425 * math.sin(theta2)
    B = 0.01615   # Constant offset along the x-y plane.

    # The x-y equations combine to form:
    #     x + i*y = (A + i*B)*exp(i*theta1)
    # Solve for theta1 via the angle difference:
    theta1 = math.atan2(y, x) - math.atan2(B, A)

    return (theta1, theta2)