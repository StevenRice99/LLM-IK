def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float]:
    """
    Computes the joint angles (theta1, theta2) for a 2-DOF serial manipulator
    so that its TCP reaches the desired position p and orientation r.
    
    The forward kinematics of the manipulator are given by:
    
      TCP_position = [ 0.425*sin(theta2)*cos(theta1) - 0.01615*sin(theta1),
                       0.425*sin(theta2)*sin(theta1) + 0.01615*cos(theta1),
                       0.425*cos(theta2) ]
                       
      TCP_orientation (rpy) = [ 0, theta2, theta1 ]
    
    In other words, the TCP roll is fixed to 0 and the TCP pitch and yaw correspond
    directly to the joint angles: theta2 = pitch and theta1 = yaw.
    
    Given a target pose:
       p = [x, y, z] and r = [roll, pitch, yaw]
    (with the assumption that roll == 0 and that this pose is reachable),
    one valid closed-form inverse kinematics solution is to assign:
      
      theta2 = r[1]        (target pitch)
    
    and then solve for theta1 from the x-y equations.
    Noting that these x-y equations can be combined into a complex form:
    
        x + i*y = (A + i*B) * exp(i*theta1)
      
    where:
        A = 0.425*sin(theta2)
        B = 0.01615    (a known constant offset)
    
    It follows that:
      
        theta1 = atan2(y, x) - atan2(B, A)
    
    This automatically selects the solution branch that is consistent with the
    provided target orientation.
    
    :param p: Target position as (x, y, z).
    :param r: Target orientation in roll-pitch-yaw as (roll, pitch, yaw) with roll == 0.
    :return: A tuple (theta1, theta2) representing the joint angles in radians.
    """
    import math

    x, y, z = p
    roll, pitch, yaw = r  # Note: we assume roll == 0

    # Joint 2 (theta2) is set directly from the target pitch (r[1])
    theta2 = pitch

    # Effective coefficients from the x-y portion of the forward kinematics.
    A = 0.425 * math.sin(theta2)
    B = 0.01615

    # Solve for theta1 from the complex representation:
    #      x + i*y = (A + i*B) * exp(i*theta1)
    theta1 = math.atan2(y, x) - math.atan2(B, A)

    return (theta1, theta2)