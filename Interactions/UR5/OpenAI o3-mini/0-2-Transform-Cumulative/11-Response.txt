def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3) for a 3-DOF serial manipulator so that its Tool Center Point (TCP)
    reaches the desired position p = [x, y, z] and orientation r = [rx, ry, rz] (in radians).
    
    The robot’s structure is as follows:
      - Joint1 rotates about Z.
      - Joint2 rotates about Y and its origin is displaced by [0, 0.13585, 0] (from the base).
      - Joint3 rotates about Y and its origin relative to joint2 is [0, -0.1197, 0.425].
      - The TCP is displaced by [0, 0, 0.39225] relative to joint3.
      
    To solve the inverse kinematics:
      1. We decouple joint1 by “undoing” the rotation about Z. One valid solution is:
             theta1 = atan2(–x, y)
      2. Rotate the target position by –theta1 about Z. In this rotated frame the remaining chain (joints 2 and 3)
         operates in a plane (with x and z as the active coordinates). We then subtract the joint2 offset (0, 0.13585, 0)
         so that the effective position of the TCP relative to joint2 becomes:
             x_eff = x_rot
             z_eff = z   (the z coordinate is unchanged)
         (Note: the y component becomes y_eff = y_rot – 0.13585; for a chain that rotates about Y the y value is constant.)
      3. The desired TCP orientation (given as rpy) is used to determine the net angle for joints 2 and 3.
         Specifically, we form part of the rotation matrix from rpy:
             R00 = cos(ry)*cos(rz)   and   R02 = sin(ry)
         and define:
             theta_sum = atan2(R02, R00)
         which must equal (theta2 + theta3).
      4. The effective 2-link planar chain (in the x–z plane) has link lengths:
             a = 0.425    (from joint2 to joint3, using the x–z projection of [0, -0.1197, 0.425])
             b = 0.39225  (from joint3 to TCP)
         To account for the TCP offset, we “back out” the wrist (joint3) location by subtracting b in the
         direction defined by theta_sum:
             x_wrist = x_eff – b*sin(theta_sum)
             z_wrist = z_eff – b*cos(theta_sum)
         Then, because the first link of the chain (of effective length a) must reach the wrist position, we have:
             a*sin(theta2) = x_wrist    and    a*cos(theta2) = z_wrist
         so that:
             theta2 = atan2(x_wrist, z_wrist)
         and finally:
             theta3 = theta_sum – theta2
             
    This implementation assumes that the target is reachable.
    """
    import math

    # Unpack target TCP position and orientation.
    x, y, z = p
    rx, ry, rz = r

    # --- Step 1: Solve for Joint 1 (rotation about Z) ---
    # A valid solution is to decouple the planar component:
    theta1 = math.atan2(-x, y)

    # --- Step 2: Rotate the target position by -theta1 about Z ---
    cos1 = math.cos(theta1)
    sin1 = math.sin(theta1)
    x_rot = cos1 * x + sin1 * y
    y_rot = -sin1 * x + cos1 * y
    # z remains unchanged.
    z_rot = z

    # Shift the origin to joint2 (whose position in the base is [0, 0.13585, 0]).
    # After rotation, the effective y-coordinate becomes:
    y_eff = y_rot - 0.13585
    # For the 2-link (joints 2 and 3) kinematics, only x (from x_rot) and z (from z_rot) are affected by Y-axis rotations:
    x_eff = x_rot
    z_eff = z_rot

    # --- Step 3: Use the desired TCP orientation (rpy) to fix the net rotation (theta2 + theta3) ---
    # Build the required elements of the rotation matrix.
    # Here we use the components most relevant to a Y-axis rotation (since joints 2 and 3 rotate about Y).
    R00 = math.cos(ry) * math.cos(rz)
    R02 = math.sin(ry)
    theta_sum = math.atan2(R02, R00)  # this equals (theta2 + theta3)

    # --- Step 4: Solve the effective 2-link planar inverse kinematics ---
    # Link lengths derived from the robot’s geometry:
    a = 0.425    # Link from joint2 to joint3 (x–z projection of [0, -0.1197, 0.425])
    b = 0.39225  # Link from joint3 to TCP (translation along z)
    
    # Subtract the TCP offset (b) from the effective position to locate the "wrist" (joint3).
    x_wrist = x_eff - b * math.sin(theta_sum)
    z_wrist = z_eff - b * math.cos(theta_sum)
    
    # Solve for joint2 angle using the wrist position.
    theta2 = math.atan2(x_wrist, z_wrist)
    # Joint3 angle then follows from the orientation constraint:
    theta3 = theta_sum - theta2

    return (theta1, theta2, theta3)