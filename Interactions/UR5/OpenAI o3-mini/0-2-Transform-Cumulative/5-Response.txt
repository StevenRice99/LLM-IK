def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Gets the joint values needed to reach position "p" and orientation "r".
    :param p: The target TCP position to reach in the form [x, y, z].
    :param r: The target TCP orientation in rpy (radians) in the form [rx, ry, rz].
    :return: A tuple of joint values (joint1, joint2, joint3) in radians.
    """
    import math

    # Unpack target position and orientation.
    x, y, z = p
    rx, ry, rz = r

    # --- Solve Joint 1 (rotation about Z) ---
    # The first joint rotates about Z. One valid solution (from EXISTING 1) is:
    theta1 = math.atan2(-x, y)

    # --- Transform target position to the frame after Joint 1 rotation ---
    # Rotate the target by -theta1 about Z such that the remaining motion lies in a plane.
    cos_theta1 = math.cos(theta1)
    sin_theta1 = math.sin(theta1)
    # Rotation matrix about Z (by -theta1):
    x_rot = cos_theta1 * x + sin_theta1 * y
    y_rot = -sin_theta1 * x + cos_theta1 * y
    z_rot = z

    # The second joint (Revolute 2) is located at [0, 0.13585, 0] in the base.
    # In the rotated frame, subtract the y-offset so that joint2 is at the origin.
    y_eff = y_rot - 0.13585

    # For joints 2 and 3 we assume all motion is in the x–z plane.
    # (y_eff is the residual y after subtracting joint2’s offset; ideally, it should be near zero.)
    x_eff = x_rot
    z_eff = z_rot

    # --- Use the desired TCP orientation (rpy) to compute the net rotation for joints 2 and 3 ---
    # Although the complete rpy is given, for this planar sub-chain (rotations about Y),
    # we extract an effective rotation which is the sum theta2+theta3.
    cx = math.cos(rx)
    sx = math.sin(rx)
    cy = math.cos(ry)
    sy = math.sin(ry)
    cz = math.cos(rz)
    sz = math.sin(rz)
    # Construct part of the rotation matrix (from rpy) where:
    # R00 = cy * cz and R02 = sy. Then the net rotation about Y is:
    theta_sum = math.atan2(sy, cy * cz)  # This represents theta2 + theta3.

    # --- Solve the planar 2-link IK (for joints 2 and 3) ---
    # For the chain, define:
    # a: the effective distance from joint2 to joint3.
    # b: the distance from joint3 to the TCP.
    # These are taken from the manipulator’s link lengths:
    a = 0.425    # (from joint2 to joint3; note: the x-component of the revolute3 translation is zero)
    b = 0.39225  # (from joint3 to TCP, along z in the local frame)

    # The effective target in the plane is (x_eff, z_eff).
    d_sq = x_eff**2 + z_eff**2

    # By the law-of-cosines:
    # d^2 = a^2 + b^2 + 2ab*cos(theta3)   => cos(theta3) = (d^2 - a^2 - b^2) / (2ab)
    cos_theta3 = (d_sq - a*a - b*b) / (2 * a * b)
    # Clamp the value to [-1,1] to avoid numerical errors.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    
    # Two possible solutions for joint3.
    theta3_option1 = math.acos(cos_theta3)
    theta3_option2 = -theta3_option1

    # Try each candidate. We know that the overall orientation constraint requires:
    # theta2 + theta3 = theta_sum, hence theta2 = theta_sum - theta3.
    solution_found = False
    chosen_theta2 = 0.0
    chosen_theta3 = 0.0
    for theta3_candidate in [theta3_option1, theta3_option2]:
        theta2_candidate = theta_sum - theta3_candidate
        # Compute forward kinematics for the 2-link planar sub-chain:
        # x_calc = a*sin(theta2) + b*sin(theta2+theta3)
        # z_calc = a*cos(theta2) + b*cos(theta2+theta3)
        x_calc = a * math.sin(theta2_candidate) + b * math.sin(theta_sum)
        z_calc = a * math.cos(theta2_candidate) + b * math.cos(theta_sum)
        # Check if the calculated position matches the effective target.
        if math.isclose(x_calc, x_eff, abs_tol=1e-5) and math.isclose(z_calc, z_eff, abs_tol=1e-5):
            chosen_theta2 = theta2_candidate
            chosen_theta3 = theta3_candidate
            solution_found = True
            break

    if not solution_found:
        # Fallback: directly compute theta2 from the target position and then derive theta3.
        theta2_candidate = math.atan2(x_eff - b * math.sin(theta_sum), z_eff - b * math.cos(theta_sum))
        chosen_theta2 = theta2_candidate
        chosen_theta3 = theta_sum - theta2_candidate

    return (theta1, chosen_theta2, chosen_theta3)