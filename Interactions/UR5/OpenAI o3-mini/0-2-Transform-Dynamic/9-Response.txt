def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3) for a 3-DOF serial manipulator to reach a desired
    TCP position and orientation.

    The robot chain is described as follows:
      - Joint 1 rotates about Z with origin [0, 0, 0].
      - Joint 2 rotates about Y with a fixed offset from Joint 1: translation [0, 0.13585, 0].
      - Joint 3 rotates about Y with a translation in Joint 2's frame of [0, -0.1197, 0.425].
      - The TCP is offset from Joint 3 by [0, 0, 0.39225].

    In effect the forward kinematics yield:
      • Base → Joint2: by rotating about Z (theta1) then a fixed translation.
      • Joints 2 and 3 form a planar (x–z) 2–link chain (with effective link lengths L1 = 0.425 and L2 = 0.39225)
        where the combined rotation is phi = theta2+theta3.
      • The overall orientation equals Rz(theta1) * Ry(theta2+theta3).

    The solution strategy is as follows:
      1. Determine theta1 from the base (x,y) coordinates:
             theta1 = atan2(-x, y)
         (this rotates the target position into the reference frame of Joint 2).
      
      2. Transform the TCP position into Joint 2’s frame by undoing the rotation by theta1.
         Let p = [x, y, z] be the TCP position (in the base frame). Rotate by -theta1:
             x_r = cos(theta1)*x + sin(theta1)*y
             y_r = -sin(theta1)*x + cos(theta1)*y
             z_r = z
         The fixed translation from Joint 1 to Joint 2 is [0, 0.13585, 0]. In a proper chain,
         the y-value should then satisfy: y_r - 0.13585 = -0.1197 (the offset in Joint 3’s local frame).
         For the 2–link planar inverse kinematics, we work only with the x and z components.
         Thus, we set:
             x_target = x_r
             z_target = z_r

      3. Extract the desired combined angle phi = theta2 + theta3 from the desired TCP orientation.
         The full chain’s orientation is Rz(theta1)*Ry(theta2+theta3). Given the desired roll-pitch-yaw r = (rx, ry, rz),
         one can show that for a pure Ry rotation the (0,0) and (0,2) entries of Ry(phi) are cos(phi) and sin(phi) respectively.
         Using the approach from EXISTING 2 we compute:
             R00 = cos(ry)*cos(rz)   and   R02 = sin(ry)
             phi = atan2(R02, R00)

      4. Solve the 2–link planar inverse kinematics.
         The forward kinematics for the subchain (in the x–z plane) are:
              x_target = L1*sin(theta2) + L2*sin(theta2+theta3)
              z_target = L1*cos(theta2) + L2*cos(theta2+theta3)
         where L1 = 0.425 and L2 = 0.39225.
         Writing phi = theta2+theta3, subtract the TCP offset:
              term_x = x_target - L2*sin(phi)
              term_z = z_target - L2*cos(phi)
         Then solve:
              theta2 = atan2(term_x, term_z)
              theta3 = phi - theta2

    :param p: Desired TCP position in the form (x, y, z).
    :param r: Desired TCP orientation (roll, pitch, yaw) in radians.
    :return: A tuple (theta1, theta2, theta3) of joint angles in radians.
    """
    import math

    # -----------------------------
    # 1. Solve for Joint 1 (rotation about Z)
    x, y, z = p
    theta1 = math.atan2(-x, y)
    
    # -----------------------------
    # 2. Express TCP position in Joint 2's frame.
    # Rotate TCP position by -theta1.
    cos_t1 = math.cos(theta1)
    sin_t1 = math.sin(theta1)
    x_r = cos_t1 * x + sin_t1 * y
    y_r = -sin_t1 * x + cos_t1 * y
    z_r = z  # unaffected by rotation about Z.
    # Joint 2 is translated from Joint 1 by [0, 0.13585, 0]. In the rotated frame the effective position becomes:
    # p_joint2 = (x_r, y_r - 0.13585, z_r)
    # For the planar IK (joints rotate about Y), only the x and z coordinates are needed.
    x_target = x_r
    z_target = z_r

    # -----------------------------
    # 3. Determine desired combined joint angle phi = theta2 + theta3 from the desired TCP orientation.
    rx, ry, rz = r
    # Compute intermediate rotation matrix terms using the provided approach.
    cy = math.cos(ry)
    sy = math.sin(ry)
    cz = math.cos(rz)
    # Here, the (0,0) and (0,2) entries for a pure Ry rotation are:
    R00 = cy * cz   # equals cos(phi)
    R02 = sy        # equals sin(phi)
    phi = math.atan2(R02, R00)
    
    # -----------------------------
    # 4. Solve the 2-link planar inverse kinematics for joints 2 and 3.
    L1 = 0.425    # Effective length from Joint 2 to Joint 3 (in the x–z plane)
    L2 = 0.39225  # TCP offset from Joint 3 (in the x–z plane)
    term_x = x_target - L2 * math.sin(phi)
    term_z = z_target - L2 * math.cos(phi)
    theta2 = math.atan2(term_x, term_z)
    theta3 = phi - theta2

    return (theta1, theta2, theta3)