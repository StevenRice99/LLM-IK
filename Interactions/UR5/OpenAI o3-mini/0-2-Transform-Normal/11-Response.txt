def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles (q1, q2, q3) for a 3-DOF serial manipulator to reach the desired 
    TCP position and orientation.
    
    The robot’s kinematic chain is given by:
    
       T_TCP = Rz(q1) · T([0, 0.13585, 0]) · Ry(q2) · T([0, -0.1197, 0.425]) · Ry(q3) · T([0, 0, 0.39225])
    
    Note:
      • The revolute joint axes are: q1 about Z, and both q2 and q3 about Y.
      • From the chain, the TCP orientation becomes R_TCP = Rz(q1) · Ry(q2+q3).
          With the desired TCP orientation provided as roll-pitch-yaw (r = (roll, pitch, yaw)), 
          we can match:
               q1 = yaw   and   q2 + q3 = pitch.
    
    The forward position part (ignoring the constant y-offset from the first two translations) 
    is determined by the transforms after applying Rz(q1); that is, after “removing” the base rotation 
    we have an effective 2D problem in the x–z plane. In this plane the TCP position satisfies:
    
         p'_x = A*sin(q2) + tcp_offset*sin(pitch)
         p'_z = A*cos(q2) + tcp_offset*cos(pitch)
    
    where:
         A = 0.425            (length from joint 2 to joint 3)
         tcp_offset = 0.39225   (offset from joint 3 to TCP along the local z axis)
         p' = Rz(-q1) * p       (p rotated by -q1 to “remove” the base rotation)
    
    Thus, we solve for q2 as:
    
         q2 = atan2( p'_x - tcp_offset*sin(pitch),  p'_z - tcp_offset*cos(pitch) )
    
    and then the remaining joint is:
    
         q3 = pitch - q2.
    
    :param p: A tuple (x, y, z) representing the target TCP position.
    :param r: A tuple (roll, pitch, yaw) representing the target TCP orientation in radians.
              (For this manipulator, roll is not used, and we assume roll == 0.)
    :return: A tuple (q1, q2, q3) of joint angles in radians.
    """
    import math

    # Set joint 1 so that its rotation matches the desired yaw.
    q1 = r[2]
    total_pitch = r[1]  # q2 + q3 should equal the desired pitch.

    # Remove the base rotation by rotating the target position by -q1.
    # Rz(-q1) rotates the position as follows:
    #    p'_x = cos(q1)*p_x + sin(q1)*p_y
    #    p'_z = p_z   (rotation about Z does not affect the z coordinate)
    c1 = math.cos(q1)
    s1 = math.sin(q1)
    p_prime_x = c1 * p[0] + s1 * p[1]
    p_prime_z = p[2]

    # Define known constants from the robot structure.
    A = 0.425         # length from joint 2 to joint 3 along the 'arm'
    tcp_offset = 0.39225  # offset from joint 3 to the TCP along the local z axis

    # Solve for q2 from the equations:
    #    A*sin(q2) = p'_x - tcp_offset*sin(total_pitch)
    #    A*cos(q2) = p'_z - tcp_offset*cos(total_pitch)
    num = p_prime_x - tcp_offset * math.sin(total_pitch)
    den = p_prime_z - tcp_offset * math.cos(total_pitch)
    q2 = math.atan2(num, den)

    # q3 is then determined by the requirement that q2 + q3 equals the desired total pitch.
    q3 = total_pitch - q2

    return (q1, q2, q3)