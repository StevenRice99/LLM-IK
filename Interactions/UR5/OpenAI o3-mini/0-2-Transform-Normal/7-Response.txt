def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles for a 3-DOF serial manipulator to reach a desired TCP position and orientation.
    
    The robot structure is:
       T_tcp = Rz(q1) * T([0, 0.13585, 0]) * Ry(q2) * T([0, -0.1197, 0.425]) * Ry(q3) * T([0, 0, 0.39225])
    
    Given that:
       - The TCP orientation is R_tcp = Rz(q1) * Ry(q2+q3)
       - The desired orientation "r" is given as (roll, pitch, yaw)
         (with roll assumed to be zero respectively, so that q1 = yaw and q2+q3 = pitch)
    
    The forward kinematics position (ignoring the constant y-offset) can be shown to be:
       p' = [0.425*sin(q2) + 0.39225*sin(pitch),
             (0.13585 - 0.1197),
             0.425*cos(q2) + 0.39225*cos(pitch)]
    where p' is the transformed TCP position obtained by removing the base rotation Rz(q1).
    
    Thus, we set:
       q1 = yaw
       Let pitch = r[1] so that q2 + q3 = pitch.
       
    For the x and z coordinates we remove the effect of q1:
       p' = Rz(-q1) * p, which gives:
           p'_x = cos(q1)*p_x + sin(q1)*p_y
           p'_z = p_z
    Then we have:
         0.425*sin(q2) = p'_x - 0.39225*sin(pitch)
         0.425*cos(q2) = p'_z - 0.39225*cos(pitch)
    so that:
         q2 = atan2(p'_x - 0.39225*sin(pitch), p'_z - 0.39225*cos(pitch))
         
    Finally:
         q3 = pitch - q2
         
    :param p: The target TCP position in the form (x, y, z)
    :param r: The target TCP orientation (rpy) in radians in the form (roll, pitch, yaw)
    :return: A tuple (q1, q2, q3) representing the joint angles in radians.
    """
    import math

    # Set joint 1 according to the desired yaw.
    q1 = r[2]
    pitch = r[1]  # q2 + q3 must equal the desired pitch.

    # Remove the base rotation to work in the plane of joints 2 and 3.
    # Given p = [p_x, p_y, p_z], compute p' = Rz(-q1)*p.
    c1 = math.cos(q1)
    s1 = math.sin(q1)
    p_prime_x = c1 * p[0] + s1 * p[1]
    p_prime_z = p[2]  # z remains unchanged since Rz rotation doesn't affect the z coordinate.

    # Given the TCP offset along the final (local z) direction (0.39225),
    # the effective position for joints 2 and 3 is:
    #   0.425*sin(q2) + 0.39225*sin(pitch) = p_prime_x
    #   0.425*cos(q2) + 0.39225*cos(pitch) = p_prime_z
    # Solve for q2:
    num = p_prime_x - 0.39225 * math.sin(pitch)
    den = p_prime_z - 0.39225 * math.cos(pitch)
    q2 = math.atan2(num, den)

    # Then compute q3 so that q2 + q3 = pitch.
    q3 = pitch - q2

    return (q1, q2, q3)