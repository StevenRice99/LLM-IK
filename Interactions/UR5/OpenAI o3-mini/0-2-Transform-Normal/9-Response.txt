def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles (q1, q2, q3) for a 3-DOF serial manipulator given a desired TCP position p
    and orientation r. The robot structure is defined by the following transform chain:
    
       T_TCP = Rz(q1) · T([0, 0.13585, 0]) · Ry(q2) · T([0, -0.1197, 0.425]) · Ry(q3) · T([0, 0, 0.39225])
    
    The desired orientation r is given in roll-pitch-yaw format (r = (roll, pitch, yaw)).
    Noting that the TCP rotation resulting from the chain is:
    
       R_TCP = Rz(q1) · Ry(q2 + q3)
    
    we set:
       q1 = yaw                and    q2 + q3 = pitch
       
    To solve for q2 and q3, we "remove" the effect of q1 from the target position.
    Compute p' = Rz(-q1)*p, where:
       p'_x = cos(q1)*p_x + sin(q1)*p_y
       p'_z = p_z   (since rotation Rz does not change the z-coordinate)
       
    The effective positioning (ignoring the constant offset in y-direction) for joints 2 and 3 is:
    
       0.425*sin(q2) + 0.39225*sin(pitch) = p'_x 
       0.425*cos(q2) + 0.39225*cos(pitch) = p'_z 
    
    From which we solve for q2 as:
    
       q2 = atan2( p'_x - 0.39225*sin(pitch),  p'_z - 0.39225*cos(pitch) )
       
    and then q3 = pitch - q2.
    
    :param p: Target TCP position as a tuple (x, y, z)
    :param r: Target TCP orientation as a tuple (roll, pitch, yaw) in radians. (roll is assumed to be 0)
    :return: A tuple (q1, q2, q3) representing the joint angles in radians.
    """
    import math

    # Set q1 equal to the desired yaw.
    q1 = r[2]
    pitch = r[1]  # q2 + q3 must equal the desired pitch.

    # Remove the base rotation by applying Rz(-q1) to p:
    # Rz(-q1) = [ [cos(q1), sin(q1), 0],
    #             [-sin(q1), cos(q1), 0],
    #             [    0,       0,    1] ]
    c1 = math.cos(q1)
    s1 = math.sin(q1)
    p_prime_x = c1 * p[0] + s1 * p[1]
    p_prime_z = p[2]

    # TCP offset along z from the last link
    tcp_offset = 0.39225

    # Using the effective equations:
    #     0.425*sin(q2) = p_prime_x - tcp_offset*sin(pitch)
    #     0.425*cos(q2) = p_prime_z - tcp_offset*cos(pitch)
    num = p_prime_x - tcp_offset * math.sin(pitch)
    den = p_prime_z - tcp_offset * math.cos(pitch)
    q2 = math.atan2(num, den)

    # Compute q3 so that q2 + q3 = pitch.
    q3 = pitch - q2

    return (q1, q2, q3)