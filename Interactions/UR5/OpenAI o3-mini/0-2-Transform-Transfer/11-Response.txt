def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float]:
    import math

    x, y, z = p
    r_roll, r_pitch, r_yaw = r
    tol = 1e-6

    # Enforce that the only achievable Roll is zero.
    if abs(r_roll) > tol:
        raise ValueError("Target roll must be zero for this 3 DOF manipulator.")

    # Compute theta3 using the law of cosines.
    # Effective offset from link 2: 0.13585 - 0.1197 = 0.01615.
    k = 0.01615
    numerator_cos_theta3 = x**2 + y**2 + z**2 - 0.334746
    cos_theta3 = numerator_cos_theta3 / 0.3334125
    # Clamp cos_theta3 to the valid range because of potential numerical inaccuracies.
    if cos_theta3 > 1.0:
        cos_theta3 = 1.0
    elif cos_theta3 < -1.0:
        cos_theta3 = -1.0
    theta3 = math.acos(cos_theta3)

    # Compute intermediate parameters for theta2.
    C = 0.425 + 0.39225 * math.cos(theta3)
    D = 0.39225 * math.sin(theta3)
    A_sq = x**2 + y**2 - k**2
    A = math.sqrt(A_sq) if A_sq >= 0 else 0.0

    denominator_theta2 = C**2 + D**2
    sin_theta2 = (C * A - D * z) / denominator_theta2
    cos_theta2 = (C * z + D * A) / denominator_theta2
    theta2 = math.atan2(sin_theta2, cos_theta2)

    # Compute theta1 from the position-derived value.
    if (x**2 + y**2) > tol:
        theta1_pos = math.atan2(A * y - k * x, A * x + k * y)
    else:
        theta1_pos = 0.0

    # Enforce that the TCP yaw equals theta1.
    theta1 = r_yaw if abs(theta1_pos - r_yaw) > tol else theta1_pos

    # Adjust theta2 and theta3 if the TCP pitch (theta2+theta3) is slightly off
    # from the desired pitch (r_pitch).
    current_pitch = theta2 + theta3
    if abs(current_pitch - r_pitch) > tol:
        delta = r_pitch - current_pitch
        theta2 += delta / 2.0
        theta3 += delta / 2.0

    return (theta1, theta2, theta3)