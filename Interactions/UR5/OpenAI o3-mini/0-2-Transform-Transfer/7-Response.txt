def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3) for a 3 DOF serial manipulator so that its
    tool center point (TCP) reaches the desired position and orientation.

    The manipulator is defined by:
      - Revolute 1: Rotation about the Z-axis.
      - Revolute 2: Rotation about the Y-axis.
      - Revolute 3: Rotation about the Y-axis.
    The provided link parameters are:
      Link 1 origin: Position [0, 0, 0], Orientation [0, 0, 0]
      Link 2 origin: Position [0, 0.13585, 0], Orientation [0, 0, 0]
      Link 3 origin: Position [0, -0.1197, 0.425], Orientation [0, 0, 0]
      TCP offset:   Position [0, 0, 0.39225], Orientation [0, 0, 0]

    Given that the only independent orientation output is the TCP yaw (which equals theta1) and that
    the TCP pitch is given by (theta2 + theta3) (with the TCP roll fixed to 0), the input orientation r
    must satisfy:
         roll  = 0,  pitch = theta2 + theta3,  yaw = theta1.
    
    Parameters:
      p: Desired TCP position as (x, y, z).
      r: Desired TCP orientation as (roll, pitch, yaw) in radians.
         For a valid target, roll must be zero.
    
    Returns:
      A tuple (theta1, theta2, theta3) of joint angles (in radians).

    Assumes the target is reachable.
    """
    import math

    x, y, z = p
    r_roll, r_pitch, r_yaw = r

    tol = 1e-6  # Tolerance for floating point comparisons

    # This 3 DOF manipulator can only achieve zero roll.
    if abs(r_roll) > tol:
        raise ValueError("Target roll must be zero for this 3 DOF manipulator.")

    # Compute theta3 via the law of cosines.
    # Derived constants from the link translation parameters:
    #   For Link 2: [0, 0.13585, 0]
    #   For Link 3: [0, -0.1197, 0.425]
    # An effective offset: k = 0.13585 - 0.1197 = 0.01615.
    k = 0.01615
    # The relation derived from the chain yields:
    #   cos(theta3) = (x^2 + y^2 + z^2 - 0.334746) / 0.3334125
    numerator_cos_theta3 = x**2 + y**2 + z**2 - 0.334746
    cos_theta3 = numerator_cos_theta3 / 0.3334125
    # Clamp cos_theta3 to handle numerical issues.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)

    # Compute theta2 using intermediate parameters.
    # Define:
    #   C = 0.425 + 0.39225 * cos(theta3)
    #   D = 0.39225 * sin(theta3)
    C = 0.425 + 0.39225 * math.cos(theta3)
    D = 0.39225 * math.sin(theta3)
    # A is based on the projection onto the XY plane, compensating for the offset k.
    A_sq = x**2 + y**2 - k**2
    A = math.sqrt(A_sq) if A_sq >= 0 else 0.0

    # Solve for theta2 using the following relations:
    #   sin(theta2) = (C * A - D * z) / (C^2 + D^2)
    #   cos(theta2) = (C * z + D * A) / (C^2 + D^2)
    denominator_theta2 = C**2 + D**2
    sin_theta2 = (C * A - D * z) / denominator_theta2
    cos_theta2 = (C * z + D * A) / denominator_theta2
    theta2 = math.atan2(sin_theta2, cos_theta2)

    # Compute theta1. The natural position-based solution is:
    #   theta1_pos = atan2(A*y - k*x, A*x + k*y)
    # But since TCP yaw must equal theta1 (r_yaw), we enforce:
    if (x**2 + y**2) > tol:
        theta1_pos = math.atan2(A * y - k * x, A * x + k * y)
    else:
        theta1_pos = 0.0

    if abs(theta1_pos - r_yaw) > tol:
        theta1 = r_yaw
    else:
        theta1 = theta1_pos

    # Check consistency for TCP pitch, which should be (theta2 + theta3).
    current_pitch = theta2 + theta3
    if abs(current_pitch - r_pitch) > tol:
        # Distribute any small numerical error evenly between theta2 and theta3.
        delta = r_pitch - current_pitch
        theta2 += delta / 2.0
        theta3 += delta / 2.0

    return (theta1, theta2, theta3)