def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closed‐form inverse kinematics solution for a 4-DOF serial manipulator.
    
    The kinematic chain is loosely decoupled into:
     • Joint 1 (q1): A rotation about Z that aligns the x–y position.
     • Joints 2 and 3 (q2, q3): A planar two‐link arm in the (p_z, Lx) plane.
     • Joint 4 (q4): An extra rotation about Y ensuring the overall TCP orientation.
    
    Parameters:
      p : Target TCP position [x, y, z].
      r : Target TCP orientation as roll–pitch–yaw in radians [roll, pitch, yaw].
      
    Returns:
      A tuple (q1, q2, q3, q4) of joint angles in radians.
    """
    import math

    # Unpack target position and orientation (roll, pitch, yaw)
    p_x, p_y, p_z = p
    roll, pitch, yaw = r

    # -------------------------------------------------------------------------
    # Step 1: Extract the orientation component corresponding to joints 2,3,4.
    #
    # The overall orientation of the TCP is given by:
    #   R_TCP = Rz(q1) · Ry(q2 + q3 + q4)
    #
    # Therefore, from the desired roll-pitch-yaw we build the rotation matrix.
    # Using the same convention as EXISTING 4:
    cr = math.cos(roll)
    sr = math.sin(roll)
    cp = math.cos(pitch)
    sp = math.sin(pitch)
    cy = math.cos(yaw)
    sy = math.sin(yaw)
    #
    # Only the elements R[0,0] and R[0,2] matter for the solution.
    R00 = cy * cp
    R02 = cy * sp * cr + sy * sr
    #
    # The accumulated rotation from joints 2,3,4 is given by:
    #   target_sum = q2 + q3 + q4 = atan2(R02, R00)
    target_sum = math.atan2(R02, R00)

    # -------------------------------------------------------------------------
    # Step 2: Solve for joint 1 (q1)
    #
    # The fixed link translations (in local coordinates) are:
    #   From Revolute 1 to Revolute 2: [0, 0.13585, 0]
    #   "Internal" offset at Revolute 2: [0, -0.1197, 0.425]  (the 0.425 affects the vertical arm)
    #   TCP offset: [0, 0.093, 0]
    #
    # Only the y components from the first and TCP offsets combine with the offset -0.1197:
    #   offset = 0.13585 - 0.1197 + 0.093 = 0.10915
    offset = 0.13585 - 0.1197 + 0.093   # 0.10915
    #
    # In the manipulator’s local frame (after applying q1), the x-direction contribution
    # (from joints 2 and 3) is denoted Lx. The observed (global) x–y distance is:
    r_xy = math.sqrt(p_x**2 + p_y**2)
    # And because of the constant offset along y we have:
    #   r_xy^2 = Lx^2 + offset^2   ⟹   Lx = sqrt(r_xy^2 - offset^2)
    Lx = math.sqrt(r_xy**2 - offset**2)
    #
    # Also, noting that the transformation in the x–y plane can be seen as:
    #   p_x + i p_y = e^(i·q1) * (Lx + i·offset)
    # therefore:
    q1 = math.atan2(p_y, p_x) - math.atan2(offset, Lx)

    # -------------------------------------------------------------------------
    # Step 3: Solve for joints 2 and 3 (q2 and q3)
    #
    # In the plane defined by (p_z, Lx), the effective two-link arm obeys:
    #   p_z = a*cos(q2) + b*cos(q2+q3)
    #   Lx  = a*sin(q2) + b*sin(q2+q3)
    #
    # with a = 0.425 and b = 0.39225.
    a = 0.425
    b = 0.39225
    #
    # Determine the effective distance in the (p_z, Lx) plane:
    r2 = math.sqrt(p_z**2 + Lx**2)
    #
    # Use the law of cosines to compute q3:
    cos_q3 = (r2**2 - a**2 - b**2) / (2 * a * b)
    # Clamp to [-1, 1] to account for floating-point errors:
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)   # Elbow-up solution
    #
    # Now compute q2:
    q2 = math.atan2(Lx, p_z) - math.atan2(b * math.sin(q3), a + b * math.cos(q3))

    # -------------------------------------------------------------------------
    # Step 4: Solve for joint 4 (q4)
    #
    # Knowing that:
    #   q2 + q3 + q4 = target_sum
    # we rearrange for q4:
    q4 = target_sum - (q2 + q3)

    return (q1, q2, q3, q4)