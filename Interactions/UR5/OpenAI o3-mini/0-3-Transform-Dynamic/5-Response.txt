def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach TCP position 'p' and orientation 'r'.
    The robot has 4 DOF with:
      - Joint 1: rotation about Z.
      - Joints 2–4: rotations about Y forming a planar chain (after undoing joint 1).
    
    Fixed transforms (from the URDF):
      • Joint 2 origin: translation by [0, 0.13585, 0]
      • TCP offset: translation by [0, 0.093, 0]
    Effective link lengths (for the planar chain):
      L1 = 0.425    (from joint 2 to joint 3)
      L2 = 0.39225  (from joint 3 to joint 4)
    
    The approach is:
      1. Compute joint 1 angle (q1) as the angle that orients p into joint 2's plane.
         q1 = atan2(-p_x, p_y)
    
      2. Build the TCP rotation matrix R_tcp from the roll, pitch, yaw (r), assuming:
             R_tcp = [[cy*cp, -sy,    cy*sp],
                      [sy*cp,  cy,    sy*sp],
                      [ -sp,    0,       cp]]
         where cr = cos(roll), sr = sin(roll),
               cp = cos(pitch), sp = sin(pitch),
               cy = cos(yaw),   sy = sin(yaw).
    
      3. Compute the wrist center by subtracting the TCP offset (transformed by R_tcp) from p.
    
      4. Determine joint 2's origin by applying rotation q1 on [0, 0.13585, 0].
         Compute the difference vector between the wrist center and joint 2's origin.
    
      5. Undo the base rotation (about Z) by rotating the vector by -q1.
         This brings the problem into the (x,z) plane for the 2R subchain.
    
      6. In the (x,z) plane, set:
             x_target = p_eff_x,  z_target = p_eff_z,
         and compute d = sqrt(x_target² + z_target²) and φ = atan2(x_target, z_target).
    
      7. Use the cosine law on the two-link arm to solve for joint 3:
             cos(q3_candidate) = (d² - L1² - L2²) / (2 L1 L2)
         Pick one solution branch as:
             q3 = -acos(cos(q3_candidate))
         and compute an intermediate angle δ = atan2(L2*sin(acos(…)), L1+L2*cos(acos(…))).
         Then joint 2 is set as:
             q2 = φ - δ.
    
      8. Enforce the wrist orientation: the sum q2+q3+q4 must equal target_sum,
         where target_sum is derived from R_tcp as:
             target_sum = atan2(R_tcp[0,2], R_tcp[0,0]).
         Therefore, set:
             q4 = target_sum - (q2 + q3).
    
    :param p: The TCP position [x, y, z] in meters.
    :param r: The TCP orientation as (roll, pitch, yaw) in radians.
    :return: A tuple (q1, q2, q3, q4) of joint values in radians.
    """
    import math
    import numpy as np

    # Step 1. Compute Joint 1 (rotation about Z)
    x, y, z = p
    q1 = math.atan2(-x, y)

    # Step 2. Build the TCP rotation matrix R_tcp from rpy.
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    # Using the given convention:
    R_tcp = np.array([
        [cy * cp, -sy,     cy * sp],
        [sy * cp,  cy,     sy * sp],
        [-sp,      0.0,    cp     ]
    ])

    # Step 3. Compute the wrist center by subtracting the TCP offset.
    tcp_offset = np.array([0.0, 0.093, 0.0])
    p_tcp = np.array([x, y, z])
    p_wrist = p_tcp - R_tcp @ tcp_offset

    # Step 4. Determine Joint 2's origin in the base frame.
    Rz = np.array([
        [math.cos(q1), -math.sin(q1), 0.0],
        [math.sin(q1),  math.cos(q1), 0.0],
        [0.0,           0.0,          1.0]
    ])
    joint2_origin = Rz @ np.array([0.0, 0.13585, 0.0])
    
    # Step 5. Transform the wrist center to joint 2's coordinate frame.
    p_diff = p_wrist - joint2_origin
    # Undo the rotation of q1:
    Rz_neg = np.array([
        [ math.cos(q1),  math.sin(q1), 0.0],
        [-math.sin(q1),  math.cos(q1), 0.0],
        [0.0,            0.0,          1.0]
    ])
    p_eff = Rz_neg @ p_diff

    # Step 6. Solve the planar 2R arm in the (x,z) plane.
    # p_eff[0] is x and p_eff[2] is z.
    x_target = p_eff[0]
    z_target = p_eff[2]
    d = math.sqrt(x_target**2 + z_target**2)
    phi = math.atan2(x_target, z_target)

    L1 = 0.425   # effective length from joint2 to joint3
    L2 = 0.39225 # effective length from joint3 to joint4

    # Use the cosine law to solve for q3 candidate.
    cos_q3_candidate = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clip to avoid numerical issues.
    cos_q3_candidate = max(min(cos_q3_candidate, 1.0), -1.0)
    q3_candidate = math.acos(cos_q3_candidate)
    # Choose one branch (elbow-down) for q3.
    q3 = -q3_candidate

    # Compute intermediate angle δ.
    delta = math.atan2(L2 * math.sin(q3_candidate), L1 + L2 * math.cos(q3_candidate))
    # Then solve for q2.
    q2 = phi - delta

    # Step 7. Enforce the wrist orientation.
    # target_sum is extracted from R_tcp.
    target_sum = math.atan2(R_tcp[0, 2], R_tcp[0, 0])
    q4 = target_sum - (q2 + q3)

    return (q1, q2, q3, q4)