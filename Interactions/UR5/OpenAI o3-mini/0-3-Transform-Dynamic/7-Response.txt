def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closed‐form inverse kinematics for a 4-DOF serial manipulator.
    
    The robot specifications are:
      • Revolute 1 (joint 1): position [0,0,0], rotation about Z.
      • Revolute 2 (joint 2): position [0, 0.13585, 0], rotation about Y.
      • Revolute 3 (joint 3): position [0, -0.1197, 0.425], rotation about Y.
      • Revolute 4 (joint 4): position [0, 0, 0.39225], rotation about Y.
      • The TCP (tool center point) offset is [0, 0.093, 0] from joint 4.
    
    The method follows these steps:
      1. Compute joint 1 angle (q1) by “aligning” the target position p into the plane of joints 2–4.
         We use q1 = atan2(–p_x, p_y).
      
      2. Build the TCP rotation matrix R_tcp from roll, pitch, yaw (r) using the convention:
           R_tcp = [ [cy*cp,            cy*sp*sr - sy*cr,   cy*sp*cr + sy*sr],
                     [sy*cp,            sy*sp*sr + cy*cr,   sy*sp*cr - cy*sr],
                     [ -sp,             cp*sr,              cp*cr           ] ]
         where cr = cos(roll), sr = sin(roll),
               cp = cos(pitch), sp = sin(pitch),
               cy = cos(yaw),   sy = sin(yaw).
      
      3. Compute the wrist center (the origin of joint 4) by subtracting the TCP offset (transformed by R_tcp)
         from the target position p.
      
      4. The origin of joint 2 is given by applying a rotation about Z (by q1) to [0, 0.13585, 0]. Compute the
         difference between the wrist center and joint 2's origin.
      
      5. Undo the base rotation by rotating this difference by –q1. This brings the problem into a 2D plane (x–z)
         valid for the 2R subchain of joints 2 and 3.
      
      6. Solve the planar inverse kinematics for a 2R manipulator with effective link lengths:
             L1 = 0.425   and   L2 = 0.39225.
         Define:
             x_target = p_eff[0], z_target = p_eff[2],
             d = sqrt(x_target² + z_target²),
             φ = atan2(x_target, z_target).
         Then by the cosine law:
             cos(q3_candidate) = (d² - L1² - L2²) / (2 * L1 * L2)
         and choose the “elbow-down” solution with:
             q3 = -acos(cos(q3_candidate)).
         Next, compute:
             δ = atan2(L2*sin(acos(cos(q3_candidate))), L1 + L2*cos(acos(cos(q3_candidate)))).
         Then,
             q2 = φ - δ.
      
      7. Finally, enforce the desired wrist orientation. The joints 2–4 must satisfy:
             q2 + q3 + q4 = target_sum,
         where target_sum is extracted from R_tcp as:
             target_sum = atan2(R_tcp[0,2], R_tcp[0,0]).
         So set:
             q4 = target_sum - (q2 + q3).
    
    :param p: The target TCP position as (x, y, z) in meters.
    :param r: The target TCP orientation as (roll, pitch, yaw) in radians.
    :return: A tuple (q1, q2, q3, q4) representing the joint angles in radians.
    """
    import math
    import numpy as np

    # Step 1: Compute joint 1 (rotation about Z)
    x, y, z = p
    q1 = math.atan2(-x, y)

    # Step 2: Construct the TCP rotation matrix R_tcp from the given roll, pitch, yaw.
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    R_tcp = np.array([
        [cy * cp,            cy * sp * sr - sy * cr,    cy * sp * cr + sy * sr],
        [sy * cp,            sy * sp * sr + cy * cr,    sy * sp * cr - cy * sr],
        [-sp,                cp * sr,                   cp * cr]
    ])

    # Step 3: Compute the wrist center by subtracting the TCP offset.
    tcp_offset = np.array([0.0, 0.093, 0.0])
    p_wrist = np.array(p) - R_tcp @ tcp_offset

    # Step 4: Compute joint 2’s origin in the base frame.
    Rz = np.array([
        [math.cos(q1), -math.sin(q1), 0.0],
        [math.sin(q1),  math.cos(q1), 0.0],
        [0.0,           0.0,          1.0]
    ])
    joint2_origin = Rz @ np.array([0.0, 0.13585, 0.0])

    # Step 5: Transform the wrist center into joint 2’s coordinate frame.
    p_diff = p_wrist - joint2_origin
    Rz_neg = np.array([
        [ math.cos(q1),  math.sin(q1), 0.0],
        [-math.sin(q1),  math.cos(q1), 0.0],
        [0.0,            0.0,          1.0]
    ])
    p_eff = Rz_neg @ p_diff

    # In the joint2 coordinate frame, solve for joints 2 and 3 in the x–z plane.
    x_target = p_eff[0]
    z_target = p_eff[2]
    d = math.sqrt(x_target**2 + z_target**2)
    phi = math.atan2(x_target, z_target)

    # Step 6: Solve the planar 2R inverse kinematics for joints 2 and 3.
    L1 = 0.425    # effective link from joint 2 to joint 3
    L2 = 0.39225  # effective link from joint 3 to joint 4

    cos_q3_candidate = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    cos_q3_candidate = max(min(cos_q3_candidate, 1.0), -1.0)
    q3_candidate = math.acos(cos_q3_candidate)
    # Choose the elbow-down solution for joint 3:
    q3 = -q3_candidate

    delta = math.atan2(L2 * math.sin(q3_candidate), L1 + L2 * math.cos(q3_candidate))
    q2 = phi - delta

    # Step 7: Compute joint 4 to satisfy the desired wrist orientation.
    target_sum = math.atan2(R_tcp[0, 2], R_tcp[0, 0])
    q4 = target_sum - (q2 + q3)

    return (q1, q2, q3, q4)