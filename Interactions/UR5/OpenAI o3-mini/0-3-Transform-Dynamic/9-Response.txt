def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math
    import numpy as np

    # Extract the target TCP position.
    x, y, z = p

    # Step 1: Compute joint 1 (rotation about Z) to align the target into the arm’s plane.
    q1 = math.atan2(-x, y)

    # Step 2: Build the TCP rotation matrix from roll, pitch, yaw.
    # Using the convention:
    #     R_tcp = [[cy*cp,  cy*sp*sr - sy*cr,  cy*sp*cr + sy*sr],
    #              [sy*cp,  sy*sp*sr + cy*cr,  sy*sp*cr - cy*sr],
    #              [  -sp,              cp*sr,             cp*cr  ]]
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    R_tcp = np.array([
        [cy * cp,            cy * sp * sr - sy * cr,  cy * sp * cr + sy * sr],
        [sy * cp,            sy * sp * sr + cy * cr,  sy * sp * cr - cy * sr],
        [   -sp,                           cp * sr,                cp * cr]
    ])

    # Step 3: Remove the TCP offset (given as [0, 0.093, 0]) to compute the wrist center.
    tcp_offset = np.array([0.0, 0.093, 0.0])
    p_tcp = np.array([x, y, z])
    p_wrist = p_tcp - R_tcp.dot(tcp_offset)

    # Step 4: Compute joint 2’s origin.
    # Joint 2 is located at [0, 0.13585, 0] in the base, rotated by q1 about the Z axis.
    Rz_q1 = np.array([
        [math.cos(q1), -math.sin(q1), 0.0],
        [math.sin(q1),  math.cos(q1), 0.0],
        [0.0,           0.0,          1.0]
    ])
    joint2_origin = Rz_q1.dot(np.array([0.0, 0.13585, 0.0]))

    # Step 5: Express the vector from joint 2’s origin to the wrist center.
    p_diff = p_wrist - joint2_origin
    # Undo the base rotation (q1) to transform into joint 2's coordinate frame.
    Rz_neg_q1 = np.array([
        [ math.cos(q1),  math.sin(q1), 0.0],
        [-math.sin(q1),  math.cos(q1), 0.0],
        [0.0,            0.0,         1.0]
    ])
    p_eff = Rz_neg_q1.dot(p_diff)

    # In joint 2's coordinate frame, the arm operates in the x–z plane.
    x_planar = p_eff[0]
    z_planar = p_eff[2]
    d = math.sqrt(x_planar**2 + z_planar**2)
    phi = math.atan2(x_planar, z_planar)

    # Step 6: Solve the planar 2R inverse kinematics.
    # Effective link lengths corresponding to the distances from joint 2 to joint 3 and joint 3 to joint 4.
    L1 = 0.425
    L2 = 0.39225

    # Use the cosine law.
    cos_q3 = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clip for numerical safety.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3_candidate = math.acos(cos_q3)
    # Choose the elbow-down configuration.
    q3 = -q3_candidate

    # Compute the angle offset for joint 2.
    delta = math.atan2(L2 * math.sin(q3_candidate), L1 + L2 * math.cos(q3_candidate))
    q2 = phi - delta

    # Step 7: Enforce wrist orientation.
    # The sum q2 + q3 + q4 must match the desired wrist angle.
    target_sum = math.atan2(R_tcp[0, 2], R_tcp[0, 0])
    q4 = target_sum - (q2 + q3)

    return (q1, q2, q3, q4)