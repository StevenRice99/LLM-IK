def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math

    # Link translation constants (in meters)
    d2    = 0.13585    # Translation from base (Revolute 1) to Revolute 2 along Y.
    d3_y  = -0.1197    # Y-offset from Revolute 2 to Revolute 3 (doesn't affect planar reach).
    d3_z  = 0.425      # Z-offset from Revolute 2 to Revolute 3.
    d4    = 0.39225    # Z-offset from Revolute 3 to Revolute 4.
    tcp_y = 0.093      # Y-offset from Revolute 4 to TCP.

    # The net constant offset in Y (unchanged by rotations about Y)
    constant_y = d2 + d3_y + tcp_y  # 0.13585 - 0.1197 + 0.093 = 0.10915

    # Unpack desired TCP position and orientation.
    x, y, z = p
    roll, pitch, yaw = r

    # The final TCP orientation is given by R = Rz(q1) * Ry(q2+q3+q4).
    # With the assumption that roll = 0, we set:
    q1 = yaw           # q1 (rotation about Z) is taken as the TCP yaw.
    total_pitch = pitch  # Must equal (q2 + q3 + q4)

    # "Undo" the effect of q1 on the TCP position to isolate the effective planar (x,z) components.
    cos_q1 = math.cos(q1)
    sin_q1 = math.sin(q1)
    # Rotate the position by -q1:
    p_prime_x = cos_q1 * x + sin_q1 * y
    # The y-component after rotation (p_prime_y) should ideally equal constant_y.
    # p_prime_y = -sin_q1 * x + cos_q1 * y   (not used further)
    p_prime_z = z

    # The effective distance in the (x,z) plane (planar reach)
    R_val = math.sqrt(p_prime_x**2 + p_prime_z**2)

    # Solve for q3 using the law of cosines for a two‐link planar arm.
    # The two links have effective lengths: L1 = d3_z and L2 = d4.
    cos_q3 = (R_val**2 - d3_z**2 - d4**2) / (2 * d3_z * d4)
    # Clamp to the valid range to handle numerical precision issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Compute intermediate values to solve for q2.
    A = d3_z + d4 * math.cos(q3)
    B = d4 * math.sin(q3)
    # γ is the geometric offset introduced by the second link.
    gamma = math.atan2(B, A)
    # θ_total is the angle of the effective target in the (x,z) plane.
    theta_total = math.atan2(p_prime_x, p_prime_z)
    q2 = theta_total - gamma

    # Finally, find q4 to meet the orientation requirement:
    q4 = total_pitch - (q2 + q3)

    return (q1, q2, q3, q4)