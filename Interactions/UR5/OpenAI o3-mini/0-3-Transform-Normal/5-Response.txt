def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" and orientation "r" for the 4 DOF arm.
    The robot’s kinematics chain is:
      TCP = T1 * T2 * T3 * T4 * T_TCP
    where:
      T1 = (no translation) then rotation about Z by q1.
      T2 = translation [0, 0.13585, 0] then rotation about Y by q2.
      T3 = translation [0, -0.1197, 0.425] then rotation about Y by q3.
      T4 = translation [0, 0, 0.39225] then rotation about Y by q4.
      T_TCP = translation [0, 0.093, 0].
      
    Note that because all fixed rotations are zero,
      the overall position becomes:
        p = Rz(q1)*[ X, constant_y, Z ]
      with constant_y = 0.13585 + (-0.1197) + 0.093 = 0.10915.
      And the (X,Z) part is generated by the two Y-axis joints q2 and q3:
        X = sin(q2+γ)*R_link,  Z = cos(q2+γ)*R_link,
      where R_link = sqrt( (d4*cos(q3)+d3_z)**2 + (d4*sin(q3))**2 ),
      with d3_z = 0.425 and d4 = 0.39225, and where
        γ = atan2(d4*sin(q3), d4*cos(q3)+d3_z).
      
    Meanwhile, the orientation produced is
        R = Rz(q1) * Ry(q2+q3+q4)
    and the TCP’s rpy is taken as [roll, pitch, yaw].
    In our arm the roll (rotation about X) is always zero so we assume r[0] == 0.
    Thus one identifies:
        q1       = r[2]       (yaw)
        q2+q3+q4 = r[1]       (pitch)
    
    With these observations the inverse kinematics can be computed in closed‐form.
    :param p: The TCP position as (x, y, z).
    :param r: The TCP orientation as (roll, pitch, yaw) in radians.
              (Assume roll is zero for reachable targets.)
    :return: A tuple (q1, q2, q3, q4) of joint angles in radians.
    """
    import math
    # Link translation constants (in meters)
    d2      = 0.13585      # Translation from Revolute 1 to 2 along y
    d3_y    = -0.1197      # y-translation from Revolute 2 to 3 (in joint2 frame)
    d3_z    = 0.425        # z-translation from Revolute 2 to 3 (in joint2 frame)
    d4      = 0.39225      # z-translation from Revolute 3 to 4 (in joint3 frame)
    tcp_y   = 0.093        # y-translation from Revolute 4 to TCP (in joint4 frame)
    # Combined constant translation in the arm’s y-direction (does not vary with joint rotations about Y)
    constant_y = d2 + d3_y + tcp_y   # = 0.13585 - 0.1197 + 0.093 = 0.10915

    # From the end-effector orientation:
    # The forward kinematics yields orientation R = Rz(q1) * Ry(q2+q3+q4),
    # and the provided r is in (roll, pitch, yaw) with roll (rotation about X) = 0.
    # Hence we set:
    q1 = r[2]           # yaw component
    total_pitch = r[1]  # must equal (q2 + q3 + q4)
    
    # To solve for the planar joints q2 and q3, first remove the effect of q1 from the TCP position.
    # Compute p' = Rz(-q1) * p.
    p_x, p_y, p_z = p
    cos_q1 = math.cos(q1)
    sin_q1 = math.sin(q1)
    p_prime_x = cos_q1 * p_x + sin_q1 * p_y
    p_prime_y = -sin_q1 * p_x + cos_q1 * p_y  # Should equal constant_y
    p_prime_z = p_z

    # (Optional) One might check that p_prime_y is (nearly) constant_y; we assume targets are reachable.
    
    # In the modified coordinates, the relevant (x,z) position of the arm (i.e. the projection onto the plane of motion)
    # is given by: [p_prime_x, p_prime_z]. The chain from joint2 onward contributes only to the x and z.
    # From the kinematics derivation, the (x,z) displacement is:
    #   [p_prime_x, p_prime_z] = R_link * [ sin(q2+γ), cos(q2+γ) ]
    # where R_link = sqrt( (d4*cos(q3)+d3_z)**2 + (d4*sin(q3))**2 ) and
    #       γ = atan2(d4*sin(q3), d4*cos(q3)+d3_z).
    # Also, the effective reach in the plane is:
    R_val = math.sqrt(p_prime_x**2 + p_prime_z**2)
    
    # Solve for q3 using the law of cosines.
    # The relation is: R_val^2 = d3_z^2 + d4^2 + 2*d3_z*d4*cos(q3)
    cos_q3 = (R_val**2 - d3_z**2 - d4**2) / (2 * d3_z * d4)
    # Clamp cos_q3 to the valid range [-1, 1] to account for numerical errors.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)
    
    # Compute helper terms A and B so that:
    #   A = d4*cos(q3) + d3_z
    #   B = d4*sin(q3)
    # Then the total effective reach is R_link = sqrt(A^2 + B^2) (which should equal R_val) and
    #   q2 + γ = angle_total, where γ = atan2(B, A) and angle_total = atan2(p_prime_x, p_prime_z).
    A = d4 * math.cos(q3) + d3_z
    B = d4 * math.sin(q3)
    # Although R_link should come out as:
    R_link = math.sqrt(A**2 + B**2)  # Ideally, R_link ~= R_val.
    angle_total = math.atan2(p_prime_x, p_prime_z)
    gamma = math.atan2(B, A)
    q2 = angle_total - gamma

    # With q2 and q3 known, q4 is determined by the orientation constraint:
    q4 = total_pitch - (q2 + q3)

    return (q1, q2, q3, q4)