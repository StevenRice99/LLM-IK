def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" and orientation "r" for the 4 DOF serial manipulator.
    
    The kinematic chain is:
       TCP = T1 * T2 * T3 * T4 * T_TCP
    with:
       • T1: rotation about Z by q1.
       • T2: translation [0, 0.13585, 0] then rotation about Y by q2.
       • T3: translation [0, -0.1197, 0.425] then rotation about Y by q3.
       • T4: translation [0, 0, 0.39225] then rotation about Y by q4.
       • T_TCP: translation [0, 0.093, 0].
       
    Since all fixed rotations are zero and rotations about Y leave a vector’s y-coordinate unchanged,
    a constant y-offset exists given by:
         constant_y = 0.13585 + (-0.1197) + 0.093 = 0.10915.
         
    The overall TCP position can then be viewed as:
         p = Rz(q1) * [X, constant_y, Z]
    where the (X,Z) components are produced by the planar two-link (q2, q3, q4) system.
    
    Furthermore, the overall orientation of the TCP is:
         R = Rz(q1) * Ry(q2+q3+q4)
    and the provided r is expressed in (roll, pitch, yaw) with roll assumed to be zero.
    Thus we set:
         q1 = yaw = r[2]         and  q2 + q3 + q4 = pitch = r[1].
         
    The (x,z) planar part of the kinematics uses the chain:
         [p'_x, p'_z] = [ sin(θ), cos(θ) ] * R_link,
    where p' is the TCP position after “undoing” the rotation by q1.
    
    The effective lengths in the planar system are:
         d3_z = 0.425 (from link 3)  and  d4 = 0.39225 (from link 4).
    Their contributions form a two‐link system whose endpoint distance R_val satisfies:
         R_val^2 = (d3_z + d4*cos(q3))^2 + (d4*sin(q3))^2
                 = d3_z^2 + d4^2 + 2*d3_z*d4*cos(q3).
    Thus q3 is given by:
         q3 = acos((R_val^2 - d3_z^2 - d4^2)/(2*d3_z*d4)).
         
    Then, letting:
         A = d3_z + d4*cos(q3)     and   B = d4*sin(q3),
    we have an intermediary angle:
         γ = atan2(B, A).
    Meanwhile, the angle from the planar TCP position is:
         θ_total = atan2(p'_x, p'_z).
    Hence:
         q2 = θ_total - γ.
    And finally, the remaining angle q4 is found from:
         q4 = (r[1]) - (q2 + q3).
         
    :param p: The TCP position (x, y, z) in meters.
    :param r: The TCP orientation in radians as (roll, pitch, yaw). (Assume roll == 0)
    :return: A tuple (q1, q2, q3, q4) of calculated joint angles in radians.
    """
    import math

    # Link translation constants (in meters)
    d2    = 0.13585    # Translation from base to Revolute 2 along y.
    d3_y  = -0.1197    # y-offset from Revolute 2 to 3 (does not affect planar reach).
    d3_z  = 0.425      # z-offset from Revolute 2 to 3.
    d4    = 0.39225    # z-offset from Revolute 3 to 4.
    tcp_y = 0.093      # y-offset from Revolute 4 to TCP.
    
    # The constant y-offset (remains unchanged by rotations about Y)
    constant_y = d2 + d3_y + tcp_y  # 0.13585 - 0.1197 + 0.093 = 0.10915

    # Extract TCP orientation components.
    # Assume roll = r[0] is 0. Set q1 (rotation about Z) equal to the yaw.
    q1 = r[2]
    total_pitch = r[1]  # This is equal to the sum (q2 + q3 + q4).

    # "Undo" the effect of q1 by rotating the TCP position by -q1.
    # This isolates the planar (x,z) components.
    p_x, p_y, p_z = p
    cos_q1 = math.cos(q1)
    sin_q1 = math.sin(q1)
    # p_prime is the transformed TCP position.
    p_prime_x = cos_q1 * p_x + sin_q1 * p_y
    p_prime_y = -sin_q1 * p_x + cos_q1 * p_y  # Expected to be near constant_y.
    p_prime_z = p_z

    # Compute the effective distance in the (x,z) plane.
    R_val = math.sqrt(p_prime_x**2 + p_prime_z**2)

    # Solve for q3 using the law of cosines:
    # R_val^2 = d3_z^2 + d4^2 + 2*d3_z*d4*cos(q3)
    cos_q3 = (R_val**2 - d3_z**2 - d4**2) / (2 * d3_z * d4)
    # Clamp cos_q3 to avoid numerical errors.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Compute helper variables for the effective two-link manipulator.
    A = d3_z + d4 * math.cos(q3)
    B = d4 * math.sin(q3)
    gamma = math.atan2(B, A)  # Angle contributed by the geometry.
    angle_total = math.atan2(p_prime_x, p_prime_z)  # Direction of the (x,z) target.

    # Determine q2 from the difference between the target direction and the geometric offset.
    q2 = angle_total - gamma

    # Finally, determine q4 from the orientation constraint.
    q4 = total_pitch - (q2 + q3)

    return (q1, q2, q3, q4)