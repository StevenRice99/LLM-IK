def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closed-form inverse kinematics for a 4 DOF serial manipulator.
    
    The chain is given by:
      TCP = T1 * T2 * T3 * T4 * T_TCP
    where:
       • T1: rotation about Z by q1.
       • T2: translation [0, 0.13585, 0] then rotation about Y by q2.
       • T3: translation [0, -0.1197, 0.425] then rotation about Y by q3.
       • T4: translation [0, 0, 0.39225] then rotation about Y by q4.
       • T_TCP: translation [0, 0.093, 0].
       
    Because all fixed rotations are zero, the overall TCP position can be written as:
         p = Rz(q1) * [X, constant_y, Z],
    with the constant y-offset:
         constant_y = 0.13585 + (-0.1197) + 0.093 = 0.10915.
    
    The arm’s orientation is:
         R = Rz(q1) * Ry(q2+q3+q4),
    and the given TCP orientation is in rpy form (roll, pitch, yaw) with roll = 0.
    We therefore set:
         q1 = yaw   and   q2 + q3 + q4 = pitch.
    
    The (x,z) components are produced from a planar two‑link arm with effective lengths:
         L1 = 0.425  (from Revolute 3’s z translation) and 
         L2 = 0.39225 (from Revolute 4’s z translation).
    Their contribution yields an effective reach R_val in the (x,z) plane.
    Using the law of cosines:
         R_val^2 = L1^2 + L2^2 + 2*L1*L2*cos(q3),
    so that:
         q3 = acos((R_val**2 - L1**2 - L2**2) / (2*L1*L2)).
    Next, defining:
         A = L1 + L2*cos(q3)     and    B = L2*sin(q3),
    we get an offset angle:
         γ = atan2(B, A).
    The target direction in the (x,z) plane is given by:
         θ_total = atan2(x_eff, z_eff),
    where the effective coordinates (x_eff, z_eff) are obtained by undoing q1 from p.
    Then,
         q2 = θ_total - γ.
    Finally, the remaining joint angle is:
         q4 = (pitch) - (q2 + q3).
    
    :param p: The desired TCP position (x, y, z) in meters.
    :param r: The desired TCP orientation (roll, pitch, yaw) in radians (assume roll == 0).
    :return: A tuple (q1, q2, q3, q4) with the joint angles in radians.
    """
    import math

    # Link translation constants (in meters)
    d2    = 0.13585    # Translation from base (Revolute 1) to Revolute 2 along Y.
    d3_y  = -0.1197    # Y-offset from Revolute 2 to Revolute 3 (does not affect planar reach).
    d3_z  = 0.425      # Z-offset from Revolute 2 to Revolute 3.
    d4    = 0.39225    # Z-offset from Revolute 3 to Revolute 4.
    tcp_y = 0.093      # Y-offset from Revolute 4 to TCP.
    
    # The constant y-value, after the effect of rotations about Y:
    constant_y = d2 + d3_y + tcp_y  # 0.10915

    # Extract orientation components.
    # By assumption, roll = r[0] == 0.
    # Set q1 as the yaw and total pitch as r[1] (which equals q2+q3+q4).
    q1 = r[2]
    total_pitch = r[1]

    # "Undo" the base rotation q1 to isolate the planar (x,z) components.
    p_x, p_y, p_z = p
    cos_q1 = math.cos(q1)
    sin_q1 = math.sin(q1)
    # Rotate position by -q1:
    p_prime_x = cos_q1 * p_x + sin_q1 * p_y
    p_prime_y = -sin_q1 * p_x + cos_q1 * p_y  # Ideally near constant_y.
    p_prime_z = p_z

    # Compute the effective distance in the (x,z) plane.
    R_val = math.sqrt(p_prime_x**2 + p_prime_z**2)

    # Solve for q3 from the planar two-link arm (using law of cosines).
    cos_q3 = (R_val**2 - d3_z**2 - d4**2) / (2 * d3_z * d4)
    # Clamp to valid range to avoid numerical issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)
    
    # Compute helper variables to determine q2.
    A = d3_z + d4 * math.cos(q3)
    B = d4 * math.sin(q3)
    gamma = math.atan2(B, A)
    # Angle of the vector from the (x,z) coordinates.
    angle_total = math.atan2(p_prime_x, p_prime_z)
    
    q2 = angle_total - gamma

    # Determine q4 from the overall pitch requirement.
    q4 = total_pitch - (q2 + q3)

    return (q1, q2, q3, q4)