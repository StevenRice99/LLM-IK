def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach a desired end-effector position and orientation.
    
    The manipulator has 4 revolute joints with the following structure:
      - Joint 1 rotates about the Z-axis.
      - Joints 2, 3, and 4 rotate about the Y-axis (in their local frames).
      
    The forward kinematics for this arm result in the TCP orientation being:
        R = Rz(q1) * Ry(q2) * Ry(q3) * Ry(q4) = Rz(q1) * Ry(q2+q3+q4).
    
    The provided closed-form solution for the position is:
        x, y, z = p
        q3 = arccos((x²+y²+z² – 0.346395)/0.3341625)
        A = 0.425 + 0.39225*cos(q3)
        B = 0.39225*sin(q3)
        S = sqrt(x²+y² – 0.10915²)
        q2 = arctan2(S*A - z*B, S*B + z*A)
        phi = arctan2(0.10915, S)
        q1 = arctan2(y, x) - phi

    To incorporate the desired orientation, given as roll-pitch-yaw (r = [roll, pitch, yaw]),
    we use the URDF convention to form R_des:
          R_des = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    Recognizing that the joint configuration produces:
          R = Rz(q1) @ Ry(q2+q3+q4),
    we “remove” the effect of q1 by forming:
          R_aux = Rz(-q1) @ R_des = Ry(q2+q3+q4)
    and then extract the total rotation about Y, q_total = q2+q3+q4, from R_aux.
    Finally, q4 is determined as:
          q4 = q_total - (q2+q3)
    
    Assumes that all input targets are reachable and ignores singularity checks.
    
    :param p: The target position [x, y, z] in world coordinates.
    :param r: The target orientation as roll, pitch, yaw in radians: [roll, pitch, yaw].
    :return: A tuple of joint angles (q1, q2, q3, q4) in radians.
    """
    import numpy as np

    # Unpack the desired end-effector position.
    x, y, z = p

    # --- Position Inverse Kinematics (closed-form solution) ---
    # Compute q3 using the law of cosines.
    numerator   = x**2 + y**2 + z**2 - 0.346395
    denominator = 0.3341625
    cos_q3 = np.clip(numerator / denominator, -1.0, 1.0)
    q3 = np.arccos(cos_q3)
    
    # Intermediate parameters based on the robot's link dimensions.
    A = 0.425 + 0.39225 * np.cos(q3)
    B = 0.39225 * np.sin(q3)
    
    # Compute the effective distance S in the XY-plane, accounting for the offset of 0.10915.
    S_squared = x**2 + y**2 - 0.10915**2
    S = np.sqrt(S_squared) if S_squared >= 0 else 0.0
    C = z
    q2 = np.arctan2(S * A - C * B, S * B + C * A)
    
    # Compute a correction angle (phi) due to the offset.
    phi = np.arctan2(0.10915, S) if S != 0 else np.pi/2
    q1 = np.arctan2(y, x) - phi
    # Normalize q1 to the range [-pi, pi].
    q1 = (q1 + np.pi) % (2 * np.pi) - np.pi

    # --- Orientation Inverse Kinematics ---
    # Calculate the desired rotation matrix R_des from the given rpy.
    roll, pitch, yaw = r

    # Compute rotation matrices around X, Y, and Z using standard definitions.
    R_x = np.array([[1, 0, 0],
                    [0, np.cos(roll), -np.sin(roll)],
                    [0, np.sin(roll),  np.cos(roll)]])
    
    R_y = np.array([[ np.cos(pitch), 0, np.sin(pitch)],
                    [      0,         1,      0       ],
                    [-np.sin(pitch), 0, np.cos(pitch)]])
    
    R_z = np.array([[np.cos(yaw), -np.sin(yaw), 0],
                    [np.sin(yaw),  np.cos(yaw), 0],
                    [     0,           0,       1]])
    
    # According to the URDF convention: roll -> pitch -> yaw.
    R_des = R_z @ R_y @ R_x

    # Remove the effect of the base rotation (q1) by premultiplying with Rz(-q1).
    Rz_neg_q1 = np.array([[ np.cos(q1),  np.sin(q1), 0],
                          [-np.sin(q1),  np.cos(q1), 0],
                          [     0,          0,       1]])
    R_aux = Rz_neg_q1 @ R_des

    # R_aux should be a pure rotation about the Y-axis: R_aux = Ry(q2+q3+q4).
    # The rotation matrix for a rotation about Y by an angle theta is:
    #   [ cos(theta)   0  sin(theta) ]
    #   [     0        1       0     ]
    #   [-sin(theta)   0  cos(theta) ]
    # We can therefore extract q_total = q2 + q3 + q4 as:
    q_total = np.arctan2(R_aux[0, 2], R_aux[0, 0])
    
    # Solve for q4 based on the fact that q_total = q2 + q3 + q4.
    q4 = q_total - (q2 + q3)
    # Normalize q4 to the range [-pi, pi].
    q4 = (q4 + np.pi) % (2 * np.pi) - np.pi

    return (q1, q2, q3, q4)