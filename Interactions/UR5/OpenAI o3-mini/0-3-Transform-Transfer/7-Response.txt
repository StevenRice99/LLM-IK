def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values (q1, q2, q3, q4) needed to reach a desired end-effector (TCP) position and orientation.
    
    The manipulator has 4 revolute joints with the following kinematic structure:
      • Joint 1 rotates about Z.
      • Joints 2, 3, and 4 rotate about Y (in their local frames).
    
    The forward kinematics yield an overall orientation of:
         R = Rz(q1)*Ry(q2)*Ry(q3)*Ry(q4) = Rz(q1)*Ry(q2+q3+q4)
    
    The provided closed-form solution for the position (ignoring orientation) is:
         x, y, z = p
         q3 = arccos((x²+y²+z² – 0.346395)/0.3341625)
         A = 0.425 + 0.39225*cos(q3)
         B = 0.39225*sin(q3)
         S = sqrt(x²+y² – 0.10915²)
         q2 = arctan2( S*A - z*B, S*B + z*A )
         φ  = arctan2(0.10915, S)
         q1 = arctan2(y, x) – φ
         
    To incorporate the desired orientation, given by roll-pitch-yaw “r” (with URDF convention):
         R_des = Rz(yaw) @ Ry(pitch) @ Rx(roll)
         
    Removing the effect of q1 from the orientation by forming:
         R_aux = Rz(-q1) @ R_des,
    we note that R_aux should be a pure rotation about Y, i.e., 
         R_aux = Ry(q2+q3+q4)
    Hence we extract the combined Y-axis rotation:
         q_total = q2 + q3 + q4 = arctan2( R_aux[0,2], R_aux[0,0] )
    and finally compute:
         q4 = q_total - (q2+q3)
    
    Assumes that the target is reachable and does not perform singularity checks.
    
    :param p: Target position as (x, y, z)
    :param r: Target orientation as (roll, pitch, yaw) in radians.
    :return: Tuple of joint angles (q1, q2, q3, q4) in radians.
    """
    import numpy as np

    # Unpack target position and orientation
    x, y, z = p
    roll, pitch, yaw = r

    # --- POSITION INVERSE KINEMATICS ---
    # Compute joint 3 angle using the law of cosines.
    numerator   = x**2 + y**2 + z**2 - 0.346395
    denominator = 0.3341625
    cos_q3 = np.clip(numerator / denominator, -1.0, 1.0)
    q3 = np.arccos(cos_q3)

    # Intermediate terms based on manipulator dimensions.
    A = 0.425 + 0.39225 * np.cos(q3)
    B = 0.39225 * np.sin(q3)
    
    # Compute "S", the effective distance in the XY-plane (accounting for offset along the X-axis).
    S_squared = x**2 + y**2 - (0.10915)**2
    S = np.sqrt(S_squared) if S_squared >= 0 else 0.0
    C = z

    # Compute joint 2 using the geometry of the manipulator.
    q2 = np.arctan2(S * A - C * B, S * B + C * A)
    
    # Determine the base joint correction due to the lateral offset.
    phi = np.arctan2(0.10915, S) if S != 0 else np.pi/2
    q1 = np.arctan2(y, x) - phi
    # Normalize q1 to the range [-pi, pi]
    q1 = (q1 + np.pi) % (2 * np.pi) - np.pi

    # --- ORIENTATION INVERSE KINEMATICS ---
    # Compute the desired end-effector rotation matrix from roll, pitch, yaw.
    # According to the URDF convention: R_des = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    R_x = np.array([
        [1, 0, 0],
        [0, np.cos(roll), -np.sin(roll)],
        [0, np.sin(roll),  np.cos(roll)]
    ])
    R_y = np.array([
        [ np.cos(pitch), 0, np.sin(pitch)],
        [      0,        1,      0      ],
        [-np.sin(pitch), 0, np.cos(pitch)]
    ])
    R_z = np.array([
        [np.cos(yaw), -np.sin(yaw), 0],
        [np.sin(yaw),  np.cos(yaw), 0],
        [     0,           0,     1]
    ])
    R_des = R_z @ R_y @ R_x

    # Remove the effect of the base joint (q1) from the orientation.
    # Rz(-q1) is the inverse rotation about the Z-axis.
    Rz_neg_q1 = np.array([
        [ np.cos(q1),  np.sin(q1), 0],
        [-np.sin(q1),  np.cos(q1), 0],
        [     0,          0,       1]
    ])
    R_aux = Rz_neg_q1 @ R_des

    # R_aux should represent a pure rotation about Y: R_aux = Ry(q_total)
    # For a rotation about Y by an angle q_total:
    #   cos(q_total) = R_aux[0,0]   and   sin(q_total) = R_aux[0,2]
    q_total = np.arctan2(R_aux[0, 2], R_aux[0, 0])
    
    # Solve for joint 4 (q4) knowing that q_total = q2 + q3 + q4.
    q4 = q_total - (q2 + q3)
    q4 = (q4 + np.pi) % (2 * np.pi) - np.pi

    return (q1, q2, q3, q4)