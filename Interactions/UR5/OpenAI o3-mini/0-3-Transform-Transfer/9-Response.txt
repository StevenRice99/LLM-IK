def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import numpy as np

    # Unpack the target position and orientation.
    x, y, z = p
    roll, pitch, yaw = r

    # --- POSITION INVERSE KINEMATICS ---
    # Compute q3 from the law of cosines.
    numerator = x**2 + y**2 + z**2 - 0.346395
    denominator = 0.3341625
    cos_q3 = np.clip(numerator / denominator, -1.0, 1.0)
    q3 = np.arccos(cos_q3)

    # Intermediate values from the manipulatorâ€™s geometry.
    A = 0.425 + 0.39225 * np.cos(q3)
    B = 0.39225 * np.sin(q3)

    # Compute the effective planar distance S accounting for the lateral offset of 0.10915.
    S_squared = x**2 + y**2 - (0.10915)**2
    S = np.sqrt(S_squared) if S_squared >= 0 else 0.0
    C = z

    # Solve for q2.
    q2 = np.arctan2(S * A - C * B, S * B + C * A)

    # Compute the correction for q1 due to the offset.
    phi = np.arctan2(0.10915, S) if S != 0 else np.pi / 2
    q1 = np.arctan2(y, x) - phi
    # Normalize q1 to lie within [-pi, pi].
    q1 = (q1 + np.pi) % (2 * np.pi) - np.pi

    # --- ORIENTATION INVERSE KINEMATICS ---
    # Construct the desired end-effector rotation matrix R_des from roll-pitch-yaw using the URDF convention:
    # R_des = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    R_x = np.array([[1, 0, 0],
                    [0, np.cos(roll), -np.sin(roll)],
                    [0, np.sin(roll),  np.cos(roll)]])
    R_y = np.array([[ np.cos(pitch), 0, np.sin(pitch)],
                    [             0, 1,             0],
                    [-np.sin(pitch), 0, np.cos(pitch)]])
    R_z = np.array([[np.cos(yaw), -np.sin(yaw), 0],
                    [np.sin(yaw),  np.cos(yaw), 0],
                    [         0,           0, 1]])
    R_des = R_z @ R_y @ R_x

    # Remove the effect of the base rotation q1.
    # Compute the rotation matrix for -q1 about Z.
    Rz_neg_q1 = np.array([[ np.cos(q1),  np.sin(q1), 0],
                          [-np.sin(q1),  np.cos(q1), 0],
                          [         0,           0, 1]])
    R_aux = Rz_neg_q1 @ R_des

    # Since the forward kinematics yield:
    #     R = Rz(q1)*Ry(q2+q3+q4)
    # after removing Rz(q1) the remaining rotation should be a pure rotation about Y:
    #     R_aux = Ry(q2+q3+q4)
    # For rotation about Y:
    #     Ry(theta) = [[ cos(theta), 0, sin(theta)],
    #                   [     0,      1,     0     ],
    #                   [-sin(theta), 0, cos(theta)]]
    # so we can extract the total Y rotation angle as:
    q_total = np.arctan2(R_aux[0, 2], R_aux[0, 0])
    
    # Knowing that q_total = q2 + q3 + q4, solve for q4.
    q4 = q_total - (q2 + q3)
    q4 = (q4 + np.pi) % (2 * np.pi) - np.pi

    return (q1, q2, q3, q4)