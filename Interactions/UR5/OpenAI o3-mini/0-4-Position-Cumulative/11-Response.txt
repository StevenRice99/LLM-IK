def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math
    # Unpack the target TCP position.
    p_x, p_y, p_z = p

    # Compute horizontal distance and polar angle in base XY plane.
    r = math.sqrt(p_x**2 + p_y**2)
    delta = math.atan2(p_y, p_x)

    # Fixed horizontal offset from the constant translations.
    # (0.13585 - 0.1197 + 0.093 = 0.10915 m)
    offset = 0.10915

    # Determine base joint q1 so that after rotation the Y-component equals the offset.
    # That is, r * sin(delta - q1) = offset  ==>  q1 = delta - arcsin(offset/r)
    phi = math.asin(offset / r)
    q1 = delta - phi

    # Rotate the horizontal (XY) coordinates into the “arm plane”.
    # After rotation, the effective x-coordinate is:
    x_arm = math.cos(q1) * p_x + math.sin(q1) * p_y
    # The vertical coordinate in the arm plane is unchanged: p_z

    # Define effective link lengths.
    L1 = 0.425
    L2 = 0.39225 + 0.09465  # equals 0.4869 m (translation from joint4 and TCP offset)

    # Compute effective distance in the arm (sagittal) plane.
    r_eff = math.sqrt(x_arm**2 + p_z**2)

    # Use the law of cosines to solve for the elbow angle q3.
    cos_q3 = (r_eff**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp to ensure a valid acos argument.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Solve for the shoulder angle q2.
    q2 = math.atan2(x_arm, p_z) - math.atan2(L2 * math.sin(q3), L1 + L2 * math.cos(q3))

    # Choose wrist joints arbitrarily: they do not affect TCP position.
    q4 = 0.0
    q5 = 0.0

    return (q1, q2, q3, q4, q5)