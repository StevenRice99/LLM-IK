def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 5-DOF manipulator so that its TCP is reached at position p.
    
    The manipulator's structure is as follows:
      • Joint 1 rotates about Z.
      • There is a net fixed horizontal offset of 0.10915 m caused by:
          - A translation of +0.13585 m in Y (joint 2 origin)
          - A translation of -0.1197 m in Y (joint 3 origin)
          - A translation of +0.093 m in Y (joint 5 origin)
      • The arm (joints 2 and 3) form a planar 2R chain in the "arm-plane" (defined by the rotated TCP)
        with effective link lengths:
            L1 = 0.425 m  (first link length)
            L2 = 0.39225 + 0.09465 = 0.4869 m (second link, comprising joint4 translation and TCP offset)
      • Since only position is specified, the wrist joints (joints 4 and 5) are chosen as q4 = q5 = 0.
      
    The solution approach:
      1. With the TCP position p = [p_x, p_y, p_z], the horizontal (XY) distance is r = sqrt(p_x²+p_y²), and 
         its polar angle is δ = atan2(p_y, p_x).
      2. To counteract the fixed horizontal offset, we require that, after rotating the base by –q1, 
         the Y-coordinate (in the arm-plane) equals the known offset. This yields:
             r * sin(δ – q1) = offset   -->   q1 = δ – arcsin(offset / r)
      3. Rotate the horizontal position (p_x,p_y) by –q1 to compute the effective x_arm coordinate.
         In the arm-plane:
             x_arm = cos(q1)*p_x + sin(q1)*p_y
         and the vertical coordinate remains p_z.
      4. The 2R inverse kinematics on the plane:
             x_arm = L1*sin(q2) + L2*sin(q2+q3)
             p_z   = L1*cos(q2) + L2*cos(q2+q3)
         gives:
             q3 = acos[(r_eff² – L1² – L2²) / (2 L1 L2)]   with r_eff = sqrt(x_arm²+p_z²)
             q2 = atan2(x_arm, p_z) – atan2(L2*sin(q3), L1+L2*cos(q3))
      5. With q4 and q5 chosen to be zero, the complete solution is obtained.
      
    :param p: A tuple (p_x, p_y, p_z) specifying the desired TCP position.
    :return: A tuple (q1, q2, q3, q4, q5) giving the joint angles in radians.
    """
    import math

    # Unpack the TCP position.
    p_x, p_y, p_z = p

    # Compute the horizontal distance and angle in the base's XY-plane.
    r = math.sqrt(p_x**2 + p_y**2)
    delta = math.atan2(p_y, p_x)
    
    # Fixed horizontal offset (derived from the manipulator's constant translations).
    offset = 0.10915

    # Solve for q1 such that, after rotation by -q1, the Y-component becomes equal to the offset.
    # That is: r * sin(delta - q1) = offset  -->  q1 = delta - arcsin(offset / r)
    phi = math.asin(offset / r)
    q1 = delta - phi

    # Rotate the horizontal TCP position into the arm-plane.
    # This ensures that after applying q1, the second coordinate is the fixed offset.
    x_arm = math.cos(q1) * p_x + math.sin(q1) * p_y
    # The vertical coordinate in the arm-plane remains p_z.
    
    # Define the effective link lengths.
    L1 = 0.425                           # Link from joint2 to joint3.
    L2 = 0.39225 + 0.09465                # Effective second link (joint4 translation plus TCP offset) = 0.4869.
    
    # Determine the effective distance in the arm-plane.
    r_eff = math.sqrt(x_arm**2 + p_z**2)
    
    # Use the law of cosines to solve for the elbow angle q3.
    # cos(q3) = (r_eff² - L1² - L2²) / (2 * L1 * L2)
    cos_q3 = (r_eff**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_q3 to the valid range to address potential numerical issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)
    
    # Solve for the shoulder angle q2 using the law of sines/cosines.
    q2 = math.atan2(x_arm, p_z) - math.atan2(L2 * math.sin(q3), L1 + L2 * math.cos(q3))
    
    # Choose wrist joints arbitrarily since they do not affect the position.
    q4 = 0.0
    q5 = 0.0
    
    return (q1, q2, q3, q4, q5)