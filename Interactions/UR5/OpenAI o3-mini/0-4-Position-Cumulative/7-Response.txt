def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 5-DOF serial manipulator to achieve
    a desired TCP position p = (p_x, p_y, p_z).

    Manipulator details:
      • Joint 1 rotates about Z.
      • Fixed translations result in a net horizontal offset of 0.10915 m.
         (This is derived as: 0.13585 (joint 2) - 0.1197 (joint 3) + 0.093 (joint 5))
      • The arm (joints 2 and 3) forms a planar 2R system with effective link lengths:
             L1 = 0.425 m
             L2 = 0.39225 + 0.09465 = 0.4869 m
      • The wrist joints (joints 4 and 5) are chosen as 0 since they do not affect the TCP position.
    
    The solution is obtained by first “removing” the effect of the constant offset.
    After rotating the TCP coordinates by -q1, the second coordinate equals the offset.
    This provides:
          r * sin(δ - q1) = offset   where r = sqrt(p_x²+p_y²) and δ = atan2(p_y,p_x).
    Thus, q1 = δ - arcsin(offset/r).

    Then, the TCP position (p_x, p_y, p_z) is rotated into the “arm plane” to get:
          x_arm = cos(q1)*p_x + sin(q1)*p_y   and   z_arm = p_z.
    The 2R inverse kinematics on this plane gives:
          x_arm = L1*sin(q2) + L2*sin(q2+q3)
          z_arm = L1*cos(q2) + L2*cos(q2+q3)
    from which, using the law of cosines:
          q3 = acos((r_eff² - L1² - L2²) / (2 * L1 * L2))   with r_eff = sqrt(x_arm² + p_z²)
          q2 = atan2(x_arm, p_z) - atan2(L2*sin(q3), L1 + L2*cos(q3))
    
    Finally, we choose q4 = 0 and q5 = 0.

    :param p: A tuple (p_x, p_y, p_z) specifying the desired TCP position.
    :return: A tuple (q1, q2, q3, q4, q5) with the joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    p_x, p_y, p_z = p

    # Compute horizontal distance and the polar angle in the XY-plane.
    r = math.sqrt(p_x**2 + p_y**2)
    delta = math.atan2(p_y, p_x)

    # The fixed horizontal offset from the constant translations.
    offset = 0.10915

    # Determine q1 by ensuring the rotated Y-coordinate equals "offset"
    # r * sin(delta - q1) = offset  ==>  q1 = delta - arcsin(offset/r)
    phi = math.asin(offset / r)
    q1 = delta - phi

    # Rotate the horizontal (XY) coordinates into the "arm plane".
    # After rotation, the Y-coordinate is offset and the X-coordinate (named x_arm) is effective for the 2R chain.
    x_arm = math.cos(q1) * p_x + math.sin(q1) * p_y
    # The vertical coordinate in the arm plane is simply p_z.
    
    # Define effective link lengths.
    L1 = 0.425
    L2 = 0.39225 + 0.09465  # equals 0.4869

    # Calculate the effective distance in the arm (sagittal) plane.
    r_eff = math.sqrt(x_arm**2 + p_z**2)

    # Law of cosines to compute q3 (the elbow angle).
    cos_q3 = (r_eff**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp the value to the valid range to avoid numerical errors.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Compute q2 (shoulder angle) from the geometry.
    q2 = math.atan2(x_arm, p_z) - math.atan2(L2 * math.sin(q3), L1 + L2 * math.cos(q3))

    # Choose wrist joints to be zero (redundant since TCP position is reached already).
    q4 = 0.0
    q5 = 0.0

    return (q1, q2, q3, q4, q5)