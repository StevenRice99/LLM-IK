def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 5-DOF serial manipulator so that its TCP reaches position p.
    The manipulator has:
      • Joint 1 rotating about the Z-axis.
      • Fixed translations that yield a net horizontal offset of 0.10915 m.
      • A 2R arm (joints 2 and 3) operating in an "arm plane" with effective link lengths:
             L1 = 0.425 m
             L2 = 0.39225 + 0.09465 = 0.4869 m.
      • Wrist joints (joints 4 and 5) that do not affect the TCP position (thus set to 0).
      
    The solution procedure:
      1. Let p = (p_x, p_y, p_z) be the target TCP position.
      2. Compute r = sqrt(p_x² + p_y²) and the polar angle δ = atan2(p_y, p_x).
      3. Since after the base rotation q1 the effective horizontal offset in the arm plane must equal 0.10915 m,
         we have: r * sin(δ – q1) = 0.10915. Therefore, choose:
               q1 = δ – asin(0.10915 / r).
      4. Rotate the horizontal position by –q1 to get the effective x-coordinate in the arm plane:
               x_arm = cos(q1)*p_x + sin(q1)*p_y.
         The vertical coordinate remains p_z.
      5. For the 2R chain:
             x_arm = L1*sin(q2) + L2*sin(q2+q3)
             p_z   = L1*cos(q2) + L2*cos(q2+q3),
         define r_eff = sqrt(x_arm²+p_z²) and use the law of cosines to obtain:
               cos(q3) = (r_eff² - L1² - L2²) / (2 * L1 * L2)
         (ensure cos(q3) is within [-1, 1] to address numerical issues),
         then q3 = acos(cos(q3)),
         and solve for q2:
               q2 = atan2(x_arm, p_z) - atan2(L2*sin(q3), L1 + L2*cos(q3)).
      6. Choose q4 = 0.0 and q5 = 0.0.
      
    :param p: A tuple (p_x, p_y, p_z) representing the target TCP position.
    :return: A tuple (q1, q2, q3, q4, q5) of joint angles in radians.
    """
    import math

    # Unpack the TCP coordinates.
    p_x, p_y, p_z = p

    # Compute horizontal distance and polar angle.
    r = math.sqrt(p_x**2 + p_y**2)
    delta = math.atan2(p_y, p_x)

    # Fixed horizontal offset from the manipulator's translations.
    offset = 0.10915

    # Compute base joint angle q1 such that after rotation by -q1,
    # the second component becomes equal to the offset.
    # r * sin(delta - q1) = offset  ==>  q1 = delta - arcsin(offset/r)
    phi = math.asin(offset / r)
    q1 = delta - phi

    # Rotate the horizontal coordinates into the arm plane.
    # After the rotation, the effective x-coordinate is:
    x_arm = math.cos(q1) * p_x + math.sin(q1) * p_y

    # Define effective link lengths.
    L1 = 0.425
    L2 = 0.39225 + 0.09465  # equals 0.4869

    # Compute effective distance in the arm (sagittal) plane.
    r_eff = math.sqrt(x_arm**2 + p_z**2)

    # Solve for elbow joint (q3) using the law of cosines.
    cos_q3 = (r_eff**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp to avoid numerical errors.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Solve for shoulder joint (q2) using the law of sines/cosines.
    q2 = math.atan2(x_arm, p_z) - math.atan2(L2 * math.sin(q3), L1 + L2 * math.cos(q3))

    # Wrist joints (redundant for position) are set to zero.
    q4 = 0.0
    q5 = 0.0

    return (q1, q2, q3, q4, q5)