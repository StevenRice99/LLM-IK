def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # Robot geometry constants.
    L_a      = 0.425    # Effective link length from revolute 2 to revolute 3.
    offset_y = 0.01615  # Lateral offset computed as 0.13585 - 0.1197.
    d_y      = 0.093    # Constant translation in y (from revolute 5).
    d_z      = 0.39225  # Constant translation in z (from revolute 4).
    L_d      = 0.09465  # TCP offset along wrist direction.

    # Step 1: Solve for the wrist joint angle θ₄.
    # The TCP position is given by:
    #    TCP = p₃ + [L_d*sin(θ₄), d_y, d_z + L_d*cos(θ₄)]
    # where p₃ = [L_a*sin(θ₂)*cos(θ₁) - offset_y*sin(θ₁),
    #             L_a*sin(θ₂)*sin(θ₁) + offset_y*cos(θ₁),
    #             L_a*cos(θ₂)]
    #
    # Subtracting the wrist offset, define the virtual target for p₃:
    #    p₁ = [x - L_d*sin(θ₄), y - d_y, z - d_z - L_d*cos(θ₄)].
    # Since p₃ must satisfy ||p₃||² = L_a² + offset_y², we require:
    #    [x - L_d*sin(θ₄)]² + [y - d_y]² + [z - d_z - L_d*cos(θ₄)]² = L_a² + offset_y².
    #
    # Through algebra, one can show this condition leads to:
    #    x*sin(θ₄) + (z - d_z)*cos(θ₄) = K,
    # where K is:
    K = ((x**2 + (y - d_y)**2 + (z - d_z)**2 + L_d**2) - (L_a**2 + offset_y**2)) / (2 * L_d)
    
    # Write the left-hand side in cosine form.
    R_val = math.sqrt(x**2 + (z - d_z)**2)
    phi   = math.atan2(x, (z - d_z))
    # Solve the cosine equation: cos(θ₄ - φ) = K/R_val.
    theta4 = phi + math.acos(K / R_val)  # (choosing one branch)

    # Step 2: Compute the virtual target p₁ for the p₃ sub-chain.
    x1 = x - L_d * math.sin(theta4)
    y1 = y - d_y
    z1 = z - d_z - L_d * math.cos(theta4)

    # Step 3: Solve for θ₂ using the z–component of p₁.
    # From p₃ we have z1 = L_a*cos(θ₂)  =>  θ₂ = acos(z1 / L_a)
    theta2 = math.acos(z1 / L_a)

    # Step 4: Solve for θ₁ using the x– and y–components of p₁.
    # p₁’s x– and y– components satisfy:
    #    x1 = L_a*sin(θ₂)*cos(θ₁) - offset_y*sin(θ₁)
    #    y1 = L_a*sin(θ₂)*sin(θ₁) + offset_y*cos(θ₁)
    # Let A = L_a*sin(θ₂) and B = offset_y.
    A = L_a * math.sin(theta2)
    B = offset_y
    # Rearranging yields:
    denom = A**2 + B**2
    C = (A * x1 + B * y1) / denom
    S = (-B * x1 + A * y1) / denom
    theta1 = math.atan2(S, C)

    # Step 5: Set the redundant joints (θ₃ and θ₅) to zero.
    theta3 = 0.0
    theta5 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)