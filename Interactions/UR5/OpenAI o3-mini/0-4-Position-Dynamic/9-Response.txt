def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes joint angles (θ₁, θ₂, θ₃, θ₄, θ₅) in radians that yield a desired TCP position p,
    using a closed-form analytical inverse kinematics solution based on the following relations:
    
      p₃ = [0.425*sin(θ₂)*cos(θ₁) - 0.01615*sin(θ₁),
            0.425*sin(θ₂)*sin(θ₁) + 0.01615*cos(θ₁),
            0.425*cos(θ₂)]
    
      TCP = p₃ + [0.09465*sin(θ₄), 0.093, 0.39225 + 0.09465*cos(θ₄)]
    
    Since the arm has 5 DOF but only 3 are needed to fix position, we set the redundant joints as:
      θ₃ = 0,   θ₅ = 0

    The solution strategy consists of:
      1. "Subtracting" the wrist offset [0.09465*sin(θ₄), 0.093, 0.39225+0.09465*cos(θ₄)] from the
         desired TCP position to compute a virtual target p₁ for p₃.
      2. Enforcing ||p₃||² = 0.425² + 0.01615² yields an equation in θ₄ which can be written as:
             x*sin(θ₄) + (z - 0.39225)*cos(θ₄) = K,
         where K is computed from the known lengths.
      3. With θ₄ determined (choosing one branch of the acos), subtract the wrist offset to obtain p₁.
      4. From the z–component of p₁ determine θ₂ via:  θ₂ = acos(z₁ / 0.425)
      5. The x– and y–components of p₁ then yield θ₁.
    
    :param p: Desired TCP position as a tuple (x, y, z).
    :return: A tuple of joint angles (θ₁, θ₂, θ₃, θ₄, θ₅) in radians.
    """
    import math

    # Unpack target TCP position.
    x, y, z = p

    # Robot constants per URDF.
    L_a      = 0.425      # effective length related to joints 2-3.
    offset_y = 0.01615    # lateral offset (computed as 0.13585 - 0.1197).
    d_y      = 0.093      # constant y-translation from revolute 5.
    d_z      = 0.39225    # constant z-translation from revolute 4.
    L_d      = 0.09465    # TCP offset along wrist direction.

    # Step 1: Solve for the wrist joint angle θ₄.
    # The TCP is given by TCP = p₃ + [L_d*sin(θ₄), d_y, d_z + L_d*cos(θ₄)].
    # "Subtract" the wrist offset from p=(x,y,z) to yield:
    #   p₁ = [x - L_d*sin(θ₄),  y - d_y,  z - d_z - L_d*cos(θ₄)]
    # Since ||p₃||² = L_a² + offset_y² must hold, we have:
    #   [x - L_d*sin(θ₄)]² + [y - d_y]² + [z - d_z - L_d*cos(θ₄)]² = L_a² + offset_y².
    # Through algebraic manipulation this reduces to:
    #   x*sin(θ₄) + (z - d_z)*cos(θ₄) = K,
    # where:
    K = ((x**2 + (y - d_y)**2 + (z - d_z)**2 + L_d**2) - (L_a**2 + offset_y**2)) / (2 * L_d)

    # Define R and φ to convert the left-hand side to a cosine form.
    R_val = math.sqrt(x**2 + (z - d_z)**2)
    phi   = math.atan2(x, (z - d_z))
    # Now, write the equation as R_val * cos(θ₄ - φ) = K.
    # Solving for θ₄ gives:
    ratio = K / R_val  # (Assuming reachable target so that |ratio| <= 1.)
    theta4 = phi + math.acos(ratio)  # choosing the “+” branch

    # Step 2: Compute the virtual target p₁ for p₃.
    x1 = x - L_d * math.sin(theta4)
    y1 = y - d_y
    z1 = z - d_z - L_d * math.cos(theta4)

    # Step 3: Solve for θ₂ from the z–component of p₁.
    # We have: z1 = L_a*cos(θ₂)   -->   θ₂ = acos(z1 / L_a)
    theta2 = math.acos(z1 / L_a)

    # Step 4: Solve for θ₁ from the x– and y–components.
    # From the definition:
    #   x1 = L_a*sin(θ₂)*cos(θ₁) - offset_y*sin(θ₁)
    #   y1 = L_a*sin(θ₂)*sin(θ₁) + offset_y*cos(θ₁)
    # Let A = L_a*sin(θ₂) and B = offset_y.
    A = L_a * math.sin(theta2)
    B = offset_y
    # The equations can be rearranged to:
    #   cos(θ₁) = (A*x1 + B*y1) / (A² + B²)     and
    #   sin(θ₁) = (-B*x1 + A*y1) / (A² + B²).
    denom = A**2 + B**2  # Guaranteed to be > 0 for non-degenerate cases.
    C = (A * x1 + B * y1) / denom
    S = (-B * x1 + A * y1) / denom
    theta1 = math.atan2(S, C)

    # Step 5: Set the redundant joints.
    theta3 = 0.0  # Redundant joint in the p₃ sub-chain.
    theta5 = 0.0  # Wrist rotation does not affect the TCP position.

    return (theta1, theta2, theta3, theta4, theta5)