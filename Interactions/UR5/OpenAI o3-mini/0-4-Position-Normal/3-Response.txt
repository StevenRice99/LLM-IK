def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes a closed‐form inverse kinematics solution for the 5 DOF robot
    given a desired TCP position p = (x, y, z). The solution fixes the extra 
    two degrees of freedom by choosing q4 = q5 = 0.

    The robot parameters come from the URDF table:
       - Revolute 1: origin [0, 0, 0]
       - Revolute 2: origin [0, 0.13585, 0]
       - Revolute 3: origin [0, -0.1197, 0.425]
       - Revolute 4: origin [0, 0, 0.39225]
       - Revolute 5: origin [0, 0.093, 0]
       - TCP: origin [0, 0, 0.09465]

    In the zero joint configuration (all angles zero) the TCP is at:
       (0, offset2 + offset3 + offset5, offset3_z + offset4_z + tcp_z)
       which numerically is (0, 0.13585 - 0.1197 + 0.093, 0.425 + 0.39225 + 0.09465)
       i.e., (0, 0.10915, 0.9119).

    The solution decouples the inverse position problem by:
       1. Computing the base joint (q1) so that the (x,y) target is aligned with the
          zero-configuration offset in y (0.10915). This is done by “unwinding” the 
          (x,y) components.
       2. Transforming the remaining problem into a planar 2R chain (joints q2 and q3)
          with link lengths:
              d = offset3_z = 0.425
              L = offset4_z + tcp_z = 0.39225 + 0.09465 = 0.4869 
          and using the law of cosines and associated geometry.
       3. Setting the redundant joints q4 and q5 to zero.
    
    :param p: The desired TCP position as a tuple (x, y, z).
    :return: A tuple (q1, q2, q3, q4, q5) representing joint angles in radians.
    """
    import math

    # Unpack target position.
    x, y, z = p

    # Robot kinematics parameters (from the table)
    offset2   = 0.13585    # Translation from Revolute 1 to Revolute 2 (along y)
    offset3   = -0.1197    # Translation from Revolute 2 to Revolute 3 (along y)
    offset3_z = 0.425      # Translation from Revolute 2 to Revolute 3 (along z)
    offset4_z = 0.39225    # Translation from Revolute 3 to Revolute 4 (along z)
    offset5   = 0.093      # Translation from Revolute 4 to Revolute 5 (along y)
    tcp_z     = 0.09465    # Translation from Revolute 5 to TCP (along z)

    # In the zero configuration, TCP is at:
    #   (0, offset2 + offset3 + offset5, offset3_z + offset4_z + tcp_z)
    base_y_offset = offset2 + offset3 + offset5  # 0.13585 - 0.1197 + 0.093 = 0.10915

    # Step 1. Compute the effective radial distance in the (x,y) plane.
    R_eff = math.sqrt(x * x + y * y)

    # Compute the effective x-component after “undoing” the base offset.
    # We require: (x_d)^2 + (base_y_offset)^2 = R_eff^2, hence x_d = sqrt(R_eff^2 - base_y_offset^2)
    temp = max(R_eff * R_eff - base_y_offset * base_y_offset, 0.0)
    x_d = math.sqrt(temp)

    # Step 2. Compute the base joint angle q1.
    # The (x,y) target as seen in the zero configuration frame would be (x_d, base_y_offset),
    # so we rotate the vector (x_d, base_y_offset) by q1 to align with (x, y).
    q1 = math.atan2(y, x) - math.atan2(base_y_offset, math.sqrt(temp))

    # Step 3. Compute the target distance for the planar (q2, q3) sub-problem.
    # After "unwinding" q1, the effective 2D position becomes (x_d, z).
    D_target = math.sqrt(x_d * x_d + z * z)

    # Step 4. Solve for q3 (elbow joint) using the law of cosines in the planar 2R chain.
    # Define d and L for the two links of the 2R chain:
    d = offset3_z           # 0.425 (link from Revolute 2's offset in z)
    L = offset4_z + tcp_z     # 0.39225 + 0.09465 ≈ 0.4869 (combined effective length)
    
    # Law of cosines gives:
    #   cos(q3) = (D_target^2 - (d^2 + L^2)) / (2*d*L)
    cos_q3 = (D_target * D_target - (d * d + L * L)) / (2 * d * L)
    # Clamp cos_q3 to be within [-1, 1] for numerical safety.
    cos_q3 = max(-1.0, min(1.0, cos_q3))
    q3 = math.acos(cos_q3)

    # Step 5. Solve for q2 (shoulder joint) using an intermediate angle φ.
    # Define φ such that:
    #   φ = atan2(L*sin(q3), d + L*cos(q3))
    phi = math.atan2(L * math.sin(q3), d + L * math.cos(q3))
    # In the planar 2R chain, one has:
    #   tan(q2 + φ) = x_d / z  =>  q2 = atan2(x_d, z) - φ
    q2 = math.atan2(x_d, z) - phi

    # Step 6. Since the manipulator is redundant for positioning, fix the remaining joints:
    q4 = 0.0
    q5 = 0.0

    return (q1, q2, q3, q4, q5)