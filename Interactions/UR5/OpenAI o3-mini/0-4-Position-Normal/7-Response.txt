def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes a closed‐form inverse kinematics solution for the 5 DOF manipulator,
    given a desired TCP position p = (x, y, z). This solution positions the tool by
    solving for the first three joints and fixes the redundant joints (q4, q5) to zero.
    
    The robot parameters (all lengths in meters) come from the URDF:
      • Revolute 1: origin [0, 0, 0]            (axis Z)
      • Revolute 2: origin [0, 0.13585, 0]       (axis Y)
      • Revolute 3: origin [0, -0.1197, 0.425]    (axis Y)
      • Revolute 4: origin [0, 0, 0.39225]        (axis Y)
      • Revolute 5: origin [0, 0.093, 0]          (axis Z)
      • TCP:      origin [0, 0, 0.09465]
      
    In the zero joint configuration (all angles zero) the TCP is at:
         (0,
          offset2 + offset3 + offset5,
          offset3_z + offset4_z + tcp_z)
       where:
         offset2   =  0.13585
         offset3   = -0.1197 
         offset3_z =  0.425
         offset4_z =  0.39225
         offset5   =  0.093
         tcp_z     =  0.09465
       so the TCP is at (0, 0.10915, 0.9119).
       
    The inverse kinematics is computed as follows:
      1. Determine the base rotation (q1) so that the desired (x,y) aligns with the
         fixed TCP offset in y (0.10915). In the base plane, let R = sqrt(x^2+y^2).
         Then, the effective x-component in the zero configuration (before rotation)
         is x_d = sqrt(R^2 - (0.10915)^2); the fixed y-component is 0.10915.
         Hence, q1 = atan2(y, x) - atan2(0.10915, x_d).
         
      2. With q1 “undone,” the manipulator’s planar subproblem (in the x-z plane)
         has effective coordinates (x_d, z). The two links of the arm are:
             d = offset3_z = 0.425  and 
             L = offset4_z + tcp_z = 0.39225 + 0.09465 = 0.4869.
         In zero configuration, (x_d, z) would be (0, d+L) = (0, 0.9119).
         For a desired planar distance D_target = sqrt(x_d² + z²), the law of cosines gives
             cos(q3) = (D_target² - d² - L²) / (2*d*L).
         We then recover the elbow angle q3 via acos, and define an intermediate angle:
             phi = atan2(L*sin(q3), d + L*cos(q3)).
         The shoulder angle is q2 = atan2(x_d, z) - phi.
         
      3. Finally, we set the redundant joints as q4 = 0 and q5 = 0.
      
    :param p: The desired TCP position as a tuple (x, y, z).
    :return: A tuple (q1, q2, q3, q4, q5) representing joint angles in radians.
    """
    import math

    # Unpack target TCP position.
    x, y, z = p

    # Robot parameters (from the table above).
    offset2   = 0.13585    # Translation along y from Revolute 1 to 2.
    offset3   = -0.1197    # Translation along y from Revolute 2 to 3.
    offset3_z = 0.425      # Translation along z from Revolute 2 to 3.
    offset4_z = 0.39225    # Translation along z from Revolute 3 to 4.
    offset5   = 0.093      # Translation along y from Revolute 4 to 5.
    tcp_z     = 0.09465    # Translation along z from Revolute 5 to TCP.

    # In the zero configuration, the TCP y-offset is:
    base_y_offset = offset2 + offset3 + offset5   # 0.13585 - 0.1197 + 0.093 = 0.10915

    # Step 1: Compute the base joint angle q1.
    # In the base plane the target has radius R.
    R = math.sqrt(x*x + y*y)
    # The zero configuration gives a fixed y-offset; thus, the effective x component in that
    # frame is:
    temp = max(R*R - base_y_offset*base_y_offset, 0.0)
    x_d = math.sqrt(temp)
    # To align the zero-config vector (x_d, base_y_offset) with (x, y), use:
    q1 = math.atan2(y, x) - math.atan2(base_y_offset, x_d)

    # Step 2: Solve the planar 2R problem for q2 and q3.
    # After “undoing” q1, the effective planar coordinates become (x_d, z).
    D_target = math.sqrt(x_d*x_d + z*z)
    # The two link lengths for the planar subproblem:
    d = offset3_z            # 0.425
    L = offset4_z + tcp_z      # 0.39225 + 0.09465 = 0.4869

    # Solve for q3 using the law of cosines:
    cos_q3 = (D_target*D_target - d*d - L*L) / (2*d*L)
    # Clamp cos_q3 to the interval [-1, 1] for numerical safety.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Compute an intermediate angle phi.
    phi = math.atan2(L * math.sin(q3), d + L * math.cos(q3))
    # Then solve for q2.
    q2 = math.atan2(x_d, z) - phi

    # Step 3: Set the remaining redundant joint angles.
    q4 = 0.0
    q5 = 0.0

    return (q1, q2, q3, q4, q5)