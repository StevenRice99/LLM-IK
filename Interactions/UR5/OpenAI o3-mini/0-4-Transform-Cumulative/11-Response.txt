def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the closed-form analytical inverse kinematics for a 5-DOF serial manipulator.
    The robot’s structure is as follows:
      • Joint 1: Revolute about Z at [0,0,0].
      • Joint 2: Revolute about Y, translated by [0, 0.13585, 0] from joint 1.
      • Joint 3: Revolute about Y, translated by [0, -0.1197, 0.425] from joint 2.
      • Joint 4: Revolute about Y, translated by [0, 0, 0.39225] from joint 3.
      • Joint 5: Revolute about Z, translated by [0, 0.093, 0] from joint 4.
      • TCP: Translated by [0, 0, 0.09465] from joint 5.
      
    The specified TCP orientation r = (roll, pitch, yaw) is used in the Rz*Ry*Rx convention.
    The solution decouples the position and orientation by first removing the effect of the
    end–effector offset.
    
    Steps:
      1. Compute the target rotation matrix R_target from the roll, pitch, yaw angles.
      2. Compute the wrist center position by subtracting the rotated tool offset (from joint 5)
         from the TCP target position.
      3. Solve for joint 1 (theta1) as the direction from the base to the wrist center.
      4. Compute the world position of joint 2 and form the vector from joint 2 to the wrist center.
         Because joints 2 and 3 both rotate about Y, only the effective X and Z components are used.
      5. Solve the planar 2R inverse kinematics (with link lengths L1 and L2) to obtain theta2 and theta3.
      6. Remove the base rotation to extract the combined wrist rotation angle beta. Then compute
         joint 4 (theta4) so that theta2+theta3+theta4 = beta.
      7. Finally, extract joint 5 (theta5) from the remaining rotation.
    
    :param p: TCP target position as (x, y, z).
    :param r: TCP target orientation as (roll, pitch, yaw) in radians.
    :return: Tuple (theta1, theta2, theta3, theta4, theta5) of joint angles in radians.
    """
    import math
    import numpy as np

    # Step 1. Compute the target rotation matrix using the convention: R_target = R_z(yaw) * R_y(pitch) * R_x(roll)
    x_target, y_target, z_target = p
    roll, pitch, yaw = r
    R_x = np.array([[1, 0, 0],
                    [0, math.cos(roll), -math.sin(roll)],
                    [0, math.sin(roll), math.cos(roll)]])
    R_y = np.array([[math.cos(pitch), 0, math.sin(pitch)],
                    [0, 1, 0],
                    [-math.sin(pitch), 0, math.cos(pitch)]])
    R_z = np.array([[math.cos(yaw), -math.sin(yaw), 0],
                    [math.sin(yaw), math.cos(yaw), 0],
                    [0, 0, 1]])
    R_target = R_z @ R_y @ R_x

    # Step 2. Compute the wrist center position.
    # The tool offset (from joint 5 to TCP) is the sum of:
    #   - Joint 5’s translation: [0, 0.093, 0]
    #   - TCP’s translation: [0, 0, 0.09465]
    p_tool = np.array([0, 0.093, 0.09465])
    p_target_vec = np.array([x_target, y_target, z_target])
    # Removing the tool offset (rotated by the target orientation) yields the wrist center.
    p_wrist = p_target_vec - (R_target @ p_tool)

    # Step 3. Solve for Joint 1 (rotation about Z).
    # Define theta1 so that when the wrist center lies along the positive Y-axis, theta1 is zero.
    theta1 = math.atan2(p_wrist[0], p_wrist[1])

    # Step 4. Compute joint 2’s world position.
    # Joint 2’s location in the base frame is [0, 0.13585, 0], which rotates with theta1.
    p_joint2 = np.array([0, 0.13585, 0])
    Rz_theta1 = np.array([[math.cos(theta1), -math.sin(theta1), 0],
                          [math.sin(theta1),  math.cos(theta1), 0],
                          [0, 0, 1]])
    p_joint2_world = Rz_theta1 @ p_joint2

    # Form the vector from joint 2 to the wrist center.
    p_rel = p_wrist - p_joint2_world
    # Since joints 2 and 3 rotate about Y, consider only X and Z:
    x_eff = p_rel[0]
    z_eff = p_rel[2]
    r_plane = math.sqrt(x_eff**2 + z_eff**2)

    # Step 5. Solve the planar 2R problem for joints 2 and 3.
    # Effective link lengths:
    L1 = 0.425    # from joint 2 to joint 3
    L2 = 0.39225  # from joint 3 to the wrist center
    cos_theta3 = (r_plane**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp to account for numerical issues.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)
    # Auxiliary angle for the geometry.
    psi = math.atan2(L2 * math.sin(theta3), L1 + L2 * math.cos(theta3))
    gamma = math.atan2(x_eff, z_eff)
    theta2 = gamma - psi

    # Step 6. Solve for joint 4 using the required wrist orientation.
    # Remove the effect of joint 1 from the target rotation.
    Rz_neg_theta1 = np.array([[math.cos(-theta1), -math.sin(-theta1), 0],
                              [math.sin(-theta1),  math.cos(-theta1), 0],
                              [0, 0, 1]])
    R_rem = Rz_neg_theta1 @ R_target
    # In the structure R_rem = R_y(beta) * R_z(theta5), the elements (0,2) and (2,2) yield beta.
    beta = math.atan2(R_rem[0, 2], R_rem[2, 2])
    # Since beta = theta2 + theta3 + theta4, solve for theta4.
    theta4 = beta - (theta2 + theta3)

    # Step 7. Solve for joint 5 (rotation about Z).
    # In the factorization R_rem = R_y(beta) * R_z(theta5), the second row remains invariant under R_y.
    theta5 = math.atan2(R_rem[1, 0], R_rem[1, 1])
    
    return (theta1, theta2, theta3, theta4, theta5)