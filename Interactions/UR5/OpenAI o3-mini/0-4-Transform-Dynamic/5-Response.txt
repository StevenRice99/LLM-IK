def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Gets the joint values [q1, q2, q3, q4, q5] needed to reach the desired TCP
    position p (x, y, z) and orientation r (roll, pitch, yaw in radians).
    
    The robot has 5 revolute joints with the following properties:
      • Revolute 1: frame origin [0, 0, 0], rotation about Z.
      • Revolute 2: frame offset [0, 0.13585, 0] relative to link1, rotation about Y.
      • Revolute 3: link length a = 0.425 (from joint2), rotation about Y.
      • Revolute 4: link length b = 0.39225 (from joint3), rotation about Y.
      • Revolute 5: wrist rotation about Z.
      
    A constant TCP offset along the final frame's Z (0.09465) is assumed.
    
    The closed‐form solution decouples the chain by (1) solving for the base rotation,
    (2) transforming the target into the shoulder (joint2) frame, (3) computing the
    “planar” target (after subtracting the TCP offset) and solving a 2‐link IK for q2 and q3,
    (4) setting q4 so that the arm’s “planar” angle sums correctly, and (5) decoupling the wrist
    to obtain q5.
    
    :param p: The target TCP position, a tuple (x, y, z).
    :param r: The target TCP orientation (roll, pitch, yaw in radians).
    :return: A tuple of joint angles (q1, q2, q3, q4, q5) in radians.
    """
    import math
    import numpy as np

    # -----------------------------------------------------------
    # 1. Solve for joint 1 (base rotation about Z).
    # According to our convention, we compute q1 such that:
    #   q1 = atan2( -x , y )
    # ensuring the proper alignment.
    x, y, z = p
    q1 = math.atan2(-x, y)

    # -----------------------------------------------------------
    # 2. Bring the target (position and orientation) into joint 2’s frame.
    # Revolute 2 is offset from joint1 by [0, 0.13585, 0].
    # Form the rotation matrix about Z for q1.
    Rz_q1 = np.array([[math.cos(q1), -math.sin(q1), 0],
                      [math.sin(q1),  math.cos(q1), 0],
                      [0,           0,            1]])
    # Inverse rotation to “undo” q1:
    Rz_neg_q1 = Rz_q1.T

    # Compute joint2 global position:
    joint2_offset = np.array([0, 0.13585, 0])
    p_joint2 = Rz_q1 @ joint2_offset

    # Express TCP position relative to joint2:
    p_eff = np.array(p) - p_joint2
    # Now express this in joint2’s coordinate frame (by removing q1 rotation):
    p_sub = Rz_neg_q1 @ p_eff
    # p_sub components: x_eff, y_eff, z_eff. The subsequent IK in the arm "plane"
    # will use the x (lateral) and z (vertical) coordinates.
    x_eff, _, z_eff = p_sub

    # Compute the target rotation matrix from roll, pitch, yaw.
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    R_x = np.array([[1, 0, 0],
                    [0, cr, -sr],
                    [0, sr,  cr]])
    R_y = np.array([[cp, 0, sp],
                    [0,  1, 0],
                    [-sp, 0, cp]])
    R_z = np.array([[cy, -sy, 0],
                    [sy,  cy, 0],
                    [0,    0, 1]])
    R_target_global = R_z @ R_y @ R_x
    # Express the target orientation in joint2’s frame:
    R_target = Rz_neg_q1 @ R_target_global

    # -----------------------------------------------------------
    # 3. Decouple the arm’s planar motion.
    # The effective planar orientation of the arm (from joints 2-4) can be extracted from R_target.
    # Here we define theta_sum so that:
    #   theta_sum = atan2( R_target[0, 2], R_target[2, 2] )
    # by convention the “arm” points along +z with positive rotation toward +x.
    theta_sum = math.atan2(R_target[0, 2], R_target[2, 2])
    
    # The TCP has a fixed offset along its final local z-axis (C_tcp = 0.09465).
    # Subtract that offset (projected onto the arm’s direction) to locate the wrist center.
    C_tcp = 0.09465
    pos_x = x_eff - C_tcp * math.sin(theta_sum)
    pos_z = z_eff - C_tcp * math.cos(theta_sum)

    # -----------------------------------------------------------
    # 4. Solve the 2-link planar IK for joints 2 and 3.
    # The link lengths (from joint2) are:
    a = 0.425    # from joint 2 to joint 3
    b = 0.39225  # from joint 3 to joint 4
    d_sq = pos_x**2 + pos_z**2

    # Use the cosine law to solve for q3:
    cos_q3 = (d_sq - a**2 - b**2) / (2 * a * b)
    # Clamp for numerical robustness:
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3_candidate1 = math.acos(cos_q3)
    q3_candidate2 = -q3_candidate1

    q2_sol = None
    q3_sol = None
    # Try both candidates for q3.
    for q3_cand in [q3_candidate1, q3_candidate2]:
        # Compute q2 based on the geometry:
        denom = a + b * math.cos(q3_cand)
        num = b * math.sin(q3_cand)
        q2_candidate = math.atan2(pos_x, pos_z) - math.atan2(num, denom)
        # Verify the solution by forward computing the wrist center position.
        x_calc = a * math.sin(q2_candidate) + b * math.sin(q2_candidate + q3_cand)
        z_calc = a * math.cos(q2_candidate) + b * math.cos(q2_candidate + q3_cand)
        if math.isclose(x_calc, pos_x, abs_tol=1e-5) and math.isclose(z_calc, pos_z, abs_tol=1e-5):
            q2_sol = q2_candidate
            q3_sol = q3_cand
            break

    if q2_sol is None:
        # Fallback (should not occur for reachable targets):
        q2_sol = 0.0
        q3_sol = 0.0

    # Joint 4 (rotation about Y) is chosen so that the sum of the arm rotations equals theta_sum.
    q4 = theta_sum - q2_sol - q3_sol

    # -----------------------------------------------------------
    # 5. Solve for joint 5 (wrist rotation about Z).
    # Remove the effect of the arm’s rotation.
    R_y_sum = np.array([[math.cos(theta_sum),  0, math.sin(theta_sum)],
                        [0,                    1, 0],
                        [-math.sin(theta_sum), 0, math.cos(theta_sum)]])
    # The remaining rotation is isolated by:
    R_remaining = R_y_sum.T @ R_target
    # Joint 5 is given by the rotation about Z to match R_remaining:
    q5 = math.atan2(R_remaining[1, 0], R_remaining[0, 0])
    
    return (q1, q2_sol, q3_sol, q4, q5)