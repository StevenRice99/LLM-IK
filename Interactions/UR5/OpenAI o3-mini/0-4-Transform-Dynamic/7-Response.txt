def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Gets the joint values [q1, q2, q3, q4, q5] needed to reach the desired TCP
    position p (x, y, z) and orientation r (roll, pitch, yaw in radians).

    The robot has 5 revolute joints with the following structure:
      • Joint 1: Origin [0, 0, 0], rotates about Z.
      • Joint 2: Offset [0, 0.13585, 0] from joint 1, rotates about Y.
      • Joint 3: Offset [0, 0.01615, 0.425] from joint 2, effective link length a=0.425, rotates about Y.
      • Joint 4: Offset [0, 0, 0.39225] from joint 3, effective link length b=0.39225, rotates about Y.
      • Joint 5: Offset [0, 0.093, 0] from joint 4, rotates about Z.
    The TCP is offset by [0, 0, 0.09465] in the final link’s frame.

    The inverse kinematics decouples the problem into:
      1. Solving for the base angle (q1) from the global TCP position.
      2. Transforming the target position and orientation into joint 2’s frame.
      3. Removing the TCP offset (along the final z-axis) to compute the wrist center.
      4. Using a 2‐link planar inverse kinematics (with link lengths a and b) to obtain q2 and q3.
      5. Setting q4 so that the cumulative arm “planar” rotation equals the target planar angle.
      6. Decoupling the wrist to compute q5.

    :param p: The target TCP position (x, y, z).
    :param r: The target TCP orientation (roll, pitch, yaw) in radians.
    :return: A tuple (q1, q2, q3, q4, q5) of joint values in radians.
    """
    import math
    import numpy as np

    # 1. Solve for Joint 1 (base rotation about Z)
    x, y, z = p
    q1 = math.atan2(-x, y)

    # 2. Transform the target TCP into Joint 2's frame.
    # Joint 2 is offset from the base by [0, 0.13585, 0].
    joint2_offset = np.array([0, 0.13585, 0])
    # Rotation matrix about Z for the base rotation (q1)
    Rz_q1 = np.array([[math.cos(q1), -math.sin(q1), 0],
                      [math.sin(q1),  math.cos(q1), 0],
                      [0,             0,            1]])
    # Global position of joint 2
    p_joint2 = Rz_q1 @ joint2_offset
    # Compute the TCP position relative to joint 2
    p_eff = np.array(p) - p_joint2
    # Express this difference in joint 2's coordinate frame (by undoing q1)
    p_sub = Rz_q1.T @ p_eff
    # For the planar IK, we use the x (lateral) and z (vertical) components.
    x_eff = p_sub[0]
    z_eff = p_sub[2]

    # 3. Compute the target orientation in joint 2's frame.
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    R_x = np.array([[1, 0, 0],
                    [0, cr, -sr],
                    [0, sr,  cr]])
    R_y = np.array([[cp, 0, sp],
                    [0,  1,  0],
                    [-sp, 0, cp]])
    R_z = np.array([[cy, -sy, 0],
                    [sy,  cy, 0],
                    [0,   0, 1]])
    R_target_global = R_z @ R_y @ R_x
    # Express the target orientation in joint 2's frame.
    R_target = Rz_q1.T @ R_target_global

    # Extract the effective arm (planar) rotation angle.
    # By convention, the arm points along +z with rotation measured as:
    theta_sum = math.atan2(R_target[0, 2], R_target[2, 2])

    # 4. Remove the TCP offset.
    # TCP offset is along the final frame's z-axis: C_tcp = 0.09465.
    C_tcp = 0.09465
    pos_x = x_eff - C_tcp * math.sin(theta_sum)
    pos_z = z_eff - C_tcp * math.cos(theta_sum)

    # 5. Solve the 2-link planar IK for joints 2 and 3.
    a = 0.425    # effective link length from joint 2 to joint 3.
    b = 0.39225  # effective link length from joint 3 to joint 4.
    d_sq = pos_x**2 + pos_z**2
    cos_q3 = (d_sq - a**2 - b**2) / (2 * a * b)
    # Clamp cos_q3 to account for numerical errors.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3_candidate1 = math.acos(cos_q3)
    q3_candidate2 = -q3_candidate1

    q2_sol = None
    q3_sol = None
    for q3_cand in [q3_candidate1, q3_candidate2]:
        denom = a + b * math.cos(q3_cand)
        num = b * math.sin(q3_cand)
        q2_candidate = math.atan2(pos_x, pos_z) - math.atan2(num, denom)
        # Forward compute the expected position for verification.
        x_calc = a * math.sin(q2_candidate) + b * math.sin(q2_candidate + q3_cand)
        z_calc = a * math.cos(q2_candidate) + b * math.cos(q2_candidate + q3_cand)
        if math.isclose(x_calc, pos_x, abs_tol=1e-5) and math.isclose(z_calc, pos_z, abs_tol=1e-5):
            q2_sol = q2_candidate
            q3_sol = q3_cand
            break
    if q2_sol is None:
        # Fallback (should not occur for reachable targets)
        q2_sol = 0.0
        q3_sol = 0.0

    # Joint 4 is chosen so that the sum of joints 2, 3, and 4 equals theta_sum.
    q4 = theta_sum - q2_sol - q3_sol

    # 6. Solve for Joint 5 (wrist rotation about Z).
    # Remove the contribution of the arm's (joints 2-4) rotation.
    R_y_sum = np.array([[math.cos(theta_sum),  0, math.sin(theta_sum)],
                        [0,                    1, 0],
                        [-math.sin(theta_sum), 0, math.cos(theta_sum)]])
    R_remaining = R_y_sum.T @ R_target
    q5 = math.atan2(R_remaining[1, 0], R_remaining[0, 0])

    return (q1, q2_sol, q3_sol, q4, q5)