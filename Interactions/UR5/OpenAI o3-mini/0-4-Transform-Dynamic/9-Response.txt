def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math
    import numpy as np

    # 1. Compute joint 1 angle (rotation about Z) from the global TCP position.
    x, y, z = p
    q1 = math.atan2(-x, y)

    # 2. Transform the TCP position into joint 2's coordinate frame.
    #    Joint 2 is offset from the base by [0, 0.13585, 0].
    Rz = np.array([[math.cos(q1), -math.sin(q1), 0],
                   [math.sin(q1),  math.cos(q1), 0],
                   [0,             0,            1]])
    joint2_offset = np.array([0, 0.13585, 0])
    p_joint2 = Rz @ joint2_offset
    # p_eff is the effective TCP position relative to the base-origin of joint 2.
    p_eff = np.array(p) - p_joint2
    # Remove the base rotation to express p_eff in joint 2's local frame.
    p_sub = Rz.T @ p_eff
    # For the planar arm IK, we use the x (lateral) and z (vertical) components.
    x_eff = p_sub[0]
    z_eff = p_sub[2]

    # 3. Compute the target orientation in joint 2's frame.
    roll, pitch, yaw = r
    R_x = np.array([[1, 0, 0],
                    [0, math.cos(roll), -math.sin(roll)],
                    [0, math.sin(roll),  math.cos(roll)]])
    R_y = np.array([[math.cos(pitch), 0, math.sin(pitch)],
                    [0, 1, 0],
                    [-math.sin(pitch), 0, math.cos(pitch)]])
    R_z_target = np.array([[math.cos(yaw), -math.sin(yaw), 0],
                           [math.sin(yaw),  math.cos(yaw), 0],
                           [0, 0, 1]])
    R_target_global = R_z_target @ R_y @ R_x
    # Express the target rotation in joint 2's frame.
    R_target = Rz.T @ R_target_global

    # 4. Extract the effective planar rotation angle (theta_sum) from the target.
    # By convention, the arm is oriented such that zero points along +z,
    # so theta_sum is measured as the angle between the projection of the TCP’s z-axis
    # and the vertical z-axis.
    theta_sum = math.atan2(R_target[0, 2], R_target[2, 2])

    # 5. Remove the TCP offset along the final local z-axis.
    # The TCP offset is C_tcp = 0.09465.
    C_tcp = 0.09465
    pos_x = x_eff - C_tcp * math.sin(theta_sum)
    pos_z = z_eff - C_tcp * math.cos(theta_sum)

    # 6. Solve the 2-link planar inverse kinematics for joints 2 and 3.
    # Use effective link lengths a and b:
    a = 0.425    # Length from joint 2 to joint 3
    b = 0.39225  # Length from joint 3 to joint 4
    d_sq = pos_x**2 + pos_z**2
    cos_q3 = (d_sq - a**2 - b**2) / (2 * a * b)
    # Clamp the cosine value to avoid numerical issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)
    # Compute q2 using the 2-link geometry.
    q2 = math.atan2(pos_x, pos_z) - math.atan2(b * math.sin(q3), a + b * math.cos(q3))

    # 7. The joint 4 angle is set so that the total arm rotation equals theta_sum.
    q4 = theta_sum - q2 - q3

    # 8. Finally, decouple the wrist to solve for joint 5 (rotation about Z).
    # Remove the effect of the arm’s planar rotation.
    R_y_sum = np.array([[math.cos(theta_sum), 0, math.sin(theta_sum)],
                        [0, 1, 0],
                        [-math.sin(theta_sum), 0, math.cos(theta_sum)]])
    R_remaining = R_y_sum.T @ R_target
    q5 = math.atan2(R_remaining[1, 0], R_remaining[0, 0])

    return (q1, q2, q3, q4, q5)