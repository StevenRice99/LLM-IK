def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import numpy as np

    # Unpack the target TCP position and orientation (roll, pitch, yaw)
    p_x, p_y, p_z = p
    roll, pitch, yaw = r

    # Define the basic rotation matrices.
    def Rx(a: float) -> np.ndarray:
        return np.array([[1, 0, 0],
                         [0, np.cos(a), -np.sin(a)],
                         [0, np.sin(a),  np.cos(a)]])
    
    def Ry(a: float) -> np.ndarray:
        return np.array([[ np.cos(a), 0, np.sin(a)],
                         [         0, 1,         0],
                         [-np.sin(a), 0, np.cos(a)]])
    
    def Rz(a: float) -> np.ndarray:
        return np.array([[np.cos(a), -np.sin(a), 0],
                         [np.sin(a),  np.cos(a), 0],
                         [        0,          0, 1]])
    
    # Compute the target rotation matrix using the convention:
    #   R_target = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    R_target = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    
    #===========================================================================
    # Step 1. Determine Joint 1 (theta1) from the x-y projection of the target.
    #
    # From the URDF, the combined fixed translation along Y for joints 2, 3, and 5 is:
    #     offset_y = 0.13585 - 0.1197 + 0.093 = 0.10915.
    #
    # The effective x-y position of the arm (before the rotation by theta1) becomes:
    #     [S, offset_y]  where S = sqrt(r_xy^2 - offset_y^2) and
    #     r_xy = sqrt(p_x^2 + p_y^2).
    # The forward kinematics in the x-y plane satisfy:
    #     [p_x, p_y] = Rz(theta1) @ [S, offset_y].
    #
    # Thus, letting phi = arctan2(p_y, p_x), we deduce:
    #     theta1 = phi - arcsin(offset_y / r_xy)
    #===========================================================================
    offset_y = 0.10915
    r_xy = np.hypot(p_x, p_y)
    phi = np.arctan2(p_y, p_x)
    theta1 = phi - np.arcsin(offset_y / r_xy)
    S = np.sqrt(r_xy**2 - offset_y**2)
    
    #===========================================================================
    # Step 2. Remove the effect of Joint 1 from the target orientation.
    #
    # Compute the matrix M = Rz(-theta1) @ R_target. The remaining rotation
    # from joints 2-5 can be represented in the form:
    #     M = Ry(gamma) @ Rz(theta5)
    # Thus, we extract:
    #     gamma = arctan2(M[0,2], M[2,2])   and   theta5 = arctan2(M[1,0], M[1,1])
    # Here, gamma is the total rotation about Y contributed by joints 2,3,4:
    #     gamma = theta2 + theta3 + theta4.
    #===========================================================================
    M = Rz(-theta1) @ R_target
    gamma = np.arctan2(M[0, 2], M[2, 2])
    theta5 = np.arctan2(M[1, 0], M[1, 1])
    
    #===========================================================================
    # Step 3. Solve for Joints 2, 3, and 4 via a decoupled 2R-planar problem.
    #
    # The relevant link lengths are given as:
    #    L1 = 0.425     (from joint 2 to joint 3)
    #    L2 = 0.39225   (from joint 3 to joint 4)
    # The TCP offset (from the final joint) is:
    #    L3 = 0.09465.
    #
    # Removing the TCP offset contribution along the gamma direction:
    #    x_p = S - L3 * sin(gamma)
    #    z_p = p_z - L3 * cos(gamma)
    # For the 2R planar arm, the effective target is (x_p, z_p) with:
    #    r_planar = sqrt(x_p^2 + z_p^2)
    #
    # The standard 2R solution uses the law of cosines:
    #    cos(theta3) = (r_planar^2 - L1^2 - L2^2) / (2 * L1 * L2)
    # Hence, theta3 = arccos(cos(theta3))
    #
    # Then, an intermediate angle delta is computed as:
    #    delta = arctan2(L2*sin(theta3), L1 + L2*cos(theta3))
    # and the angle for Joint 2 becomes:
    #    theta2 = arctan2(x_p, z_p) - delta.
    #
    # Finally, Joint 4 (theta4) is set to satisfy:
    #    gamma = theta2 + theta3 + theta4   ==>   theta4 = gamma - (theta2 + theta3)
    #===========================================================================
    L1 = 0.425
    L2 = 0.39225
    L3 = 0.09465

    x_p = S - L3 * np.sin(gamma)
    z_p = p_z - L3 * np.cos(gamma)
    r_planar = np.hypot(x_p, z_p)

    cos_theta3 = (r_planar**2 - L1**2 - L2**2) / (2 * L1 * L2)
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)  # Account for numerical errors.
    theta3 = np.arccos(cos_theta3)

    delta = np.arctan2(L2 * np.sin(theta3), L1 + L2 * np.cos(theta3))
    theta2 = np.arctan2(x_p, z_p) - delta

    theta4 = gamma - (theta2 + theta3)
    
    return (theta1, theta2, theta3, theta4, theta5)