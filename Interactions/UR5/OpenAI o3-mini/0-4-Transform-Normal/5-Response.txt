def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4, theta5) to reach a target end-effector (TCP)
    position "p" and orientation "r". The target orientation is provided as roll, pitch, yaw (in radians) using the
    convention R_target = Rz(yaw) · Ry(pitch) · Rx(roll).

    The manipulator has 5 revolute joints:
        - Joint 1 rotates about Z.
        - Joints 2, 3, and 4 rotate about Y.
        - Joint 5 rotates about Z.
    The robot’s link geometry (derived from the URDF) is:
        Revolute 2 translation: [0, 0.13585, 0]
        Revolute 3 translation: [0, -0.1197, 0.425]   -> yields an effective link along Z and a small shift in Y.
        Revolute 4 translation: [0, 0, 0.39225]
        Revolute 5 translation: [0, 0.093, 0]
        TCP translation from joint 5: [0, 0, 0.09465]
    Noting that the small shift in Y “cancels out” to give an overall offset of 0.10915 in the y-direction:
         0.13585 + 0.093 - 0.1197 = 0.10915.
    The kinematics can be decoupled into:
      (1) Finding theta1 from the projection in the x-y plane.
      (2) “Removing” the theta1 rotation from the target orientation and extracting the summed wrist rotation, gamma,
          and the final joint theta5.
      (3) Solving a 2R planar arm (in a rotated x–z plane) for joints 2 and 3 then computing joint 4 from
          gamma = theta2 + theta3 + theta4.
    """
    import numpy as np
    
    # Unpack target TCP position and orientation (roll, pitch, yaw).
    p_x, p_y, p_z = p
    roll, pitch, yaw = r

    # Define basic rotation matrices.
    def Rx(a):
        return np.array([[1,            0,           0],
                         [0,  np.cos(a), -np.sin(a)],
                         [0,  np.sin(a),  np.cos(a)]])
    def Ry(a):
        return np.array([[ np.cos(a), 0, np.sin(a)],
                         [         0, 1,         0],
                         [-np.sin(a), 0, np.cos(a)]])
    def Rz(a):
        return np.array([[np.cos(a), -np.sin(a), 0],
                         [np.sin(a),  np.cos(a), 0],
                         [        0,          0, 1]])

    # Compute the target rotation matrix using the Rz(yaw) · Ry(pitch) · Rx(roll) convention.
    R_target = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    
    # -------------------------------------------------------------------------
    # (1) Solve for theta1 using the x-y projection.
    # The effective x-y position of the “arm” is offset by 0.10915 in y (from revolute 2, 3, & 5).
    offset_y = 0.10915
    r_xy = np.hypot(p_x, p_y)
    phi = np.arctan2(p_y, p_x)
    # The kinematics imply that the x-y components relate as:
    #   [p_x, p_y] = Rz(theta1) · [S, offset_y],  where S = sqrt(r_xy^2 - offset_y^2)
    # Hence, the first joint is:
    theta1 = phi - np.arcsin(offset_y / r_xy)
    S = np.sqrt(r_xy**2 - offset_y**2)
    
    # -------------------------------------------------------------------------
    # (2) Remove joint 1’s rotation from the target orientation.
    # Compute M = Rz(-theta1) * R_target so that the remaining rotation equals Ry(gamma) · Rz(theta5)
    M = Rz(-theta1) @ R_target
    # Extract gamma: note that for a rotation of the form Ry(gamma) · Rz(theta5), the (0,2) and (2,2) elements give:
    #     sin(gamma) and cos(gamma) respectively.
    gamma = np.arctan2(M[0, 2], M[2, 2])
    # The (1,0) and (1,1) elements of M equal sin(theta5) and cos(theta5) respectively.
    theta5 = np.arctan2(M[1, 0], M[1, 1])
    
    # -------------------------------------------------------------------------
    # (3) Solve for joints 2, 3, and 4 using a decoupled 2R planar problem.
    #
    # The effective arm after “removing” joint 1 and the TCP offset:
    #   - The links for the 2R chain are:
    #         L1 = 0.425 (from joint 2 to joint 3)
    #         L2 = 0.39225 (from joint 3 to joint 4)
    #   - The TCP offset from the final revolute joint (after joint 4) is:
    #         L3 = 0.09465.
    # The projection along the arm’s plane is:
    #   x_p = S - L3*sin(gamma)
    #   z_p = p_z - L3*cos(gamma)
    L1 = 0.425
    L2 = 0.39225
    L3 = 0.09465
    x_p = S - L3 * np.sin(gamma)
    z_p = p_z - L3 * np.cos(gamma)
    r2 = np.hypot(x_p, z_p)
    
    # Solve for theta3 via the law of cosines.
    cos_theta3 = (r2**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clip to avoid numerical issues.
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)
    theta3 = np.arccos(cos_theta3)
    
    # Compute an intermediate angle delta using the law of sines (or tangent form) for the 2R chain.
    delta = np.arctan2(L2 * np.sin(theta3), L1 + L2 * np.cos(theta3))
    # Then solve for theta2.
    theta2 = np.arctan2(x_p, z_p) - delta
    
    # Finally, joint 4 accounts for the remaining rotation so that:
    #    gamma = theta2 + theta3 + theta4,  hence:
    theta4 = gamma - (theta2 + theta3)
    
    return (theta1, theta2, theta3, theta4, theta5)