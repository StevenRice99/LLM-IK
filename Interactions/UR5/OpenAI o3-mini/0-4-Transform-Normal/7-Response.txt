def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4, theta5) needed to reach the
    target end-effector (TCP) position 'p' and orientation 'r'. The orientation is given as
    roll, pitch, yaw (in radians) using the convention:
        R_target = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    
    The manipulator has five revolute joints with the following characteristics:
      • Joint 1 rotates about Z.
      • Joints 2, 3, and 4 rotate about Y.
      • Joint 5 rotates about Z.
    
    The robot's link parameters (from the URDF) are:
        - Revolute 2 translation: [0, 0.13585, 0]
        - Revolute 3 translation: [0, -0.1197, 0.425]
        - Revolute 4 translation: [0, 0, 0.39225]
        - Revolute 5 translation: [0, 0.093, 0]
        - TCP offset (from joint 5): [0, 0, 0.09465]
    
    The effective offset in the Y-direction from the combined translations is:
        offset_y = 0.13585 - 0.1197 + 0.093 = 0.10915.
    
    The solution process is:
      (1) Decouple the x-y projection to solve for theta1:
            [p_x, p_y] = Rz(theta1) · [S, offset_y],
            with S = sqrt(p_x²+p_y² - offset_y²) and phi = arctan2(p_y, p_x),
            so that theta1 = phi − arcsin(offset_y / r_xy).
      (2) Remove joint 1’s rotation from R_target:
            M = Rz(−theta1) @ R_target,
            and write M = Ry(gamma) @ Rz(theta5), so extract:
                gamma  = arctan2(M[0,2], M[2,2])
                theta5 = arctan2(M[1,0], M[1,1])
      (3) For the remaining joints, subtract the TCP offset L3 = 0.09465 from the figure,
          and solve a 2R planar problem (in the rotated plane) for joints 2 and 3 with link lengths:
                L1 = 0.425 and L2 = 0.39225.
          Define:
                x_p = S − L3*sin(gamma)
                z_p = p_z − L3*cos(gamma)
          Then, with r_planar = sqrt(x_p² + z_p²), solve for theta3 using the law of cosines:
                cos(theta3) = (r_planar² − L1² − L2²) / (2*L1*L2)
          and compute:
                delta = arctan2(L2*sin(theta3), L1 + L2*cos(theta3))
                theta2 = arctan2(x_p, z_p) − delta
          Finally, since gamma = theta2 + theta3 + theta4:
                theta4 = gamma − (theta2 + theta3)
    """
    import numpy as np

    # Unpack target TCP position and orientation (roll, pitch, yaw).
    p_x, p_y, p_z = p
    roll, pitch, yaw = r

    # Define basic rotation matrices.
    def Rx(a):
        return np.array([[1, 0, 0],
                         [0, np.cos(a), -np.sin(a)],
                         [0, np.sin(a),  np.cos(a)]])
    
    def Ry(a):
        return np.array([[ np.cos(a), 0, np.sin(a)],
                         [         0, 1,         0],
                         [-np.sin(a), 0, np.cos(a)]])
    
    def Rz(a):
        return np.array([[np.cos(a), -np.sin(a), 0],
                         [np.sin(a),  np.cos(a), 0],
                         [        0,          0, 1]])

    # Compute the target rotation matrix.
    R_target = Rz(yaw) @ Ry(pitch) @ Rx(roll)
    
    # (1) Solve for theta1 using the x-y projection.
    offset_y = 0.10915                # effective Y-offset
    r_xy = np.hypot(p_x, p_y)           # projection magnitude in x-y plane
    phi = np.arctan2(p_y, p_x)
    theta1 = phi - np.arcsin(offset_y / r_xy)
    S = np.sqrt(r_xy**2 - offset_y**2)  # effective distance along the arm after compensating the offset

    # (2) Remove joint 1’s rotation from the target orientation.
    M = Rz(-theta1) @ R_target
    # For a rotation of the form Ry(gamma) @ Rz(theta5), the elements provide:
    gamma = np.arctan2(M[0, 2], M[2, 2])  # gamma = theta2 + theta3 + theta4
    theta5 = np.arctan2(M[1, 0], M[1, 1])
    
    # (3) Solve the 2R planar problem for joints 2 and 3.
    L1 = 0.425     # Link from joint 2 to joint 3.
    L2 = 0.39225   # Link from joint 3 to joint 4.
    L3 = 0.09465   # TCP offset from joint 5.
    
    # Adjust the effective coordinates by subtracting the TCP offset.
    x_p = S - L3 * np.sin(gamma)
    z_p = p_z - L3 * np.cos(gamma)
    r_planar = np.hypot(x_p, z_p)
    
    # Solve for theta3 using the law of cosines.
    cos_theta3 = (r_planar**2 - L1**2 - L2**2) / (2 * L1 * L2)
    cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)  # Numerical safety.
    theta3 = np.arccos(cos_theta3)
    
    # Compute the intermediate angle delta and then theta2.
    delta = np.arctan2(L2 * np.sin(theta3), L1 + L2 * np.cos(theta3))
    theta2 = np.arctan2(x_p, z_p) - delta
    
    # Determine theta4 from the relation: gamma = theta2 + theta3 + theta4.
    theta4 = gamma - (theta2 + theta3)
    
    return (theta1, theta2, theta3, theta4, theta5)