def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed‐form analytical solution for the inverse kinematics (position only)
    of a 6 DOF serial manipulator given a target TCP position p = (x, y, z).

    The kinematic chain (with all joint rotations zeroed) is as follows:
      • Revolute 1 (q1): at [0, 0, 0], rotates about Z.
      • Revolute 2 (q2): translated by [0, 0.13585, 0] then rotates about Y.
      • Revolute 3 (q3): translated by [0, -0.1197, 0.425] then rotates about Y.
      • Revolute 4 (q4): translated by [0, 0, 0.39225] then rotates about Y.
      • Revolute 5 (q5): translated by [0, 0.093, 0] then rotates about Z.
      • Revolute 6 (q6): translated by [0, 0, 0.09465] then rotates about Y.
      • TCP offset: translated by [0, 0.0823, 0].

    With all joints zero, the TCP is at [0, 0.19145, 0.9119]. Because the
    “position‐only” IK problem is underconstrained (six joints for position), we choose the
    solution where the wrist joints are set to zero (i.e. q4 = q5 = q6 = 0). In that case the TCP
    may be written as:
         p_TCP = Rz(q1) * { p2 + Ry(q2) * [ A + Ry(q3) * B ] },
    where the fixed translations are
         p2 = [0, 0.13585, 0],
         A  = [0, -0.1197, 0.425],
         B  = [0, 0.1753, 0.4869]   (note: 0.1753 = 0.093+0.0823 and 0.4869 = 0.39225+0.09465).

    A key observation is that the rotation Rz(q1) “rotates away” the X-coordinate of p.
    In fact, if we define
         q1 = atan2(-x, y)
    then the rotated target p' = Rz(-q1)*p becomes
         (0, sqrt(x²+y²), z).
    For reachability of the target the “planar” Y-component must equal the constant offset
         sqrt(x²+y²) = 0.19145.
    
    In the rotated frame the remaining unknowns (q2 and q3) are obtained by considering the
    planar 2R manipulator with effective link lengths:
         L1 = 0.425    (from the Z-part of A)
         L2 = 0.4869   (from the Z-part of B).
         
    The planar end‐effector (in the rotated frame) is:
         [ L1*sin(q2) + L2*sin(q2+q3),  L1*cos(q2) + L2*cos(q2+q3) ].
    To have zero “sagittal” (i.e. X-direction) displacement the following must hold:
         L1*sin(q2) + L2*sin(q2+q3) = 0.
    Combining with the “reach” along Z (the second component),
         L1*cos(q2) + L2*cos(q2+q3) = z,
    one obtains (by squaring and adding) the relation:
         z² = L1² + L2² + 2*L1*L2*cos(q3),
    so that
         cos(q3) = (z² - L1² - L2²) / (2*L1*L2).
    With q3 known (choosing the principal value) the zero-X condition gives:
         q2 = -atan2(L2*sin(q3), L1 + L2*cos(q3)).

    Finally, we assign q4 = q5 = q6 = 0.
    
    It is assumed that the provided target p is reachable (i.e. sqrt(x² + y²)=0.19145
    and z is such that |cos(q3)|≤1).

    :param p: A tuple (x, y, z) representing the desired TCP position.
    :return: A tuple of joint angles (q1, q2, q3, q4, q5, q6) in radians.
    """
    import math

    # Unpack the target position.
    x, y, z = p

    # Step 1: Determine q1 by aligning the target with the robot's natural plane.
    # This rotation eliminates the X-component in the rotated frame.
    q1 = math.atan2(-x, y)

    # In the rotated frame, the target becomes (0, r, z) with r = sqrt(x^2+y^2).
    # For a valid target r must equal 0.19145 (from the constant translations).
    # (Since we assume a reachable target, we need not enforce this explicitly.)

    # Step 2: Define the effective link lengths for the planar 2R sub-chain.
    L1 = 0.425    # Effective link length from A's Z-component.
    L2 = 0.4869   # Effective link length from B's Z-component.

    # Step 3: Solve for q3 via the cosine law.
    # z^2 = L1^2 + L2^2 + 2 * L1 * L2 * cos(q3)   -->   cos(q3) = (z^2 - L1^2 - L2^2) / (2*L1*L2)
    cos_q3 = (z**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_q3 to the interval [-1, 1] to prevent numerical issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Step 4: Solve for q2 using the "zero-X" (planar) condition.
    # The condition L1*sin(q2) + L2*sin(q2+q3) = 0 leads to:
    q2 = -math.atan2(L2 * math.sin(q3), (L1 + L2 * math.cos(q3)))

    # Step 5: Set the remaining wrist joints to zero.
    q4 = 0.0
    q5 = 0.0
    q6 = 0.0

    return (q1, q2, q3, q4, q5, q6)