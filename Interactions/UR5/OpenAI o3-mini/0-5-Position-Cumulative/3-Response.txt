def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed‐form analytical solution for the inverse kinematics for a 6 DOF serial
    manipulator given a target TCP position p = (x, y, z).

    The robot’s kinematic chain (with all rotations “zeroed”) is:
      - Revolute 1 (q1): at [0, 0, 0], rotates about Z.
      - Revolute 2 (q2): translates by [0, 0.13585, 0] then rotates about Y.
      - Revolute 3 (q3): translates by [0, -0.1197, 0.425] (the “arm” before the wrist).
      - Revolute 4 (q4): translates by [0, 0, 0.39225] then rotates about Y.
      - Revolute 5 (q5): translates by [0, 0.093, 0] then rotates about Z.
      - Revolute 6 (q6): translates by [0, 0, 0.09465] then rotates about Y.
      - TCP offset: translates by [0, 0.0823, 0].

    In the forward kinematics (with all joint angles zero) the TCP position is:
         [0, 0.19145, 0.9119].

    Since this IK “position‐only” problem is underconstrained (6 joints for position only),
    we choose one particular solution by “assigning” q4 = q5 = q6 = 0.
    Then the position equation becomes determined entirely by the first three joints.
    
    In our convention the rotations and translations along the chain (when q4, q5, q6 = 0)
    combine so that the TCP is computed by
       p_TCP = Rz(q1) * { p2 + R_y(q2) * [ A + R_y(q3)*B ] },
    where
       p2 = [0, 0.13585, 0]           (from base to link2)
       A  = [0, -0.1197, 0.425]        (from link2 to link3)
       B  = [0, 0.1753, 0.4869]         (wrist + TCP offset; note: 0.1753 = 0.093+0.0823 and 0.4869 = 0.39225+0.09465)
    
    It turns out (by working through the algebra) that when you “rotate away” q1 you obtain a
    planar (Y–Z) 2R manipulator with effective link lengths:
         L1 = 0.425       (from the A-part: its Z component) 
         L2 = 0.4869      (from the wrist offset B, its Z contribution).
    
    In the rotated frame (by angle -q1) the TCP becomes:
         p' = (0, p'_y, p'_z)
    with p'_y fixed to 0.19145 (because 0.13585 + (-0.1197 + 0.1753) = 0.19145)
    and p'_z equal to the desired reach along Z.
    
    To “invert” the planar equations we note that the two joint angles q2 and q3 must satisfy:
         (i)   L1*sin(q2) + L2*sin(q2+q3) = 0,   (so that the X (or “sagittal”) component is zero)
         (ii)  L1*cos(q2) + L2*cos(q2+q3) = p'_z.
    Equation (i) forces
         tan(q2) = - [L2*sin(q3)] / [L1 + L2*cos(q3)]
    so that we can choose
         q2 = -atan2(L2*math.sin(q3), L1 + L2*math.cos(q3)).
    And then (ii) gives the relation
         p'_z = sqrt(L1**2 + L2**2 + 2*L1*L2*cos(q3)).
    Hence, we first solve for q3 from
         cos(q3) = (p'_z**2 - L1**2 - L2**2) / (2 * L1 * L2),
    and then set q2 accordingly.
    
    We obtain q1 by “aligning” the target p with the robot’s natural plane. In particular,
         q1 = atan2(-x, y)
    guarantees that when we rotate p about –q1 about Z the resulting x-component vanishes.
    
    Finally, we set q4, q5, and q6 to zero.
    
    :param p: The desired TCP position as (x, y, z).
    :return: A 6-tuple of joint angles (q1, q2, q3, q4, q5, q6) in radians.
    """
    import math

    x, y, z = p

    # ---------- Solve for q1 ----------
    # q1 rotates about Z. Choosing q1 = atan2(-x, y) ensures that when p is rotated by -q1,
    # its x-coordinate becomes zero.
    q1 = math.atan2(-x, y)

    # Rotate p by -q1 about the Z-axis so that the arm “planar” problem appears in the Y-Z plane.
    # For a rotation by -q1:
    cos_q1 = math.cos(q1)
    sin_q1 = math.sin(q1)
    # new coordinates p_rot = Rz(-q1)*[x, y, z]:
    x_r = cos_q1 * x + sin_q1 * y   # this should become 0
    y_r = -sin_q1 * x + cos_q1 * y
    z_r = z  # unchanged

    # In our robot, the Y component of the TCP is fixed by the translations:
    # p2_y (0.13585) + (-0.1197 + 0.1753) = 0.19145.
    # Thus, for a valid target p the rotated coordinate should have y_r = 0.19145.
    # (We assume the input target is reachable so that this holds.)
    
    # ---------- Solve for q2 and q3 using the equivalent planar 2R manipulator ----------
    #
    # In the rotated frame, the remaining displacement (after the base translation p2)
    # comes only in the Z direction. The effective manipulator (starting at the end of link2)
    # has:
    #      Link 1 length: L1 = 0.425         (from the translation [0, -0.1197, 0.425])
    #      Link 2 length: L2 = 0.4869        (the combined effect of the wrist offset,
    #                                        from [0, 0, 0.39225] + [0, 0.09465] in Z plus [0,0.093,0] and [0,0.0823] in Y;
    #                                        only the Z parts affect the reach).
    #
    # The planar equations (with the arm “starting” at p2) are:
    #      (i)   L1 * sin(q2) + L2 * sin(q2+q3) = 0
    #      (ii)  L1 * cos(q2) + L2 * cos(q2+q3) = z_r.
    #
    # From (i) we deduce:
    #      tan(q2) = - (L2*sin(q3)) / (L1 + L2*cos(q3)),
    # so we can set:
    #      q2 = -atan2(L2 * sin(q3), (L1 + L2 * cos(q3))).
    # And (ii) gives the relation which we use to solve for q3:
    #      z_r = sqrt(L1**2 + L2**2 + 2*L1*L2*cos(q3)).
    #
    L1 = 0.425
    L2 = 0.4869

    # Solve for q3 from the cosine law:
    cos_q3 = (z_r**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Ensure numerical safety:
    if cos_q3 > 1.0:
        cos_q3 = 1.0
    elif cos_q3 < -1.0:
        cos_q3 = -1.0
    q3 = math.acos(cos_q3)
    # (There are two possible solutions for q3: "elbow up" and "elbow down" by taking ±q3.
    # Here we choose the principal value.)

    # Now, using the sine relation from (i):
    q2 = - math.atan2(L2 * math.sin(q3), (L1 + L2 * math.cos(q3)))

    # ---------- Set the remaining joints ----------
    # With our choice of q4 = q5 = q6 = 0, the wrist and end-effector do not further affect the position.
    q4 = 0.0
    q5 = 0.0
    q6 = 0.0

    return (q1, q2, q3, q4, q5, q6)