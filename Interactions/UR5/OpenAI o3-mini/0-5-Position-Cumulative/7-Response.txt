def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed‐form analytical solution for the inverse kinematics (position only)
    of the 6 DOF serial manipulator given a desired TCP position p = (x, y, z).

    The kinematic chain (with all joint rotations zeroed) is:
      - Revolute 1 (q1): at [0, 0, 0], rotates about Z.
      - Revolute 2 (q2): translated by [0, 0.13585, 0] then rotates about Y.
      - Revolute 3 (q3): translated by [0, -0.1197, 0.425] (the “arm” before the wrist).
      - Revolute 4 (q4): translated by [0, 0, 0.39225] then rotates about Y.
      - Revolute 5 (q5): translated by [0, 0.093, 0] then rotates about Z.
      - Revolute 6 (q6): translated by [0, 0, 0.09465] then rotates about Y.
      - TCP offset: translated by [0, 0.0823, 0].

    With all joint angles zero the TCP is at:
         [0, 0.19145, 0.9119].

    Since the “position‐only” IK problem is underconstrained (6 joints for position),
    we choose the solution where the wrist joints are set to zero (q4 = q5 = q6 = 0).

    In our derivation the forward kinematics (with q4=q5=q6=0) can be written as:
         p_TCP = Rz(q1) * { p2 + Ry(q2) * [ A + Ry(q3) * B ] },
    where:
         p2 = [0, 0.13585, 0]
         A  = [0, -0.1197, 0.425]
         B  = [0, 0.1753, 0.4869]    (with 0.1753 = 0.093 + 0.0823 and 0.4869 = 0.39225 + 0.09465)

    A key observation is that a rotation by q1 about Z “rotates away” the X component,
    so that in the rotated frame the TCP lies in the Y–Z plane. In fact, with this rotation,
    the TCP becomes:
         p' = Rz(-q1)*p  = (0, 0.19145, z)
    where 0.19145 is fixed (the sum of the constant translations along Y) and z is the reach.
    
    This transformed problem reduces to a planar 2R manipulator in the Y–Z plane with effective
    link lengths given by the Z components of A and B:
         L1 = 0.425     (from A's Z-part)
         L2 = 0.4869    (from B's Z-part)
    
    In the rotated (planar) frame the position equations become:
         (i)   L1*sin(q2) + L2*sin(q2+q3) = 0   (to ensure the X offset is zero)
         (ii)  L1*cos(q2) + L2*cos(q2+q3) = z
         
    Equation (i) leads to:
         tan(q2) = - [L2*sin(q3)]/(L1 + L2*cos(q3))
    so that we can choose:
         q2 = -atan2(L2*sin(q3), L1 + L2*cos(q3)).
    
    Meanwhile, combining (i) and (ii) yields:
         z^2 = L1^2 + L2^2 + 2*L1*L2*cos(q3)
    so that:
         cos(q3) = (z**2 - L1**2 - L2**2) / (2 * L1 * L2).
    
    Finally, q1 is obtained by aligning the input target p with the robot’s natural plane:
         q1 = atan2(-x, y)
    
    With q4, q5, and q6 set to zero, this yields one valid IK solution.

    Note: It is assumed that the input target position p = (x, y, z) is reachable.

    :param p: A tuple (x, y, z) representing the desired position of the TCP.
    :return: A tuple (q1, q2, q3, q4, q5, q6) of joint angles in radians.
    """
    import math

    # Extract the target TCP coordinates.
    x, y, z = p

    # --- Compute q1 ---
    # Choose q1 to rotate the target about Z so that its x-component vanishes in the rotated frame.
    q1 = math.atan2(-x, y)

    # --- Define effective link lengths for the planar 2R arm ---
    L1 = 0.425    # Effective link length from the Z-component of A.
    L2 = 0.4869   # Effective link length from the Z-component of B.

    # --- Compute q3 using the cosine law of the planar 2R arm ---
    # z^2 = L1^2 + L2^2 + 2 * L1 * L2 * cos(q3)
    cos_q3 = (z**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_q3 to the interval [-1, 1] to avoid numerical issues.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # --- Compute q2 using the sine requirement (which ensures zero x-offset) ---
    q2 = -math.atan2(L2 * math.sin(q3), (L1 + L2 * math.cos(q3)))

    # --- Assign the remaining joint angles (wrist joints) to zero ---
    q4 = 0.0
    q5 = 0.0
    q6 = 0.0

    return (q1, q2, q3, q4, q5, q6)