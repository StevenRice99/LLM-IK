def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    import math

    # Extract the desired TCP coordinates.
    x, y, z = p

    # Step 1: Solve for q1.
    # Choose q1 = atan2(-x, y) so that when the target is rotated about Z by –q1,
    # its x-coordinate becomes 0.
    q1 = math.atan2(-x, y)

    # Effective link lengths for the decoupled planar (Y–Z) sub-problem.
    # They come from the Z contributions of the translations:
    #   A = [0, -0.1197, 0.425]  and  B = [0, 0.1753, 0.4869].
    # Thus, L1 = 0.425 and L2 = 0.4869.
    L1 = 0.425
    L2 = 0.4869

    # Step 2: Solve for q3 using the law of cosines.
    # In the decoupled planar chain, the desired TCP z-coordinate must satisfy:
    #    z = L1*cos(q2) + L2*cos(q2 + q3)
    # Using the law of cosines we have:
    #    z^2 = L1**2 + L2**2 + 2*L1*L2*cos(q3)
    # Solve for cos(q3):
    cos_q3 = (z**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp to [-1, 1] for numerical safety.
    cos_q3 = max(min(cos_q3, 1.0), -1.0)
    q3 = math.acos(cos_q3)

    # Step 3: Solve for q2 using the requirement that the rotated (planar) x-component is zero.
    # This gives:
    #    tan(q2) = - (L2*sin(q3)) / (L1 + L2*cos(q3))
    q2 = -math.atan2(L2 * math.sin(q3), (L1 + L2 * math.cos(q3)))

    # Step 4: Choose the wrist joints to be zero.
    q4 = 0.0
    q5 = 0.0
    q6 = 0.0

    return (q1, q2, q3, q4, q5, q6)