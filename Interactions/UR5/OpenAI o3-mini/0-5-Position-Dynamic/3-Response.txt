def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes the inverse kinematics for a 6-DOF serial manipulator.
    
    The robot is decoupled into an "arm" (joints 1–3) that positions the wrist center,
    and a "wrist" (joints 4–6) that orients the end-effector (TCP). The TCP has a fixed
    orientation given by rpy = [0, 0, 1.570796325] (i.e. a +90° rotation about Z) and a fixed 
    offset with respect to the wrist given by:
                [0, L1 + a, L2]  where L1 = 0.093, a = 0.0823, L2 = 0.09465.
    Rotating that offset by Rz(1.570796325) gives the TCP offset in the base frame:
                [-0.1753, 0, 0.09465].
    Hence, the wrist center is computed as:
                p_w = p_TCP − (Rz(1.570796325) · [0, L1+a, L2])
                    = (p_x + 0.1753, p_y, p_z − 0.09465)
                    
    For the arm (joints 1–3) the law of cosines is applied using the link lengths:
                L_link2 = 0.425   (from revolute 2 to revolute 3)  
                L_link3 = 0.39225 (from revolute 3 to revolute 4)
    and a small lateral offset given by k = 0.01615 (derived from the origin positions).
    
    The wrist sub–chain (joints 4–6) is solved by expressing the relative vector v from 
    wrist to TCP in the wrist (joint-4) frame. For the desired orientation and geometry, 
    the two–link wrist solution results in trivial joint angles.
    
    :param p: TCP target position (x, y, z) in the base frame.
    :return: Tuple of joint angles (θ1, θ2, θ3, θ4, θ5, θ6) in radians.
    """
    import math

    # ----- Robot Geometry Constants -----
    # Arm (joints 1–3)
    L_link2 = 0.425      # Length from revolute 2 to 3 (projected)
    L_link3 = 0.39225    # Length from revolute 3 to 4 (projected)
    k = 0.01615          # Lateral offset (derived from link origins)
    
    # Wrist and TCP offsets
    L1 = 0.093           # Translation from revolute 4 to 5 along Y
    a  = 0.0823          # Additional TCP offset along Y (in TCP frame)
    L2 = 0.09465         # Translation from revolute 5 to 6 along Z
    # Combined TCP offset in wrist frame:
    #   offset_tcp_wrist = [0, L1+a, L2] = [0, 0.1753, 0.09465]
    # Rotating by Rz(1.570796325) (i.e. 90° about Z) gives:
    #   offset_base = [ -0.1753, 0, 0.09465 ]
    
    # ----- Step 1: Compute the Wrist Center Position -----
    x_tcp, y_tcp, z_tcp = p
    # p_w = p_TCP - (offset expressed in base frame)
    # Since offset_base = (-0.1753, 0, 0.09465), we subtract a negative in x:
    x_w = x_tcp + 0.1753
    y_w = y_tcp
    z_w = z_tcp - 0.09465

    # ----- Step 2: Solve IK for the Arm Sub–chain (Joints 1–3) -----
    # Use the law of cosines to solve for joint 3.
    # Equation: cos(θ3) = (||p_w||^2 - (L_link2^2 + L_link3^2)) / (2 * L_link2 * L_link3)
    squared_norm = x_w**2 + y_w**2 + z_w**2
    cos_theta3 = (squared_norm - (L_link2**2 + L_link3**2)) / (2 * L_link2 * L_link3)
    # Clamp cosθ3 to be within [-1, 1] for numerical safety.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)
    
    # Compute helper variables for joint 2.
    C = L_link2 + L_link3 * math.cos(theta3)
    D = L_link3 * math.sin(theta3)
    
    # Compute the projection of p_w onto the base (x-y) plane with adjustment by k.
    A_sq = x_w**2 + y_w**2 - k**2
    A = math.sqrt(A_sq) if A_sq >= 0 else 0.0
    
    denom_theta2 = C**2 + D**2
    sin_theta2 = (C * A - D * z_w) / denom_theta2
    cos_theta2 = (C * z_w + D * A) / denom_theta2
    theta2 = math.atan2(sin_theta2, cos_theta2)
    
    # Joint 1 is obtained from the projection of the wrist center onto the base plane.
    if (x_w**2 + y_w**2) == 0:
        theta1 = 0.0
    else:
        num_theta1 = A * y_w - k * x_w
        den_theta1 = A * x_w + k * y_w
        theta1 = math.atan2(num_theta1, den_theta1)
    
    # ----- Step 3: Solve IK for the Wrist Sub–chain (Joints 4–6) -----
    # Compute the vector from the wrist center to the TCP.
    v_x = x_tcp - x_w     # Expected to be -0.1753
    v_y = y_tcp - y_w     # Expected to be 0
    v_z = z_tcp - z_w     # Expected to be 0.09465
    
    # Transform the v vector from the base frame into the wrist (joint 4) frame.
    # This is done by "undoing" the TCP rotation Rz(1.570796325),
    # i.e. applying Rz(-1.570796325).
    cos_m90 = math.cos(-1.570796325)
    sin_m90 = math.sin(-1.570796325)
    # Only the (x,y) components are rotated.
    x_target = cos_m90 * v_x - sin_m90 * v_y
    y_target = sin_m90 * v_x + cos_m90 * v_y
    z_target = v_z  # remains unchanged
    # With the given geometry, one finds:
    #   x_target ≈ 0, y_target ≈ 0.1753, and z_target ≈ 0.09465.
    
    # Now solve the 2-link planar wrist IK (similar to EXISTING CODE 2).
    # Here, the first wrist link offset along Y is L1 and the "link length" is a.
    c2 = (y_target - L1) / a
    c2 = max(min(c2, 1.0), -1.0)
    theta5 = math.acos(c2)
    s2 = math.sin(theta5)
    
    # Compute theta4 using the 2-link geometry.
    A_w = L2       # length of the second wrist link (along Z)
    B_w = -a * s2  # term from projection
    denom_w = A_w**2 + (a * s2)**2
    if abs(denom_w) < 1e-10:
        theta4 = 0.0
    else:
        sin_theta4 = (A_w * x_target - B_w * z_target) / denom_w
        cos_theta4 = (A_w * z_target + B_w * x_target) / denom_w
        theta4 = math.atan2(sin_theta4, cos_theta4)
    
    # For this fixed TCP orientation and geometry, the final wrist joint is set to zero.
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)