def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes the joint angles for a 6-DOF serial manipulator given a TCP target position p
    (expressed in the base frame). The inverse kinematics solution decouples into:
      - An "arm" sub–chain (joints 1–3) that positions the wrist center.
      - A "wrist" sub–chain (joints 4–6) that orients the TCP.

    The robot’s URDF (and forward kinematics) indicate:
      • Revolute 2 and 3 (arm links) have effective link lengths:
              L2 = 0.425    (from revolute 2 to 3)
              L3 = 0.39225  (from revolute 3 to 4)
        and a small lateral offset: k = 0.01615
      • The TCP (tool) is defined in its own frame with position [0, 0.0823, 0].
      • There are fixed translations along the wrist:
              – From revolute 4 to 5: 0.093 along Y.
              – From revolute 5 to 6: 0.09465 along Z.
        Thus the overall offset from the wrist center (origin of revolute 4)
        to the TCP, expressed in the wrist frame, is:
                [0, L_wristY, L_wristZ] = [0, 0.093 + 0.0823, 0.09465] = [0, 0.1753, 0.09465]
      • With the desired fixed TCP orientation given as rpy = [0, 0, 1.570796325]
        (a +90° rotation about Z), the forward kinematics show that sub–chain 
        solutions with all wrist joints set to zero will deliver the desired orientation.
    
    This function performs the decoupling as follows:
      1. Compute the wrist center position p_w by subtracting the fixed wrist–to–TCP
         offset (expressed in the base frame) from the TCP position.
         Given the FK results, the correct base–frame wrist offset is:
             [0, 0.1753, 0.09465]
         so that:
             p_w = (x_TCP, y_TCP – 0.1753, z_TCP – 0.09465)
      2. Solve the arm IK (joints 1–3) using the law of cosines:
             cos(theta3) = (||p_w||² – (L2² + L3²)) / (2 * L2 * L3)
         and then compute theta2 and theta1 by appropriate projections.
      3. For the wrist (joints 4–6), given the fixed TCP orientation and geometry,
         a valid solution is to transmit zero angles:
             theta4 = theta5 = theta6 = 0.
    
    :param p: A tuple (x, y, z) representing the TCP target position in the base frame.
    :return: A tuple (theta1, theta2, theta3, theta4, theta5, theta6) of joint angles in radians.
    """
    
    import math

    # --- Geometry constants from the URDF ---
    # Arm sub–chain (joints 1–3)
    L2 = 0.425      # Effective link length from revolute 2 to 3
    L3 = 0.39225    # Effective link length from revolute 3 to 4
    k  = 0.01615    # Lateral offset (computed as 0.13585 - 0.1197)

    # Wrist and TCP offsets (from the wrist center, i.e. origin of revolute 4)
    # From revolute 4 to 5: translation along Y = 0.093, plus TCP offset along Y = 0.0823
    # From revolute 5 to 6: translation along Z = 0.09465.
    wrist_offset_y = 0.093 + 0.0823   # = 0.1753
    wrist_offset_z = 0.09465

    # --- Step 1: Compute the Wrist Center Position ---
    # Let the desired TCP position be p = (x_tcp, y_tcp, z_tcp).
    # Then, the wrist center (origin of revolute 4) is:
    #   p_w = (x_tcp, y_tcp - wrist_offset_y, z_tcp - wrist_offset_z)
    x_tcp, y_tcp, z_tcp = p
    x_w = x_tcp
    y_w = y_tcp - wrist_offset_y
    z_w = z_tcp - wrist_offset_z

    # --- Step 2: Solve IK for the Arm Sub–chain (Joints 1–3) ---
    # Compute the squared norm of the wrist center vector.
    squared_norm = x_w**2 + y_w**2 + z_w**2

    # Solve for joint 3 using the law of cosines:
    #   cos(theta3) = (||p_w||² - (L2² + L3²)) / (2 * L2 * L3)
    cos_theta3 = (squared_norm - (L2**2 + L3**2)) / (2 * L2 * L3)
    # Clamp cos_theta3 to the valid range [-1, 1] to avoid numerical errors.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)
    
    # Compute helper values for joint 2.
    C = L2 + L3 * math.cos(theta3)
    D = L3 * math.sin(theta3)
    
    # Compute A: the effective projection in the XY plane adjusted with the lateral offset k.
    A_sq = x_w**2 + y_w**2 - k**2
    A = math.sqrt(A_sq) if A_sq >= 0 else 0.0
    
    # Use the following relations to solve for theta2:
    #   sin(theta2) = (C * A - D * z_w) / (C**2 + D**2)
    #   cos(theta2) = (C * z_w + D * A) / (C**2 + D**2)
    denom = C**2 + D**2
    sin_theta2 = (C * A - D * z_w) / denom
    cos_theta2 = (C * z_w + D * A) / denom
    theta2 = math.atan2(sin_theta2, cos_theta2)
    
    # Solve for joint 1 using the projection onto the XY plane.
    if (x_w**2 + y_w**2) < 1e-8:
        theta1 = 0.0
    else:
        num_theta1 = A * y_w - k * x_w
        den_theta1 = A * x_w + k * y_w
        theta1 = math.atan2(num_theta1, den_theta1)
    
    # --- Step 3: Solve IK for the Wrist Sub–chain (Joints 4–6) ---
    # With the desired fixed TCP orientation (rpy = [0, 0, 1.570796325]) and the robot geometry,
    # the wrist joint solution can be chosen as:
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)