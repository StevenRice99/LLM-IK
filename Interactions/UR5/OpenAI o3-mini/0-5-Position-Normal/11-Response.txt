def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of a 6-DOF serial manipulator,
    given a target TCP position p = (x, y, z).

    The robot’s geometry is defined as follows:
      • Revolute 1: position [0, 0, 0], rotation about Z.
      • Revolute 2: position [0, 0.13585, 0], rotation about Y.
      • Revolute 3: position [0, -0.1197, 0.425], rotation about Y.
      • Revolute 4: position [0, 0, 0.39225], rotation about Y.
      • Revolute 5: position [0, 0.093, 0], rotation about Z.
      • Revolute 6: position [0, 0, 0.09465], rotation about Y.
      • TCP: position [0, 0.0823, 0] with an orientation offset.

    When the wrist joints (θ₄, θ₅, θ₆) are set to zero, the forward kinematics shows that
    the TCP position is obtained by a decoupling into a base rotation plus a 2R planar arm.
    
    Key observations:
      1. A constant offset in the manipulator’s “arm plane” arises from:
            const_y = 0.13585 - 0.1197 + (0.093 + 0.0823) = 0.19145 m.
         In the XY plane, the TCP is given by rotating the vector [r, const_y] by θ₁.
         If R_xy = sqrt(x² + y²) is the polar magnitude of (x,y) then:
            r = sqrt(R_xy² - const_y²)
         and the base joint angle is found from:
            θ₁ = atan2(y, x) - atan2(const_y, r).

      2. The remaining two joints (θ₂ and θ₃) form a planar 2R arm in the (r, z) plane.
         The effective link lengths are:
            L2 = 0.425 m,
            L3 = 0.39225 + 0.09465 = 0.4869 m.
         The planar relationships are:
            r  = L2 sin(θ₂) + L3 sin(θ₂+θ₃)
            p_z = L2 cos(θ₂) + L3 cos(θ₂+θ₃)
         Define:
            K = sqrt(r² + p_z²)
         and compute
            D = (K² - L2² - L3²) / (2*L2*L3).
         Then:
            θ₃ = atan2(√(1-D²), D)
            β = atan2(L3 sin(θ₃), L2 + L3 cos(θ₃))
            θ₂ = atan2(r, p_z) - β.

      3. By design, the wrist joints are chosen to be:
            θ₄ = θ₅ = θ₆ = 0.
    
    Assumes the target position is reachable.
    
    :param p: A tuple (x, y, z) specifying the desired TCP position in meters.
    :return: A 6-tuple (θ₁, θ₂, θ₃, θ₄, θ₅, θ₆) of joint angles in radians.
    """
    import math

    # Unpack the target TCP coordinates.
    p_x, p_y, p_z = p

    # Fixed offset due to link translations:
    const_y = 0.19145

    # Effective link lengths in the decoupled 2R planar arm.
    L2 = 0.425
    L3 = 0.39225 + 0.09465  # equals 0.4869

    # ---------------------------------------------------------------------------
    # Step 1: Solve for base joint θ₁.
    # The (x, y) coordinates satisfy:
    #   [p_x, p_y] = Rz(θ₁) · [r, const_y],
    # where R_xy² = r² + const_y². Hence, compute:
    R_xy = math.sqrt(p_x**2 + p_y**2)
    r = math.sqrt(max(R_xy**2 - const_y**2, 0))
    theta1 = math.atan2(p_y, p_x) - math.atan2(const_y, r)

    # ---------------------------------------------------------------------------
    # Step 2: Solve the 2R inverse kinematics for joints θ₂ and θ₃.
    # In the (r, p_z) plane, find θ₂ and θ₃ from:
    #   r   = L2 sin(θ₂) + L3 sin(θ₂+θ₃)
    #   p_z = L2 cos(θ₂) + L3 cos(θ₂+θ₃)
    K = math.sqrt(r**2 + p_z**2)
    D = (K**2 - L2**2 - L3**2) / (2 * L2 * L3)
    # Clamp D to the valid range [-1, 1] to avoid numerical issues.
    D = max(min(D, 1.0), -1.0)
    theta3 = math.atan2(math.sqrt(max(1 - D**2, 0)), D)
    beta = math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    theta2 = math.atan2(r, p_z) - beta

    # ---------------------------------------------------------------------------
    # Step 3: Select wrist joint angles.
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)