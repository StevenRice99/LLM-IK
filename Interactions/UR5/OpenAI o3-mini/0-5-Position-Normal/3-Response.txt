We can “decouple” the position inverse‐kinematics (IK) by noticing that when we hold the last “wrist” joints fixed (here we choose θ₄ = θ₅ = θ₆ = 0), the kinematics from the base up to the wrist center can be “projected” into a 2D problem. In our robot the constant translation in the Y direction from the second link (combined with later offsets) always contributes a fixed offset (0.19145 m) along the Y‐axis of the “arm” portion. In particular, if p = (pₓ, p_y, p_z) is the target TCP position in base coordinates and we choose the wrist joints zero, then using the forward kinematics we find that

  p_tcp = Rz(θ₁) · { [0, 0.13585, 0] + R_y(θ₂)·[0, –0.1197, 0.425] + R_y(θ₂+θ₃)·[0, 0.093+0.0823, 0.39225+0.09465] }

Observe that the three components split into two parts: (1) a net constant offset in what becomes the “arm’s” Y direction (0.13585 – 0.1197 + (0.093+0.0823) = 0.19145) and (2) the (θ₂,θ₃)–dependent “planar 2R” arm with “link lengths” L₂ = 0.425 and L₃ = 0.4869. Moreover the base rotation (θ₁ about Z) “rotates” the 2D solution into the (x,y) plane. In this formulation the (x,y) position must satisfy

  [pₓ, p_y] = Rz(θ₁) · [r, 0.19145]      (1)

with

  r = L₂ sin(θ₂) + L₃ sin(θ₂+θ₃).

Also the z-component must satisfy

  p_z = L₂ cos(θ₂) + L₃ cos(θ₂+θ₃).    (2)

Because the vector [r, 0.19145] (which “lives” in the arm’s own plane) is rotated by θ₁ to yield the (x,y) coordinates, its magnitude is fixed by

  √(pₓ² + p_y²) = √(r² + 0.19145²).

Thus one may solve for r by

  r = √(pₓ² + p_y² – 0.19145²).

Then one obtains θ₁ from (1) by

  θ₁ = atan2(p_y, pₓ) – atan2(0.19145, r).

Next, the (θ₂,θ₃) “arm‐IK” is just that of a planar 2R manipulator to match

  (r, p_z) = (L₂ sin(θ₂) + L₃ sin(θ₂+θ₃), L₂ cos(θ₂) + L₃ cos(θ₂+θ₃)).

A standard solution is to first compute

  K = √(r² + p_z²),
  D = (K² – L₂² – L₃²) / (2 L₂ L₃),

(with D clamped to [–1,1]) and then choose
  θ₃ = atan2(√(1 – D²), D)
and
  θ₂ = atan2(r, p_z) – atan2(L₃ sin(θ₃), L₂ + L₃ cos(θ₃)).

Finally we set (by design) the wrist joints to zero:
  θ₄ = θ₅ = θ₆ = 0.

A complete Python solution is given below. (Do not include any code for running or testing this – only the function definition is provided.)

Below is the complete inverse_kinematics function:

------------------------------------------------------------
def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" in space.
    :param p: The target TCP position in the form (x, y, z).
    :return: A 6-tuple of joint angles (radians) for joints 1..6.
    """
    import math

    # Unpack target TCP position.
    p_x, p_y, p_z = p

    # --- Known constant geometric parameters (all in meters) ---
    # The fixed translation components:
    # From link 1 to link 2: translation in Y=0.13585.
    # From link 2 to link 3: translation [0, -0.1197, 0.425].
    # Combined later wrist offsets (links 5 and TCP): 0.093 + 0.0823 = 0.1753 along Y.
    # Thus the arm always contributes a constant offset of:
    const_y = 0.13585 - 0.1197 + 0.1753  # = 0.19145

    # The planar “arm” lengths (from revolute-2 to wrist center via revolute-3):
    L2 = 0.425
    L3 = 0.4869

    # For our particular closed-form solution, we choose the wrist joints as default:
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    # --- Decouple the problem into a base rotation (theta1) plus a planar 2R arm solving for theta2 and theta3 ---
    # (a) The (x,y) position is given from rotating the vector [r, const_y] by theta1.
    # Its magnitude is:
    R_xy = math.sqrt(p_x**2 + p_y**2)
    # Because in our geometry R_xy^2 = r^2 + const_y^2, we solve for r:
    # (Assume the target is reachable so that R_xy >= const_y.)
    r = math.sqrt(max(R_xy**2 - const_y**2, 0))
    # Solve for theta1 from:
    #   pₓ = cos(theta1)*r - sin(theta1)*const_y,
    #   p_y = sin(theta1)*r + cos(theta1)*const_y.
    # This leads to:
    theta1 = math.atan2(p_y, p_x) - math.atan2(const_y, r)

    # (b) Now solve the planar 2R problem for [r, p_z]:
    K = math.sqrt(r**2 + p_z**2)
    # Use the cosine law to compute theta3:
    D = (K**2 - L2**2 - L3**2) / (2 * L2 * L3)
    # Clamp D to account for numerical precision issues
    D = max(min(D, 1.0), -1.0)
    theta3 = math.atan2(math.sqrt(max(1 - D**2, 0)), D)
    # Then define an auxiliary angle and solve for theta2:
    beta = math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    theta2 = math.atan2(r, p_z) - beta

    return (theta1, theta2, theta3, theta4, theta5, theta6)
------------------------------------------------------------

Explanation of key steps:
1. We first “remove” the fixed offset in the (x,y) plane (0.19145 m) that comes from the translations of links 2, 5, and the TCP. This lets us compute an effective “arm reach” r from base rotation.
2. θ₁ is obtained by “unrotating” the (x,y) target by the angle corresponding to the fixed offset.
3. With r and p_z in hand, we solve the standard 2R planar equations (via the cosine law) for θ₂ and θ₃.
4. Finally, we set the wrist (θ₄, θ₅, θ₆) to zero – a valid choice since the input specifies only position (and we assume the default orientation is acceptable).

This closed‐form solution yields one valid IK solution (assuming the target is reachable).