def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of the 6-DOF manipulator to reach the target TCP position.
    
    The robot’s geometry is defined by:
      • Revolute 1 : translation [0, 0, 0], axis Z.
      • Revolute 2 : translation [0, 0.13585, 0], axis Y.
      • Revolute 3 : translation [0, -0.1197, 0.425], axis Y.
      • Revolute 4 : translation [0, 0, 0.39225], axis Y.
      • Revolute 5 : translation [0, 0.093, 0], axis Z.
      • Revolute 6 : translation [0, 0, 0.09465], axis Y.
      • TCP      : translation [0, 0.0823, 0] with an orientation offset.
      
    By “undoing” the fixed offsets, we decouple the position inverse kinematics into:
      1. A base rotation (θ₁) that aligns the arm plane with the target’s (x,y) position.
      2. A planar 2R inverse kinematics (θ₂, θ₃) with effective link lengths:
            L2 = 0.425 (from Revolute 3’s z-offset) and
            L3 = 0.39225 + 0.09465 = 0.4869
         The constant shift in the arm’s local y-direction computed from:
            const_y = 0.13585 (Revolute 2) – 0.1197 (Revolute 3) + (0.093+0.0823) (Revolute 5 and TCP)
                  = 0.19145.
      3. The wrist joints (θ₄, θ₅, θ₆) are chosen to be zero.
    
    The effective (x,y) target fulfills:
         [pₓ, p_y] = Rz(θ₁) · [r, const_y],
         where r = sqrt(pₓ² + p_y² − const_y²) provided p is reachable.
         
    The planar 2R equations are:
         r = L2 sin(θ₂) + L3 sin(θ₂+θ₃)
         p_z = L2 cos(θ₂) + L3 cos(θ₂+θ₃)
    
    :param p: The target TCP position as a tuple (x, y, z) in meters.
    :return: A tuple of six joint angles (θ₁, θ₂, θ₃, θ₄, θ₅, θ₆) in radians.
    """
    import math

    # Unpack target TCP position.
    p_x, p_y, p_z = p

    # --- Fixed Geometric Parameters ---
    # Fixed offsets computed from URDF:
    #   Link 2: +0.13585 in Y
    #   Link 3: -0.1197 in Y and +0.425 in Z
    #   Links 5 + TCP: +0.093 + 0.0823 in Y
    # Constant offset in the arm's plane (local Y) becomes:
    const_y = 0.13585 - 0.1197 + (0.093 + 0.0823)  # = 0.19145

    # Planar arm lengths (in meters):
    L2 = 0.425
    L3 = 0.39225 + 0.09465  # = 0.4869

    # --- Decouple kinematics: Solve for base rotation (θ₁) ---
    # The projection of the target in the XY plane:
    R_xy = math.sqrt(p_x**2 + p_y**2)
    # Since R_xy² = r² + const_y², solve for effective "reach" r:
    r = math.sqrt(R_xy**2 - const_y**2)

    # Base joint θ₁ aligns the arm such that rotating [r, const_y] gives the (p_x, p_y) position.
    theta1 = math.atan2(p_y, p_x) - math.atan2(const_y, r)

    # --- Solve the planar 2R inverse kinematics (for joints θ₂ and θ₃) ---
    # Define the distance from the (r, p_z) point to the base of the arm:
    K = math.sqrt(r**2 + p_z**2)
    # Using the cosine law: D = (K² - L2² - L3²) / (2 * L2 * L3)
    D = (K**2 - L2**2 - L3**2) / (2 * L2 * L3)
    # Clamp D to the valid range due to numerical issues:
    D = max(min(D, 1.0), -1.0)
    # Solve for θ₃:
    theta3 = math.atan2(math.sqrt(max(1 - D**2, 0)), D)
    # Auxiliary angle to help solve for θ₂:
    beta = math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    theta2 = math.atan2(r, p_z) - beta

    # --- Choose the wrist joints to yield no additional orientation offset ---
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)