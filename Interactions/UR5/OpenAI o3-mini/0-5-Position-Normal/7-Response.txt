def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of a 6-DOF serial manipulator.
    The robot geometry is defined by:
        • Revolute 1: translation [0, 0, 0], axis Z.
        • Revolute 2: translation [0, 0.13585, 0], axis Y.
        • Revolute 3: translation [0, -0.1197, 0.425], axis Y.
        • Revolute 4: translation [0, 0, 0.39225], axis Y.
        • Revolute 5: translation [0, 0.093, 0], axis Z.
        • Revolute 6: translation [0, 0, 0.09465], axis Y.
        • TCP: translation [0, 0.0823, 0] with an orientation offset.
    
    The forward kinematics shows that when the wrist joints (θ₄, θ₅, θ₆) are set to zero,
    the TCP position is given by a decoupling between a base rotation and a planar 2R arm.
    
    Key parameters computed from the URDF:
      - A constant Y-offset from the translations: 
            const_y = 0.13585 - 0.1197 + (0.093 + 0.0823) = 0.19145 m.
      - The planar arm link lengths:
            L2 = 0.425 m      (from Revolute 3’s z-offset)
            L3 = 0.39225 + 0.09465 = 0.4869 m  (combined translation from Revolute 4 and Revolute 6)
    
    The strategy is as follows:
      1. In the XY plane, the TCP is obtained by rotating the vector [r, const_y] by θ₁, so:
             [pₓ, p_y] = Rz(θ₁) · [r, const_y]    →    r = sqrt(pₓ² + p_y² - const_y²)
         and
             θ₁ = atan2(p_y, pₓ) - atan2(const_y, r)
    
      2. The planar 2R arm (in the (r, p_z) plane) then satisfies:
             r  = L2 sin(θ₂) + L3 sin(θ₂+θ₃)
             p_z = L2 cos(θ₂) + L3 cos(θ₂+θ₃)
         a solution for which is:
             K = sqrt(r² + p_z²)
             D = (K² - L2² - L3²) / (2*L2*L3)
             θ₃ = atan2(sqrt(1 - D²), D)
             β = atan2(L3 sin(θ₃), L2 + L3 cos(θ₃))
             θ₂ = atan2(r, p_z) - β
             
      3. By design, the wrist joints (θ₄, θ₅, θ₆) are set to 0.
    
    Assumes all targets are reachable.
    
    :param p: The target TCP position (x, y, z) in meters.
    :return: A tuple of joint angles (θ₁, θ₂, θ₃, θ₄, θ₅, θ₆) in radians.
    """
    import math

    # Unpack target TCP position.
    p_x, p_y, p_z = p

    # Fixed offsets from the robot geometry.
    const_y = 0.13585 - 0.1197 + (0.093 + 0.0823)  # = 0.19145 m
    L2 = 0.425                                  # link length for the 2R arm (m)
    L3 = 0.39225 + 0.09465                       # = 0.4869 m

    # Compute the projection in the XY plane.
    R_xy = math.sqrt(p_x**2 + p_y**2)
    # Compute effective reach r in the arm plane (note: R_xy^2 = r^2 + const_y^2).
    r = math.sqrt(max(R_xy**2 - const_y**2, 0))
    
    # Solve for base rotation θ₁.
    theta1 = math.atan2(p_y, p_x) - math.atan2(const_y, r)

    # Solve the 2R planar inverse kinematics for (θ₂, θ₃)
    K = math.sqrt(r**2 + p_z**2)
    D = (K**2 - L2**2 - L3**2) / (2 * L2 * L3)
    # Clamp D to the valid range [-1, 1] to avoid numerical issues.
    D = max(min(D, 1.0), -1.0)
    theta3 = math.atan2(math.sqrt(max(1 - D**2, 0)), D)
    beta = math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    theta2 = math.atan2(r, p_z) - beta

    # Set wrist joints to zero.
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)