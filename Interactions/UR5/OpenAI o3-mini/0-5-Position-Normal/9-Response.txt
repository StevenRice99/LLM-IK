def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of a 6-DOF serial manipulator,
    reaching a desired TCP position "p" = (x, y, z).
    
    The robot is defined by:
      - Revolute 1: position [0, 0, 0], rotation about Z.
      - Revolute 2: position [0, 0.13585, 0], rotation about Y.
      - Revolute 3: position [0, -0.1197, 0.425], rotation about Y.
      - Revolute 4: position [0, 0, 0.39225], rotation about Y.
      - Revolute 5: position [0, 0.093, 0], rotation about Z.
      - Revolute 6: position [0, 0, 0.09465], rotation about Y.
      - TCP: position [0, 0.0823, 0] with an orientation offset.
    
    By inspecting the forward kinematics (when the wrist joints are set to zero) we can decouple the problem:
      1. A base rotation (θ1) aligns the (x,y) target by "undoing" a fixed offset.
         The fixed offset in the arm’s plane comes from:
             const_y = 0.13585  (from Revolute 2)
                      - 0.1197   (from Revolute 3)
                      + (0.093 + 0.0823)  (from Revolute 5 and TCP)
                    = 0.19145 m.
         If the (x,y) target has polar radius R_xy = sqrt(x²+y²), then the corresponding internal 
         coordinate is given by a vector [r, const_y] rotated by θ1, with:
             r = sqrt(R_xy² - const_y²)
         and
             θ1 = atan2(y, x) - atan2(const_y, r).
    
      2. The remaining two joints (θ2 and θ3) solve a planar 2R inverse kinematics problem in the plane
         defined by (r, p_z) where:
             r = L2 sin(θ2) + L3 sin(θ2+θ3)
             p_z = L2 cos(θ2) + L3 cos(θ2+θ3)
         Here, the effective link lengths are:
             L2 = 0.425 m   (from Revolute 3's z-offset)
             L3 = 0.39225 + 0.09465 = 0.4869 m  (from Revolute 4 and Revolute 6)
         Define K = sqrt(r^2 + p_z^2) and compute:
             D = (K^2 - L2^2 - L3^2) / (2*L2*L3)
         Then a typical solution is,
             θ3 = atan2(√(1-D²), D)
             β  = atan2(L3*sin(θ3), L2+L3*cos(θ3))
             θ2 = atan2(r, p_z) - β.
    
      3. With this choice the wrist joints (θ4, θ5, θ6) are set to zero.
    
    Assumes all target positions are reachable.
    
    :param p: The desired TCP position as a tuple (x, y, z).
    :return: A tuple (θ1, θ2, θ3, θ4, θ5, θ6) representing the joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    p_x, p_y, p_z = p

    # Fixed offset in the arm plane from the translations:
    # 0.13585 (Revolute 2) - 0.1197 (Revolute 3) + (0.093 + 0.0823) (Revolute 5 and TCP)
    const_y = 0.19145

    # Planar 2R arm link lengths (in meters):
    L2 = 0.425
    L3 = 0.39225 + 0.09465  # which equals 0.4869

    # ---------------------------------------------------------------------------
    # Step 1. Solve for the base joint θ1.
    #
    # The (x,y) target must satisfy:
    #     [p_x, p_y] = Rz(θ1) · [r, const_y]
    # with R_xy = sqrt(p_x^2 + p_y^2). Because:
    #      R_xy^2 = r^2 + const_y^2,
    # we compute:
    R_xy = math.sqrt(p_x**2 + p_y**2)
    r = math.sqrt(max(R_xy**2 - const_y**2, 0))
    theta1 = math.atan2(p_y, p_x) - math.atan2(const_y, r)

    # ---------------------------------------------------------------------------
    # Step 2. Solve the planar 2R inverse kinematics for joints θ2 and θ3.
    #
    # In the (r, p_z) plane, the end-effector must satisfy:
    #     r   = L2 sin(θ2) + L3 sin(θ2+θ3)
    #     p_z = L2 cos(θ2) + L3 cos(θ2+θ3)
    K = math.sqrt(r**2 + p_z**2)
    D = (K**2 - L2**2 - L3**2) / (2 * L2 * L3)
    # Clamp D to be within its valid range to account for numerical precision.
    D = max(min(D, 1.0), -1.0)
    theta3 = math.atan2(math.sqrt(max(1 - D**2, 0)), D)
    beta = math.atan2(L3 * math.sin(theta3), L2 + L3 * math.cos(theta3))
    theta2 = math.atan2(r, p_z) - beta

    # ---------------------------------------------------------------------------
    # Step 3. Set the wrist joints to zero.
    theta4 = 0.0
    theta5 = 0.0
    theta6 = 0.0

    return (theta1, theta2, theta3, theta4, theta5, theta6)