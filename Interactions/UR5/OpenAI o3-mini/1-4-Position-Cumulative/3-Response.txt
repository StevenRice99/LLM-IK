We can show that—with the fixed offsets between joints—the TCP‐position depends only on the yaw (joint‑1) angle. In fact, writing out the forward kinematics, one finds that 

  p_TCP = R_y(θ₁)·[0, –0.1197, 0.81725] + [0, 0.093, 0] + [0, 0, 0.09465]

so that in “world” coordinates

  x = 0.81725·sin(θ₁)
  y = –0.1197 + 0.093 = –0.0267            (“always”)
  z = 0.81725·cos(θ₁) + 0.09465

It is straightforward (and you can check using the forward kinematics function) to see that for any reachable target p the y–coordinate must equal –0.0267 and that the only degree‐of–freedom that “moves” p is θ₁, with

  θ₁ = atan2(x, z – 0.09465)

The other joints (θ₂ and θ₃) affect only the end–effector orientation since their “origins” are given by fixed offsets (their rotations occur about axes that pass through those origins) while the fourth joint (a rotation about Z) only “twists” a wrist (whose translation [0, 0.093, 0] plus the TCP offset [0, 0, 0.09465] yields the above p_TCP when θ₄ = 0). (In our closed–form solution we choose the “free” angles to be zero.)

Thus, one acceptable inverse kinematics solution for position (assuming that any target provided is on the (x,z) “curve” defined by 
  x² + (z – 0.09465)² = (0.81725)² 
and y = –0.0267)
is to set

  θ₁ = atan2(x, z – 0.09465)
  θ₂ = 0 
  θ₃ = 0 
  θ₄ = 0

Below is the complete Python function implementing this analytical closed–form solution. (No extraneous testing code is included.)

--------------------------------------------------

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" (TCP position).
    Note:
      Because of the fixed link translations the TCP position is
      given by:
      
         p_TCP = R_y(θ₁)*[0, -0.1197, 0.81725] + [0, 0.093, 0] + [0, 0, 0.09465]
      
      which yields (in components):
      
         x = 0.81725*sin(θ₁)
         y = -0.1197 + 0.093 = -0.0267
         z = 0.81725*cos(θ₁) + 0.09465

      In other words, the TCP can only lie on the curve defined by
         x² + (z - 0.09465)² = (0.81725)²   and   y = -0.0267.
         
      Therefore, the only joint entering the TCP position is θ₁, given by:
      
         θ₁ = atan2(x, z - 0.09465)

      The remaining joints affect only orientation; here we choose:
      
         θ₂ = 0,  θ₃ = 0,  θ₄ = 0.
      
      (All angles are expressed in radians.)
      
    :param p: The desired TCP position [x, y, z].
    :return: A 4-tuple containing the joint values (θ₁, θ₂, θ₃, θ₄).
    """
    import math
    x, y, z = p
    # For the TCP to be reachable by this structure the y-coordinate must equal -0.0267.
    # (We assume reachable targets; no error checking is performed.)
    theta1 = math.atan2(x, z - 0.09465)
    theta2 = 0.0
    theta3 = 0.0
    theta4 = 0.0
    return (theta1, theta2, theta3, theta4)

--------------------------------------------------

When you submit a target p (which must satisfy y = –0.0267 and lie on
  x² + (z – 0.09465)² = (0.81725)²),
this method returns the unique set of joint values (in radians) that yield
the TCP position as given by the forward kinematics output.

This solution uses the fact that (by the URDF–defined offsets) only θ₁ impacts p,
with the other joints being “free” (set here to zero) once position is matched.