def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed‐form analytical inverse kinematics solution for a 4-DOF serial manipulator,
    given a target TCP position p = (x, y, z) in world coordinates.
    
    The kinematic chain is:
      • Revolute 1 at the base (position [0,0,0], axis Y) rotates by q1.
      • A fixed translation T2 = [0, -0.1197, 0.425] moves us to Revolute 2.
      • Revolute 2 (axis Y) rotates by q2.
      • A fixed translation T3 = [0, 0, 0.39225] moves us to Revolute 3.
      • Revolute 3 (axis Y) rotates by q3.
      • A fixed translation T4 = [0, 0.093, 0] moves us to Revolute 4.
      • Revolute 4 (axis Z) rotates by q4.
      • A fixed translation T5 = [0, 0, 0.09465] brings us to the TCP.
      
    To decouple the IK problem we note that:
      1. q1 rotates about Y; its value is given by q1 = atan2(x, z). Rotating the target by -q1
         brings it to a plane with zero x–component.
      2. In the rotated frame the target becomes p' = (0, y, r) where r = sqrt(x²+z²).
         Next, subtract the fixed offset from the base to joint2:
             p_eff = p' - [0, -0.1197, 0.425] = (0, y+0.1197, r - 0.425).
         For a reachable target the effective y–coordinate will be y + 0.1197 = -0.0267 + 0.1197 = 0.093.
      3. In the remaining planar (y–z) sub-chain the translations are:
             • From Revolute 2 to Revolute 3: T3 = [0, 0, L] with L = 0.39225.
             • From Revolute 4 to TCP: T5 = [0, 0, l] with l = 0.09465.
         (Note: The translation T4 = [0, 0.093, 0] is “built into” the constant y–value.)
         Analysis of the forward chain shows that in the rotated frame the z–coordinate of the TCP is
             p'_z = 0.425 + sqrt( L² + 2*L*l*cos(q3) + l² ).
         Equating this with r = sqrt(x²+z²) we deduce that:
             sqrt( L² + 2*L*l*cos(q3) + l² ) = r - 0.425.
         Squaring both sides and solving for cos(q3) then yields:
             cos(q3) = [ (r - 0.425)² - L² - l² ] / (2*L*l ).
         We set q3 = acos( cos(q3) ) (after clamping for numerical accuracy).
      4. The requirement that the rotated chain’s x–component vanish
             (i.e. the result of the rotation by q2) forces
             tan(q2) = - [l*sin(q3)] / [L + l*cos(q3)],
         so that q2 = atan2(-l*sin(q3), L + l*cos(q3)).
      5. Joint 4 does not affect TCP position (only orientation), so we set q4 = 0.
    
    This function assumes that the target p is reachable.
    
    :param p: The desired TCP position (x, y, z) in world coordinates.
    :return: A tuple (q1, q2, q3, q4) of joint angles (in radians) that achieve the target position.
    """
    import math

    # Unpack target coordinates.
    x, y, z = p

    # (1) Compute the base rotation q1 (about Y).
    q1 = math.atan2(x, z)

    # (2) In the rotated frame the target's x-coordinate becomes zero.
    #     Compute r = sqrt(x^2 + z^2); then the rotated target is p' = (0, y, r).
    r = math.sqrt(x * x + z * z)
    
    # (3) Remove the fixed offset from the base to the second joint.
    #     The fixed offset is A = [0, -0.1197, 0.425], so:
    #         p_eff = p' - A = (0, y + 0.1197, r - 0.425).
    #     For a reachable target, we expect y + 0.1197 == 0.093.
    #     (We proceed under this assumption.)
    
    # (4) Solve for q3 using the cosine law in the effective (y-z) planar chain.
    #     Here, L = 0.39225 (translation from Revolute 2 to Revolute 3) and 
    #           l = 0.09465 (translation from Revolute 4 to TCP).
    L = 0.39225
    l = 0.09465
    # From forward kinematics, the effective z–coordinate is:
    #     p'_z = 0.425 + sqrt(L^2 + 2*L*l*cos(q3) + l^2)
    # Equate this with r => sqrt(L^2 + 2*L*l*cos(q3) + l^2) = r - 0.425.
    # Squaring both sides gives:
    #     L^2 + 2*L*l*cos(q3) + l^2 = (r - 0.425)**2
    # Solve for cos(q3):
    cos_q3 = ((r - 0.425)**2 - L**2 - l**2) / (2.0 * L * l)
    # Clamp the value to the valid range to account for numerical errors.
    cos_q3 = max(-1.0, min(1.0, cos_q3))
    q3 = math.acos(cos_q3)

    # (5) Determine q2 from the vanishing of the effective x–component.
    #     This requirement yields:
    #         tan(q2) = - (l*sin(q3)) / (L + l*cos(q3))
    q2 = math.atan2(-l * math.sin(q3), L + l * math.cos(q3))
    
    # (6) For a position-only solution, set q4 = 0.
    q4 = 0.0

    return (q1, q2, q3, q4)