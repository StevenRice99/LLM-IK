Below is one valid closed‐form analytical solution. In our approach we “back‐out” the effective target for the “arm” (joints 1–3) by subtracting the constant TCP offset along z (0.09465) and the link‑4 translation along y (0.093). (Because joints 1–3 all rotate about Y their effect is to “planarize” the problem in the x–z plane; note that the y component of the TCP is fixed by the design.) In our solution we then compute a two‑link inverse kinematics (with link lengths 0.425 and 0.39225) with an extra “cross‐product” test used to choose the sign of joint 2. (Joint 3 is “redundant” for position only so we set it to zero while joint 4 does not affect the TCP position because its TCP offset lies along the invariant z‑axis of frame 4.) 

For example, if the given TCP is p = [x, y, z] then we define

  • z_eff = z – 0.09465          (removes the TCP offset along z)
  • y_eff = y – 0.093            (removes the link‑4 offset along y; note that the IK of joints 1–3 uses only x and z)

Then letting d = √(x² + z_eff²) the cosine law gives

  cos(theta2) = (d² – L1² – L2²) / (2 L1 L2)

(with L1 = 0.425 and L2 = 0.39225). We adjust the sign of theta2 by checking the “cross–product”
  cross = x * (L1 + L2 cos(theta2)) – z_eff * (L2 sin(theta2))
and if cross < 0 we flip the sign so that the elbow is chosen appropriately. Also, we set
  theta1 = atan2(x, z_eff) – atan2(L2 sin(theta2), L1 + L2 cos(theta2))
while we choose theta3 = 0 and theta4 = 0 (since joint 4 rotates about the TCP’s z–axis so its offset [0, 0, 0.09465] remains unchanged regardless of theta4).

The complete code (without any testing code) is provided below.

--------------------------------------------------

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach TCP position "p".
    The kinematic chain is as follows:
      - Revolute 1 at [0,0,0] rotates about Y.
      - Revolute 2 is offset by [0, -0.1197, 0.425] from link 1 and rotates about Y.
      - Revolute 3 is offset by [0, 0, 0.39225] from link 2 and rotates about Y.
      - Revolute 4 is offset by [0, 0.093, 0] from link 3 and rotates about Z.
      - The TCP is offset by [0, 0, 0.09465] from link 4.
    For position IK only the first three joints affect the x–z coordinates.
    We “remove” the constant offsets so that the two-link (L1, L2)
    inverse kinematics (with L1 = 0.425 and L2 = 0.39225) can be applied.
    
    :param p: The desired TCP position [x, y, z].
    :return: A tuple (theta1, theta2, theta3, theta4) of joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # Remove the TCP offset (translation from revolute-4 to TCP) along z.
    z_eff = z - 0.09465
    # Remove the link-4 translation along y so that (x, z_eff) is the effective target for joints 1-3.
    # (For zero joint angles the TCP y becomes -0.0267, so subtracting 0.093 gives -0.1197.)
    y_eff = y - 0.093
    
    # For these joints the IK is decoupled into a 2D problem in the x-z plane.
    d = math.sqrt(x ** 2 + z_eff ** 2)
    L1 = 0.425
    L2 = 0.39225

    # Compute joint 2 angle using the cosine law.
    cos_theta2 = (d ** 2 - L1 ** 2 - L2 ** 2) / (2 * L1 * L2)
    # Clamp to the valid range [-1, 1] to account for floating point errors.
    cos_theta2 = max(min(cos_theta2, 1), -1)
    theta2 = math.acos(cos_theta2)

    # Use a cross–product test to pick the elbow configuration.
    cross = x * (L1 + L2 * cos_theta2) - z_eff * (L2 * math.sin(theta2))
    if cross < 0:
        theta2 = -theta2

    # Compute joint 1 using geometric relations.
    alpha = math.atan2(x, z_eff)
    beta = math.atan2(L2 * math.sin(theta2), L1 + L2 * math.cos(theta2))
    theta1 = alpha - beta

    # For position-only inverse kinematics, we may choose theta3 = 0.
    theta3 = 0

    # Joint 4 rotates about Z; since the TCP offset [0, 0, 0.09465] lies along the z-axis,
    # theta4 does not affect the TCP position. We choose it to be zero.
    theta4 = 0

    return (theta1, theta2, theta3, theta4)

--------------------------------------------------

This solution first “backs out” the effective (x, z) target for joints 1–3 by subtracting the known constant offsets, then uses a two-link inverse kinematics solution (with a cross–product check) to find theta1 and theta2. Finally, theta3 and theta4 are set to zero since they do not affect TCP position.