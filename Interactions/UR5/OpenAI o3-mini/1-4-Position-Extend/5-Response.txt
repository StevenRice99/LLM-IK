def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach TCP position "p". The kinematic chain is:
      - Revolute 1 at [0, 0, 0] rotates about Y.
      - Revolute 2 is offset by [0, -0.1197, 0.425] from link 1 and rotates about Y.
      - Revolute 3 is offset by [0, 0, 0.39225] from link 2 and rotates about Y.
      - Revolute 4 is offset by [0, 0.093, 0] from link 3 and rotates about Z.
      - The TCP is offset by [0, 0, 0.09465] from link 4.
      
    For position inverse kinematics (IK) the effect of joints 1–3 is to place the “wrist center”
    so that, when the constant offsets (TCP along z and link‑4 along y) are removed, the remaining 
    two‐link (L1, L2) planar geometry in the x–z plane can be solved. The parameters are:
      L1 = 0.425 and L2 = 0.39225.
      
    :param p: The desired TCP position [x, y, z].
    :return: A tuple (theta1, theta2, theta3, theta4) of joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # Remove the constant offsets:
    # - Remove TCP offset along z: 0.09465 (TCP is displaced along z from joint 4)
    # - Remove link‑4 offset along y: 0.093 (joint 4 is displaced along y from joint 3)
    # These adjustments yield the effective target for joints 1–3.
    z_eff = z - 0.09465
    # Although the IK for joints 1–3 acts in the x–z plane (since their rotations about Y affect x and z),
    # we remove the link‑4 offset from y for completeness.
    y_eff = y - 0.093  
    x_eff = x  # x remains unchanged

    # Compute the distance in the x–z plane from the base to the effective position.
    d = math.sqrt(x_eff**2 + z_eff**2)

    # Define link lengths for the two-link sub-chain.
    L1 = 0.425
    L2 = 0.39225

    # Compute the cosine of joint 2 (elbow angle) using the cosine law.
    cos_theta2 = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_theta2 to the valid range ([-1, 1]) to mitigate numerical errors.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)

    # Use a cross–product–like test to choose the proper elbow configuration.
    # This test compares contributions along the x and z directions.
    cross = x_eff * (L1 + L2 * cos_theta2) - z_eff * (L2 * math.sin(theta2))
    if cross < 0:
        theta2 = -theta2

    # Compute joint 1 using geometric relations.
    alpha = math.atan2(x_eff, z_eff)
    beta = math.atan2(L2 * math.sin(theta2), L1 + L2 * cos_theta2)
    theta1 = alpha - beta

    # For position IK, joint 3 is redundant. We set theta3 = 0.
    theta3 = 0

    # Joint 4 rotates about Z. Its translation (TCP offset) lies along the Z‐axis of frame 4,
    # so theta4 does not affect TCP position. We choose theta4 = 0.
    theta4 = 0

    return (theta1, theta2, theta3, theta4)