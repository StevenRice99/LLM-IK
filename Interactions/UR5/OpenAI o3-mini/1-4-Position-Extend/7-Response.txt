def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4) required to reach the TCP position p.
    The kinematic chain is:
      - Revolute 1 at [0, 0, 0] rotates about Y.
      - Revolute 2, at [0, -0.1197, 0.425] relative to link 1, rotates about Y.
      - Revolute 3, at [0, 0, 0.39225] relative to link 2, rotates about Y.
      - Revolute 4, at [0, 0.093, 0] relative to link 3, rotates about Z.
      - TCP, at [0, 0, 0.09465] relative to link 4.
    
    For position inverse kinematics the main effect comes from joints 1–3. To solve this decoupled problem,
    we remove the constant offsets contributed by revolute 4 and the TCP. Specifically:
      • The TCP is offset from link 4 by [0, 0, 0.09465] along the Z-axis.
      • Link 4 is offset from link 3 by [0, 0.093, 0] along the Y-axis.
    
    These offsets are removed to yield an effective target frame where the first three joints perform
    a planar two-link solution in the x–z plane. The two-link geometry uses:
         L1 = 0.425 and L2 = 0.39225.
    
    :param p: TCP position [x, y, z] in the base frame.
    :return: Tuple of joint angles (theta1, theta2, theta3, theta4) in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # Remove the constant offsets:
    # 1. Remove the TCP offset along z: [0, 0, 0.09465].
    z_eff = z - 0.09465

    # 2. Remove the link-4 offset along y: [0, 0.093, 0].
    # Although joints 1–3 affect only the x–z plane (due to Y-axis rotations),
    # we subtract the y-offset to align with the base configuration.
    y_eff = y - 0.093  # (This value is not used in the x–z IK but verifies consistency.)

    # For joints 1–3, the IK reduces to a planar two-link problem using (x, z_eff).
    # Compute the planar distance from the base axis to the effective target.
    d = math.sqrt(x**2 + z_eff**2)

    # Define the lengths of the two sub-chain links.
    L1 = 0.425    # Length from revolute 1 to revolute 2.
    L2 = 0.39225  # Length from revolute 2 to revolute 3.

    # Compute the cosine of joint angle 2 using the cosine law.
    cos_theta2 = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_theta2 to account for any possible floating-point error.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)

    # Use a cross–product test to choose between the two possible elbow configurations.
    # Compute a term analogous to a determinant that differentiates the two solutions.
    cross = x * (L1 + L2 * cos_theta2) - z_eff * (L2 * math.sin(theta2))
    if cross < 0:
        theta2 = -theta2

    # Compute joint 1 using geometric relations.
    # The effective angle toward the target is given by atan2(x, z_eff).
    # Subtract the contribution of the second link.
    theta1 = math.atan2(x, z_eff) - math.atan2(L2 * math.sin(theta2), L1 + L2 * cos_theta2)

    # For position-only inverse kinematics, joint 3 does not affect TCP location.
    theta3 = 0.0

    # Joint 4 rotates about Z. Since the TCP offset [0, 0, 0.09465] lies along the Z-axis,
    # theta4 does not alter the TCP location. We set it to zero.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)