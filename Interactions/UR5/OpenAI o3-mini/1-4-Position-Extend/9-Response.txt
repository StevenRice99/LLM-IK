def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4) required to position the TCP at p.
    The kinematic chain is as follows:
      - Revolute 1: position [0, 0, 0], rotation about Y.
      - Revolute 2: offset [0, -0.1197, 0.425] (from link 1), rotation about Y.
      - Revolute 3: offset [0, 0, 0.39225] (from link 2), rotation about Y.
      - Revolute 4: offset [0, 0.093, 0] (from link 3), rotation about Z.
      - TCP: offset [0, 0, 0.09465] (from link 4).
      
    For position-level inverse kinematics the only joints that affect the (x,z) placement of the TCP are joints 1–3.
    To solve the problem, we "remove" the constant offsets along z (TCP offset) and along y (link 4 offset) so that
    a planar, two-link solution (with L1 = 0.425 and L2 = 0.39225) can be used.

    The method:
      1. Subtract the TCP offset along z: z_eff = z - 0.09465.
      2. (Optionally subtract the link 4 y-offset: y_eff = y - 0.093.) Although joints 1–3 affect only x and z,
         we note this for completeness.
      3. Solve the two-link planar problem in the x–z plane:
             d = sqrt(x^2 + z_eff^2)
         and use the cosine law:
             cos(theta2) = (d^2 - L1^2 - L2^2) / (2 L1 L2)
         to compute theta2.
      4. Use a cross‐product test to select the proper elbow configuration.
      5. Compute theta1 from the effective target direction and the geometry.
      6. Set theta3 = 0 as it is redundant for position and choose theta4 = 0 (since its rotation about Z 
         does not affect the TCP position due to the TCP offset alignment).

    :param p: The desired TCP position as a tuple (x, y, z).
    :return: A tuple (theta1, theta2, theta3, theta4) with the joint angles in radians.
    """
    import math

    # Unpack target TCP position.
    x, y, z = p

    # Remove the constant offsets:
    # 1. Remove TCP offset along z.
    z_eff = z - 0.09465
    # 2. Remove link-4 offset along y (not used for the planar IK, but noted for the structure).
    # y_eff = y - 0.093   (This value does not affect the planar computation in the x-z plane.)

    # For joints 1–3, solve the planar IK using effective coordinates (x, z_eff).
    effective_x = x
    effective_z = z_eff

    # Compute the distance from the base to the effective target in the x-z plane.
    d = math.sqrt(effective_x**2 + effective_z**2)

    # Define the link lengths for the two-link sub-chain.
    L1 = 0.425    # From revolute 1 to revolute 2.
    L2 = 0.39225  # From revolute 2 to revolute 3.

    # Solve for theta2 using the cosine law.
    cos_theta2 = (d**2 - L1**2 - L2**2) / (2 * L1 * L2)
    # Clamp cos_theta2 to the valid range [-1,1] to handle numerical errors.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)

    # Use a cross–product–like test to select the correct elbow configuration.
    # The term below is analogous to the 2D cross product between the vector to the effective target and 
    # the intermediate vector (L1, L2*cos(theta2)) to pick the sign of theta2.
    if effective_x * (L1 + L2 * cos_theta2) - effective_z * (L2 * math.sin(theta2)) < 0:
        theta2 = -theta2

    # Compute theta1: the angle from the base to the effective target, corrected by the contribution of link L2.
    theta1 = math.atan2(effective_x, effective_z) - math.atan2(L2 * math.sin(theta2), L1 + L2 * cos_theta2)

    # For position IK, joint 3 is redundant (we choose theta3 = 0).
    theta3 = 0.0

    # Joint 4 rotates about Z; since the TCP offset [0, 0, 0.09465] lies along the Z-axis,
    # its rotation does not affect TCP position. Set theta4 = 0.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)