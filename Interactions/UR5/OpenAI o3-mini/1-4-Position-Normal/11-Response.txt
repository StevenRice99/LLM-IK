def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math

    # Unpack the desired TCP position.
    px, py, pz = p

    # Joint 1 rotates about Y to align the TCP target with the robot’s arm plane.
    # Here, j1 rotates such that the target’s projection in the XZ plane becomes aligned.
    j1 = math.atan2(px, pz)
    
    # In the rotated frame (arm plane), the effective horizontal distance is:
    R = math.sqrt(px**2 + pz**2)
    
    # The fixed translation from Joint 1 to Joint 2 along the Z-axis is 0.425 m.
    # Thus, the effective reach (L) that the remaining joints must cover is:
    L = R - 0.425

    # Effective link lengths in the planar (2-link) subsystem:
    # - A: link from Joint 2 to Joint 3 (0.39225 m).
    # - B: combined effect of Joint 4’s TCP translation (0.09465 m).
    A = 0.39225
    B = 0.09465

    # Use the law of cosines to solve for j3.
    cos_j3 = (L**2 - A**2 - B**2) / (2 * A * B)
    # Clamp cos_j3 to the valid range to account for numerical precision.
    cos_j3 = max(min(cos_j3, 1.0), -1.0)
    j3 = math.acos(cos_j3)
    
    # Solve for j2 by ensuring that no lateral offset exists in the arm plane.
    # The condition A*sin(j2) + B*sin(j2 + j3) = 0 leads directly to:
    j2 = -math.atan2(B * math.sin(j3), A + B * math.cos(j3))
    
    # Joint 4 does not influence the TCP position (its translation is along its Z-axis).
    j4 = 0.0

    return (j1, j2, j3, j4)