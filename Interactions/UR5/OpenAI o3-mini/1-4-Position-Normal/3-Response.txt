import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed‐form inverse kinematics solution for the 4 DOF manipulator
    that computes joint angles (in radians) to achieve a desired TCP position p.
    
    The kinematic chain is composed as follows (all distances in meters):
      • Joint1 (revolute about Y): no translation.
      • Joint2 (revolute about Y): translation [0, -0.1197, 0.425]
      • Joint3 (revolute about Y): translation [0, 0, 0.39225]
      • Joint4 (revolute about Z): translation [0, 0.093, 0]
      • TCP: translation [0, 0, 0.09465]
    
    Because joints 1–3 all rotate about Y, the first joint (j1) simply 
    rotates the “arm plane” about the vertical axis. The remaining joints
    produce a 2‐link planar arm in that plane. Notably, the vertical (Y) TCP coordinate 
    is fixed:
    
       y_TCP = -0.1197 + 0.093 = -0.0267
    
    Thus, we assume that any reachable target p has p[1] == -0.0267.
    
    The effective planar problem (in the rotated frame where the arm lies in the z–y plane)
    is then given by:
    
       TCP_z = 0.425 + 0.39225*cos(j2) + 0.09465*cos(j2+j3)
       TCP_x =        0.39225*sin(j2) + 0.09465*sin(j2+j3)   which must equal 0.
    
    We solve this as a standard two‐link planar inverse kinematics problem.
    The overall solution is chosen as:
      • j1 = atan2(p_x, p_z) (rotates the target into the arm’s plane)
      • Let R = sqrt(p_x^2 + p_z^2) be the distance in the horizontal plane.
        Then, once the base rotation j1 has aligned the arm’s plane with the target,
        the effective distance along the arm’s traveling axis is:
             L = R - 0.425
      • Treating 0.39225 m and 0.09465 m as the effective “link lengths” (A and B),
        we have the law-of-cosines:
             cos(j3) = (L^2 - A^2 - B^2) / (2*A*B)
        and we choose:
             j3 = acos(cos(j3))
      • Then, the equation for j2 comes from:
             A*cos(j2) + B*cos(j2+j3) = L
             A*sin(j2) + B*sin(j2+j3) = 0
        which leads (for the elbow configuration chosen) to:
             j2 = -atan2(B*sin(j3), A + B*cos(j3))
      • Joint 4 does not affect the position because the TCP offset [0,0,0.09465]
        is aligned with the joint’s Z axis (and rotation about Z leaves it invariant).
        Thus we choose j4 = 0.
    
    Note: This inverse solution assumes that the target p is reachable.
    
    :param p: Desired TCP position [x, y, z] (meters). p[1] should equal -0.0267.
    :return: Tuple of joint angles (j1, j2, j3, j4) in radians.
    """
    # Extract target coordinates.
    px, py, pz = p

    # Compute joint 1: rotate the arm's plane so that the target lies in the plane (with zero "x" in the rotated frame).
    # Note: atan2(px, pz) rotates the p vector about Y so that its new x is zero.
    j1 = math.atan2(px, pz)
    
    # In the rotated frame, the effective horizontal distance (R) is:
    R = math.sqrt(px**2 + pz**2)
    
    # The kinematic chain gives a constant offset along the z-axis from joint 1 to joint 2.
    # Thus, the remaining “reach” needed from joints 2 and 3 is:
    L = R - 0.425

    # Define effective link lengths (from the translations in joints 3 and TCP)
    A = 0.39225  # from joint 2 -> joint 3 translation magnitude along z in the arm’s plane
    B = 0.09465  # combined effect of the revolute joint 4 offset (translation from joint 4 to TCP)
    
    # Solve for joint 3 using the law of cosines:
    cos_j3 = (L**2 - A**2 - B**2) / (2 * A * B)
    # Clamp to valid range [-1, 1] to account for numerical issues.
    cos_j3 = max(min(cos_j3, 1.0), -1.0)
    j3 = math.acos(cos_j3)
    
    # Solve for joint 2. The sine condition (A*sin(j2) + B*sin(j2+j3)=0) is satisfied
    # if we choose:
    j2 = -math.atan2(B * math.sin(j3), A + B * math.cos(j3))
    
    # Since the TCP position is independent of joint 4, we set it arbitrarily to zero.
    j4 = 0.0

    return (j1, j2, j3, j4)