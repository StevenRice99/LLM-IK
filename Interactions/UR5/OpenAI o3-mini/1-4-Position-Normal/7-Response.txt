def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed‐form inverse kinematics solution for a 4 DOF serial manipulator.
    
    The kinematic chain is as follows:
      • Joint 1 (revolute about Y): Origin [0, 0, 0].
      • Joint 2 (revolute about Y): Translation [0, -0.1197, 0.425] from Joint 1.
      • Joint 3 (revolute about Y): Translation [0, 0, 0.39225] from Joint 2.
      • Joint 4 (revolute about Z): Translation [0, 0.093, 0] from Joint 3.
      • TCP: Translation [0, 0, 0.09465] from Joint 4.
    
    Note that because of the fixed translations in the Y direction:
         y_TCP = -0.1197 + 0.093 = -0.0267
    any reachable target will have its Y coordinate equal to -0.0267.
    
    The solution strategy is to decouple the 3-dof positioning into:
      1. A base (Joint 1) rotation about Y that aligns the target with the symmetry plane of the arm.
         We choose j1 = atan2(px, pz), where (px,pz) is the target projection on the XZ plane.
      2. A planar (2-link) inverse kinematics for joints 2 and 3.
         In the rotated frame, the effective (horizontal) distance to the target is R = sqrt(px^2+pz^2).
         Joint 2 sits at an offset of 0.425 m along the Z-axis, so the remaining reach is L = R - 0.425.
         The effective link lengths are:
              A = 0.39225   (from Joint 2 to Joint 3)
              B = 0.09465   (from Joint 4 offset plus TCP translation)
         By the law of cosines:
              cos(j3) = (L^2 - A^2 - B^2) / (2*A*B)
         and we choose the elbow-up solution:
              j3 = acos(clamped_value)
         Then, enforcing that the second joint directs the arm along L, we satisfy:
             A*sin(j2) + B*sin(j2+j3) = 0,
         which leads to:
              j2 = -atan2(B*sin(j3), A + B*cos(j3))
      3. Joint 4 does not affect the TCP position in this chain (its translation is along its Z-axis),
         so we set j4 = 0.
    
    This inverse solution assumes the target p = [px, py, pz] is reachable and that p[1] == -0.0267.
    
    :param p: Desired TCP position as a tuple (px, py, pz).
    :return: Tuple of joint angles (j1, j2, j3, j4) in radians.
    """
    import math

    # Extract target coordinates.
    px, py, pz = p
    
    # Compute the base rotation (Joint 1) to align the target with the arm's plane.
    j1 = math.atan2(px, pz)
    
    # In the rotated (XZ) plane, compute the distance from the origin.
    R = math.sqrt(px**2 + pz**2)
    
    # The offset from Joint 1 to Joint 2 is along z by 0.425 m.
    # Effective reach required from the two-link planar arm:
    L = R - 0.425
    
    # Define the effective link lengths for the planar subsystem.
    A = 0.39225   # Link from Joint 2 to Joint 3.
    B = 0.09465   # Combined offset from Joint 4 and TCP.
    
    # Law of cosines to compute j3:
    # Clamp the cosine value for numerical safety.
    cos_j3 = (L**2 - A**2 - B**2) / (2 * A * B)
    cos_j3 = max(min(cos_j3, 1.0), -1.0)
    j3 = math.acos(cos_j3)
    
    # Compute j2 such that:
    # A*sin(j2) + B*sin(j2+j3) = 0  -->  j2 = -atan2(B*sin(j3), A + B*cos(j3))
    j2 = -math.atan2(B * math.sin(j3), A + B * math.cos(j3))
    
    # Joint 4 does not affect the position, therefore choose j4 = 0.
    j4 = 0.0
    
    return (j1, j2, j3, j4)