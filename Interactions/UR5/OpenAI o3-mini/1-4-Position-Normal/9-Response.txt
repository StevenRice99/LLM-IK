def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed‐form inverse kinematics solution for a 4 DOF serial manipulator.
    
    The manipulator consists of:
      • Joint 1 (revolute about Y) at the origin.
      • Joint 2 (revolute about Y) with translation [0, -0.1197, 0.425] from Joint 1.
      • Joint 3 (revolute about Y) with translation [0, 0, 0.39225] from Joint 2.
      • Joint 4 (revolute about Z) with translation [0, 0.093, 0] from Joint 3.
      • TCP with translation [0, 0, 0.09465] from Joint 4.
    
    Note:
      Due to the fixed translations in the Y direction, the TCP’s Y coordinate is always:
          y_TCP = -0.1197 + 0.093 = -0.0267.
      It is assumed that any input target p = (px, py, pz) satisfies p[1] == -0.0267.
    
    The overall strategy is as follows:
      1. Joint 1 rotates around Y to align the target with the plane of the arm.
         In world coordinates, we set:
             j1 = atan2(px, pz).
      
      2. In the rotated plane, the effective distance along the arm’s extension is:
             R = sqrt(px^2 + pz^2)
         and due to an offset of 0.425 meters (from Joint 1 to Joint 2 along z),
         the planar reach required from the remaining two links becomes:
             L = R - 0.425.
      
      3. The arm then behaves like a 2-link planar manipulator with link lengths:
             A = 0.39225   (from Joint 2 to Joint 3) and
             B = 0.09465   (from Joint 4/TCP, where Joint 4’s rotation doesn’t affect position).
         Using the law of cosines:
             cos(j3) = (L^2 - A^2 - B^2) / (2*A*B),
         and choosing the elbow-up solution:
             j3 = acos(clamped_cos_j3).
      
      4. The angle j2 is determined by enforcing that the lateral (planar) offset vanishes:
             A*sin(j2) + B*sin(j2+j3) = 0,
         which can be solved as:
             j2 = -atan2(B*sin(j3), A + B*cos(j3)).
      
      5. Joint 4 does not affect the TCP’s position (its translation is aligned with its Z‐axis),
         so we set j4 = 0.
    
    :param p: Desired TCP position as a tuple (px, py, pz) in meters.
    :return: Tuple of joint angles (j1, j2, j3, j4) in radians.
    """
    import math

    # Unpack the target TCP coordinates.
    px, py, pz = p

    # Joint 1 rotates to align the TCP target with the manipulator’s arm plane.
    j1 = math.atan2(px, pz)

    # Compute the horizontal distance of the target from the base along the XZ plane.
    R = math.sqrt(px**2 + pz**2)

    # Offset along z from the base to Joint 2.
    offset = 0.425

    # The effective reach (length that joints 2 and 3 must cover) is:
    L = R - offset

    # Define the effective link lengths for the planar subsystem.
    A = 0.39225   # Link from Joint 2 to Joint 3.
    B = 0.09465   # Link from Joint 4/TCP (position-affecting part).

    # Solve for Joint 3 using the law of cosines.
    cos_j3 = (L**2 - A**2 - B**2) / (2 * A * B)
    # Clamp the cosine value to the valid range [-1, 1] to avoid numerical errors.
    cos_j3 = max(min(cos_j3, 1.0), -1.0)
    j3 = math.acos(cos_j3)

    # Solve for Joint 2 such that:
    #   A*sin(j2) + B*sin(j2+j3) = 0,
    # which yields:
    j2 = -math.atan2(B * math.sin(j3), A + B * math.cos(j3))

    # Joint 4 does not affect position. Choose j4 = 0.
    j4 = 0.0

    return (j1, j2, j3, j4)