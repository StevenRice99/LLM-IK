def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math

    # Unpack the target TCP coordinates (in the base frame).
    px, py, pz = p

    # (1) Compute θ₁ from the projection of p onto the x–z plane.
    theta1 = math.atan2(px, pz)
    R = math.sqrt(px**2 + pz**2)

    # (2) Remove the fixed wrist offset.
    # With the default wrist configuration (θ₄ = 0 and θ₅ = 0), the wrist offset is:
    #   d_y = 0.093         (from joint 4)
    #   d_z = 0.09465 + 0.0823 = 0.17695   (from joint 5 and the TCP)
    #
    # In the rotated (x–z) frame, the TCP appears at (0, py, R). Thus, its wrist center is:
    #     (0, py - d_y, R - d_z)
    # However, the kinematic chain has an additional offset in y from joint 2’s origin at [0, -0.1197, 0.425].
    # To recover the 2R planar subproblem, we correct for this difference by adding 0.1197:
    d_y = 0.093
    d_z = 0.09465 + 0.0823  # equals 0.17695
    D_y = (py - d_y) + 0.1197  # simplifies to py + 0.0267
    D_z = R - d_z

    # (3) Solve the planar 2R subchain (joints 2 and 3).
    # Link lengths from the robot's design:
    A = 0.425     # effective length from joint 2 to joint 3
    B = 0.39225   # effective length from joint 3 to the wrist center

    # Use the cosine law to solve for joint 3:
    cos_theta3 = (D_y**2 + D_z**2 - A**2 - B**2) / (2 * A * B)
    # Clamp cos_theta3 to the valid interval [-1, 1] to avoid numerical issues.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)  # elbow-down solution

    # (4) Solve for joint 2 based on the 2R arm geometry.
    K1 = A + B * math.cos(theta3)
    K2 = B * math.sin(theta3)
    theta2 = math.atan2(D_y, D_z) - math.atan2(K2, K1)

    # (5) Set the redundant wrist joints to a default configuration.
    theta4 = 0.0
    theta5 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)