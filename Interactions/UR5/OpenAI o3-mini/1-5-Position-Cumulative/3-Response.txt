We can obtain one analytical solution by “decoupling” the kinematics into an arm (joints 1–3) that “reaches” a computed wrist‐center and then “fixing” the wrist (joints 4–5) to a default (here, zero) configuration. In our robot the TCP “offset” beyond joint 3 comes entirely from the chain of revolute 4, 5 and the TCP’s fixed translation. (Recall that in this robot the origins are defined as a translation followed by a rotation; for example, joint 4’s transform is
  T₄ = Trans(0,0.093,0)*RotZ(θ₄),
and if we set θ₄ = 0 the translation is just (0,0.093,0). In a similar way, if we choose θ₅ = 0 then the combined “wrist offset”
  d = (0, 0.093, 0.09465+0.0823) = (0, 0.093, 0.17695)
is constant.) 

In addition, note that the chain from the base to joint 3 has a “hidden” vertical shift: revolute 2’s origin is at (0, –0.1197, 0.425) so that (when the arm is “stretched out”) the effective 2–R arm (joints 2–3) works in the (y,z)–plane with link lengths

  A = 0.425  and  B = 0.39225 
  (with an extra constant offset of –0.1197 in y).

A good “decoupling” is obtained by first solving for θ₁ from the TCP’s projection onto the x–z (horizontal) plane. Writing 
  (px,py,pz) = p  and  R = √(px² + pz²),
we let

  θ₁ = atan2(px, pz).

Then “rotate” the problem so that the TCP lies in a plane where its coordinates become
  (0, py, R).

Because the wrist offset d (which we “remove” in order to have the reduced (2R) problem) is independent of the wrist angles when we choose θ₄ = θ₅ = 0, the wrist‐center (i.e. where joint 3 must “reach”) is given by

  p_wc = (0, py – d_y, R – d_z)
with d_y = 0.093 and d_z = 0.09465 + 0.0823 = 0.17695.

Now, the arm from the base (joint 1) to joint 3 gives a fixed contribution in the “rotated” (y,z)–plane. (In our chain the translation from the base to joint 3 is found as 
  p₂ = [0, –0.1197, 0.425]
followed by a translation of [0,0,0.39225] – note that these “link” translations act in each link’s local frame; when the only rotations occur about y the net result is that the arm “lives” in a constant (y,z) plane.) 

In order to “recover” the planar 2–R geometry we add back the (–0.1197) in y so that the effective target for the (2R) subchain is

  D_y = (py – d_y) + 0.1197 = py + (0.1197 – 0.093) = py + 0.0267,
  D_z = R – d_z.

Then the standard cosine–law on a 2–R arm with link lengths A = 0.425 and B = 0.39225 yields

  cos(θ₃) = (D_y² + D_z² – A² – B²)/(2·A·B)
so that (choosing the “elbow‐down” solution)

  θ₃ = acos( cos(θ₃) ).

To get θ₂ (the angle of the first “planar” joint) we write the forward equations for the 2–R arm as
  A·sin(θ₂) + B·sin(θ₂+θ₃) = D_y  and  A·cos(θ₂) + B·cos(θ₂+θ₃) = D_z.
Defining
  K₁ = A + B·cos(θ₃)  and  K₂ = B·sin(θ₃),
one may show that

  θ₂ = atan2(D_y, D_z) – atan2(K₂, K₁).

Finally, having “used up” the (position) constraints with joints 1–3 we choose the redundant wrist joints to a “default” value:
  θ₄ = 0  and  θ₅ = 0.

The complete analytical solution is presented below. (Note that in practice one may choose the “other” elbow solution by replacing θ₃ with –θ₃ and adjusting θ₂ accordingly.)

Below is the completed inverse_kinematics function:

------------------------------------------------------------
def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" for the 5 DOF manipulator.
    This implementation decouples the kinematics: joints 1–3 position the wrist center 
    (computed by “removing” the fixed offset of joints 4, 5 and the TCP) while joints 4–5 
    are set to a default (zero) configuration.
    
    Link dimensions (from URDF):
      • Link 2: translation [0, -0.1197, 0.425]
      • Link 3: translation [0, 0, 0.39225]
      • Wrist offset from joint 3 (joints 4, 5, and TCP):
          – Joint 4: translation (0, 0.093, 0)
          – Joint 5: translation (0, 0, 0.09465)
          – TCP:     translation (0, 0.0823, 0)
          which combine (with θ₄ = θ₅ = 0) to d = (0, 0.093, 0.09465+0.0823) = (0, 0.093, 0.17695)
    
    The (2R) subproblem (joints 2 and 3) is solved in the (y,z)–plane after “removing” the 
    influence of θ₁ and the wrist offset.
    
    :param p: The target TCP position [x, y, z] in the base (world) frame.
    :return: A tuple (θ₁, θ₂, θ₃, θ₄, θ₅) with the required joint angles (in radians).
    """
    import math

    # Unpack desired TCP position.
    px, py, pz = p

    # (1) Compute θ₁ from the projection of p onto the x–z plane.
    theta1 = math.atan2(px, pz)
    R = math.sqrt(px**2 + pz**2)

    # (2) Remove the wrist offset.
    # With the default wrist configuration (θ₄ = θ₅ = 0), the combined offset is:
    d_y = 0.093
    d_z = 0.09465 + 0.0823  # = 0.17695
    # In the rotated frame (i.e. after “removing” θ₁) the TCP becomes (0, py, R).
    # The wrist center is then:
    #   (x: 0, y: py - d_y, z: R - d_z)
    # but note that the arm’s first link (joint 2) gives an additional constant shift of -0.1197 in y.
    # Define the effective target for the 2R arm by adding 0.1197:
    D_y = (py - d_y) + 0.1197   # = py + 0.0267
    D_z = R - d_z

    # (3) Solve the 2R arm (joints 2 and 3) with link lengths:
    A = 0.425
    B = 0.39225

    # Cosine law for joint 3:
    cos_theta3 = (D_y**2 + D_z**2 - A**2 - B**2) / (2 * A * B)
    # Clamp to the interval [-1, 1] to avoid numerical errors.
    cos_theta3 = max(min(cos_theta3, 1), -1)
    theta3 = math.acos(cos_theta3)  # elbow solution (the alternate solution is -theta3)

    # (4) Solve for θ₂.
    K1 = A + B * math.cos(theta3)
    K2 = B * math.sin(theta3)
    theta2 = math.atan2(D_y, D_z) - math.atan2(K2, K1)

    # (5) Choose default values for the redundant wrist joints.
    theta4 = 0.0
    theta5 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)
------------------------------------------------------------

For example, if a reachable TCP position (p) is provided the returned angles will reproduce p (when used with the provided forward kinematics).

Keep in mind that due to the redundancy (5 DOF for a 3 DOF position task) other valid solutions exist.