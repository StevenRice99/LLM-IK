def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes an analytical closed-form inverse kinematics solution for a 5-DOF manipulator.
    
    The series of operations is as follows:
    1. Decouple the problem by first computing θ₁ from the projection of the TCP on the x–z plane.
       This rotates the problem so that the remaining (planar) subchain lies in the (y, R) plane,
       where R = sqrt(x² + z²).
       
         θ₁ = atan2(px, pz)
         R = sqrt(px² + pz²)
    
    2. Remove the constant wrist offset. With the default wrist configuration of θ₄ = 0 and θ₅ = 0,
       the combined offset from the end of joint 3 to the TCP is:
            d = (0, d_y, d_z)  where d_y = 0.093 and d_z = 0.09465 + 0.0823 = 0.17695.
       In the rotated frame the TCP becomes (0, py, R); hence the wrist center is:
            (0, py - d_y, R - d_z).
       However, the kinematic chain from the base to joint 3 includes an additional fixed offset in the y-direction
       from joint 2’s origin at (0, -0.1197, 0.425). To "recover" the effective planar subproblem we add back this value:
            D_y = (py - d_y) + 0.1197   (i.e. py + 0.0267)
            D_z = R - d_z
    
    3. Solve the planar 2R subchain (joints 2 and 3) with link lengths:
            A = 0.425, B = 0.39225.
       Using the cosine law:
            cos(θ₃) = (D_y² + D_z² − A² − B²) / (2·A·B)
       and choosing the elbow-down solution:
            θ₃ = acos(cos(θ₃))
    
    4. Then solve for θ₂ using:
            K₁ = A + B·cos(θ₃)
            K₂ = B·sin(θ₃)
       so that:
            θ₂ = atan2(D_y, D_z) − atan2(K₂, K₁)
    
    5. For redundancy, the wrist joints are set to:
            θ₄ = 0 and θ₅ = 0.
    
    :param p: The target TCP position [x, y, z] in the base (world) frame.
    :return: A tuple (θ₁, θ₂, θ₃, θ₄, θ₅) giving the joint angles in radians.
    """
    import math

    # Unpack TCP target coordinates.
    px, py, pz = p

    # (1) Compute θ₁ from the projection of p onto the x–z plane.
    theta1 = math.atan2(px, pz)
    R = math.sqrt(px**2 + pz**2)

    # (2) Remove the wrist offset.
    # With the default wrist configuration (θ₄ = θ₅ = 0), the offsets are:
    d_y = 0.093
    d_z = 0.09465 + 0.0823  # d_z = 0.17695
    # In the rotated frame (after applying θ₁) the TCP becomes (0, py, R).
    # The wrist center is at: (0, py - d_y, R - d_z)
    # The additional offset from joint 2 (origin at [0, -0.1197, 0.425]) is corrected by adding 0.1197 to y.
    D_y = (py - d_y) + 0.1197  # which simplifies to py + 0.0267
    D_z = R - d_z

    # (3) Solve the 2R subchain (joints 2 and 3) with link lengths:
    A = 0.425
    B = 0.39225

    # Use the cosine law to solve for joint 3:
    cos_theta3 = (D_y**2 + D_z**2 - A**2 - B**2) / (2 * A * B)
    # Clamp cos_theta3 to the range [-1, 1] to safeguard against numerical issues.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)  # choose the elbow-down solution; alternatively, one could use -theta3.

    # (4) Solve for θ₂.
    K1 = A + B * math.cos(theta3)
    K2 = B * math.sin(theta3)
    theta2 = math.atan2(D_y, D_z) - math.atan2(K2, K1)

    # (5) Set the redundant wrist joints to default values.
    theta4 = 0.0
    theta5 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)