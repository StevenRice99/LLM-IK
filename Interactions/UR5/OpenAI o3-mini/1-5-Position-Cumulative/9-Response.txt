def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math

    # Unpack target TCP coordinates.
    px, py, pz = p

    # (1) Compute θ₁ from the projection onto the x–z plane.
    theta1 = math.atan2(px, pz)
    R = math.sqrt(px**2 + pz**2)

    # (2) Remove the fixed wrist offset.
    # With default wrist configuration (θ₄ = 0 and θ₅ = 0), the offsets are:
    #   d_y (from joint 4) and d_z (from joints 5 and TCP) where:
    d_y = 0.093
    d_z = 0.09465 + 0.0823  # 0.17695

    # The TCP position in the rotated frame becomes (0, py, R), so the wrist center is:
    #   (0, py - d_y, R - d_z)
    # However, joint 2’s origin is at [0, -0.1197, 0.425], introducing a -0.1197 offset in y.
    # To compensate, add 0.1197 back:
    D_y = (py - d_y) + 0.1197  # simplifies to py + 0.0267
    D_z = R - d_z

    # (3) Solve the 2R planar subchain (joints 2 and 3) with link lengths:
    A = 0.425     # length from joint 2 to joint 3 (first link)
    B = 0.39225   # length from joint 3 to the wrist center (second link)

    # Using the cosine law:
    cos_theta3 = (D_y**2 + D_z**2 - A**2 - B**2) / (2 * A * B)
    # Clamp cos_theta3 to avoid numerical errors.
    cos_theta3 = max(min(cos_theta3, 1.0), -1.0)
    theta3 = math.acos(cos_theta3)  # elbow-down solution

    # (4) Solve for θ₂:
    # Compute intermediate quantities.
    K1 = A + B * math.cos(theta3)
    K2 = B * math.sin(theta3)
    theta2 = math.atan2(D_y, D_z) - math.atan2(K2, K1)

    # (5) Choose default wrist joints (redundant degrees of freedom).
    theta4 = 0.0
    theta5 = 0.0

    return (theta1, theta2, theta3, theta4, theta5)