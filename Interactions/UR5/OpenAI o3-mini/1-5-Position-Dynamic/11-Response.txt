def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math

    # Unpack the target TCP position
    x, y, z = p

    # -----------------------------------------
    # Sub-chain 1: Solve for joints 1 and 2 (affecting the x–z plane)
    # Effective link lengths for this sub-chain
    L1_a = 0.425      # from Revolute 1 to 2
    L2_a = 0.39225    # from Revolute 2 to 3

    # Project target position onto the x–z plane.
    d = math.sqrt(x**2 + z**2)

    # Use the cosine law: cos(theta2) = (d^2 - L1_a^2 - L2_a^2) / (2*L1_a*L2_a)
    cos_theta2 = (d**2 - L1_a**2 - L2_a**2) / (2 * L1_a * L2_a)
    # Clamp the value to handle numerical inaccuracies.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)

    # Adjust the sign of theta2 based on the manipulator's elbow configuration.
    cross = x * (L1_a + L2_a * math.cos(theta2)) - z * (L2_a * math.sin(theta2))
    if cross < 0:
        theta2 = -theta2

    # Compute joint 1: rotation about Y that positions the arm in the x–z plane.
    theta1 = math.atan2(x, z) - math.atan2(L2_a * math.sin(theta2), L1_a + L2_a * math.cos(theta2))

    # -----------------------------------------
    # Sub-chain 2: Solve for joints 3, 4, and 5 (the wrist adjustment)
    # Parameters for the wrist sub-chain.
    a    = 0.0823   # TCP offset along y
    L1_b = 0.093    # Offset from Revolute 3 to 4 (affects y)
    L2_b = 0.09465  # Offset from Revolute 4 to 5 (affects x–z)

    # The wrist's y-axis relation: (y - L1_b) = a * cos(theta4)
    cos_theta4 = (y - L1_b) / a
    cos_theta4 = max(min(cos_theta4, 1.0), -1.0)
    theta4_candidate = math.acos(cos_theta4)

    # Two potential configurations for theta4 exist.
    wrist_candidates = []
    for theta4 in [theta4_candidate, -theta4_candidate]:
        s4 = math.sin(theta4)
        # Define constants for the wrist geometry:
        # A corresponds to the link length from Revolute 4 to 5, and
        # B captures the effect of the TCP offset.
        A = L2_b
        B = -a * s4
        denom = A**2 + (a * s4)**2
        if abs(denom) < 1e-8:
            continue  # Skip near-singular configurations

        # Solve the coupled equations in the x–z plane:
        # A*sin(theta3) - a*sin(theta4)*cos(theta3) = x
        # A*cos(theta3) + a*sin(theta4)*sin(theta3) = z
        sin_theta3 = (A * x - B * z) / denom
        cos_theta3 = (A * z + B * x) / denom

        norm = math.sqrt(sin_theta3**2 + cos_theta3**2)
        if norm < 1e-8:
            continue  # Avoid division by zero
        sin_theta3 /= norm
        cos_theta3 /= norm
        theta3 = math.atan2(sin_theta3, cos_theta3)

        # Reconstruct x and z to evaluate the quality of the candidate.
        x_calc = A * math.sin(theta3) - a * s4 * math.cos(theta3)
        z_calc = A * math.cos(theta3) + a * s4 * math.sin(theta3)
        error = (x - x_calc)**2 + (z - z_calc)**2

        wrist_candidates.append((theta3, theta4, 0.0, error))  # Joint 5 is set to 0

    if not wrist_candidates:
        raise ValueError("Target position is unreachable for the wrist sub-chain.")

    # Select the wrist candidate with the smallest reconstruction error.
    theta3, theta4, theta5, _ = min(wrist_candidates, key=lambda candidate: candidate[3])

    # Return the complete set of joint angles.
    return (theta1, theta2, theta3, theta4, theta5)