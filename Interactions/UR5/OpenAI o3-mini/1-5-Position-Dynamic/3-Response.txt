import math

def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" for the 5-DOF manipulator.
    The solution decouples the chain into two sub-chains:
      • Sub-chain 1 (joints 1 and 2) uses the planar geometry in the x–z plane
        with effective link lengths L1 = 0.425 and L2 = 0.39225.
      • Sub-chain 2 (joints 3 to 5) solves the remaining wrist adjustment using
        parameters a = 0.0823 (TCP offset in y), L1 = 0.093 (offset from joint 3 to 4),
        and L2 = 0.09465 (offset from joint 4 to 5). For this sub-chain a closed‐form
        solution is found and the last joint is taken to be zero.
    It is assumed that the overall TCP position “p” has been computed by the forward
    kinematics (including the additional TCP offset) and that the decoupling is valid.
    
    :param p: The target TCP position as (x, y, z) [in meters].
    :return: A 5-tuple of joint angles (in radians) for the revolute joints 1 through 5.
    """
    # ---------------------------
    # Sub-chain 1: Solve for joints 1 and 2.
    # These joints (with axes along Y) affect the x–z position.
    #
    # Table parameters for sub-chain 1:
    #   Link from Revolute 1->2: translation of 0.425 (assumed along z)
    #   Link from Revolute 2->3: translation of 0.39225 (assumed along z)
    L1_a = 0.425
    L2_a = 0.39225
    x, y, z = p
    # d is the distance in the x-z plane from the base (projected target)
    d = math.sqrt(x**2 + z**2)
    
    # Using the cosine law (with appropriate sign conventions)
    cos_theta2 = (d**2 - L1_a**2 - L2_a**2) / (2 * L1_a * L2_a)
    # Clamp in case of minor numerical issues
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2_sub1 = math.acos(cos_theta2)
    
    # Adjust the sign of theta2 based on the cross product to ensure correct elbow configuration.
    cross = x * (L1_a + L2_a * math.cos(theta2_sub1)) - z * (L2_a * math.sin(theta2_sub1))
    if cross < 0:
        theta2_sub1 = -theta2_sub1

    # Compute the base joint (joint1) angle.
    alpha = math.atan2(x, z)
    beta = math.atan2(L2_a * math.sin(theta2_sub1), L1_a + L2_a * math.cos(theta2_sub1))
    theta1 = alpha - beta

    # ---------------------------
    # Sub-chain 2: Solve for joints 3, 4, and 5.
    # These joints (with axes Y, Z, and Y again) account for the remaining adjustment.
    #
    # Table parameters for sub-chain 2 (wrist):
    #   a     = 0.0823  (TCP offset along y, and used as a scaling factor)
    #   L1_b  = 0.093   (translation from Revolute 3 to 4, along y)
    #   L2_b  = 0.09465 (translation from Revolute 4 to 5, along z)
    a = 0.0823
    L1_b = 0.093
    L2_b = 0.09465
    x_target, y_target, z_target = p
    # For the y-direction, form the cosine equation:
    c2 = (y_target - L1_b) / a
    c2 = max(min(c2, 1.0), -1.0)
    theta_candidate = math.acos(c2)
    # Two possible solutions for this wrist joint (joint4 angle) exist.
    wrist_theta4_options = [theta_candidate, -theta_candidate]
    best_solution = None
    min_error = float('inf')
    # Loop over the two possible wrist configurations.
    for wrist_theta4 in wrist_theta4_options:
        s_wrist4 = math.sin(wrist_theta4)
        # In the planar wrist sub-chain, define:
        #   A = L2_b (link from Revolute 4 to 5)
        #   B = -a * sin(wrist_theta4)
        A = L2_b
        B = -a * s_wrist4
        denominator = A**2 + (a * s_wrist4)**2
        if abs(denominator) < 1e-10:
            continue
        # Solve for the remaining wrist joint (joint3 of sub-chain 2) angle.
        sin_wrist3 = (A * x_target - B * z_target) / denominator
        cos_wrist3 = (A * z_target + B * x_target) / denominator
        # Normalize in case of numerical deviations.
        norm = math.sqrt(sin_wrist3**2 + cos_wrist3**2)
        if norm < 1e-10:
            continue
        sin_wrist3 /= norm
        cos_wrist3 /= norm
        wrist_theta3 = math.atan2(sin_wrist3, cos_wrist3)
        # Reconstruct the x and z using this candidate solution.
        x_calc = A * math.sin(wrist_theta3) - a * s_wrist4 * math.cos(wrist_theta3)
        z_calc = A * math.cos(wrist_theta3) + a * s_wrist4 * math.sin(wrist_theta3)
        err = (x_calc - x_target)**2 + (z_calc - z_target)**2
        if err < min_error:
            min_error = err
            # For simplicity, we set the final wrist joint (joint5) to zero.
            best_solution = (wrist_theta3, wrist_theta4, 0.0)
    if best_solution is None:
        raise ValueError("Target position unreachable for wrist sub-chain.")
    # Map the wrist sub-chain solution to joints 3, 4, and 5.
    theta3, theta4, theta5 = best_solution

    # Combine the solutions from sub-chain 1 and sub-chain 2 to form the complete 5-DOF solution.
    return (theta1, theta2_sub1, theta3, theta4, theta5)