def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 5-DOF serial manipulator so that its TCP 
    reaches the target position p = (x, y, z). The manipulator’s geometry is decoupled into 
    two sub-chains:
    
      Sub-chain 1 (Joints 1 and 2):
        • Revolute joints with axes along Y affect motion in the x–z plane.
        • Effective link lengths are:
              L1_a = 0.425 (from Revolute 1 to Revolute 2)
              L2_a = 0.39225 (from Revolute 2 to Revolute 3)
        • Using the projected distance d = sqrt(x² + z²) and the cosine law, joint 2 (θ2)
          is computed. The sign of θ2 is adjusted based on the cross-product sign,
          and joint 1 (θ1) is then computed from the geometry.
    
      Sub-chain 2 (Joints 3, 4, and 5):
        • These joints (axes Y, Z, and Y respectively) address the wrist/TCP adjustment.
        • Parameters for this sub-chain are:
              a    = 0.0823    (TCP offset along y)
              L1_b = 0.093     (offset from Revolute 3 to Revolute 4)
              L2_b = 0.09465   (offset from Revolute 4 to Revolute 5)
        • The y-component yields:
                  (y - L1_b) = a * cos(θ4)
          so that cos(θ4) = (y - L1_b) / a.
          Two possible solutions exist for θ4: one positive and one negative.
        • For each candidate θ4, joint 3 (θ3) is solved from the x–z geometry defined by:
                  A*sin(θ3) - a*sin(θ4)*cos(θ3) = x
                  A*cos(θ3) + a*sin(θ4)*sin(θ3) = z
          where A = L2_b and B = -a*sin(θ4). The candidate that minimizes the residual 
          error in x and z is selected, and joint 5 (θ5) is set to 0.
    
    It is assumed that the target is reachable.
    
    :param p: The desired TCP position as an (x, y, z) tuple in meters.
    :return: A tuple (θ1, θ2, θ3, θ4, θ5) of joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # --- Sub-chain 1: Solve for joints 1 and 2 (affecting the x–z plane) ---
    L1_a = 0.425      # Link length from Revolute 1 to 2.
    L2_a = 0.39225    # Link length from Revolute 2 to 3.
    # Compute the projected distance in the x–z plane.
    d = math.sqrt(x**2 + z**2)
    
    # Use the cosine law to compute joint 2.
    cos_theta2 = (d**2 - L1_a**2 - L2_a**2) / (2 * L1_a * L2_a)
    # Clamp cos_theta2 within [-1, 1] to avoid numerical issues.
    cos_theta2 = max(min(cos_theta2, 1.0), -1.0)
    theta2 = math.acos(cos_theta2)
    # Adjust the sign of theta2 based on the geometry.
    cross = x * (L1_a + L2_a * math.cos(theta2)) - z * (L2_a * math.sin(theta2))
    if cross < 0:
        theta2 = -theta2
    
    # Compute joint 1 using the projected angle.
    theta1 = math.atan2(x, z) - math.atan2(L2_a * math.sin(theta2), L1_a + L2_a * math.cos(theta2))
    
    # --- Sub-chain 2: Solve for joints 3, 4, and 5 (the wrist) ---
    a    = 0.0823   # TCP offset along y.
    L1_b = 0.093    # Offset from Revolute 3 to 4 (affects y).
    L2_b = 0.09465  # Offset from Revolute 4 to 5 (affects x–z).
    
    # Solve for joint 4 using the y-direction.
    cos_theta4 = (y - L1_b) / a
    cos_theta4 = max(min(cos_theta4, 1.0), -1.0)
    theta4_candidate = math.acos(cos_theta4)
    
    # Two possible wrist configurations exist for θ4.
    best_error = float('inf')
    best_solution = None
    for theta4 in [theta4_candidate, -theta4_candidate]:
        s4 = math.sin(theta4)
        # Define parameters for joint 3 solution.
        A = L2_b
        B = -a * s4
        D = A**2 + (a * s4)**2  # Denominator term.
        if abs(D) < 1e-8:
            continue  # Skip singular configurations.
        # Solve for the sine and cosine of joint 3.
        sin_theta3 = (A * x - B * z) / D
        cos_theta3 = (A * z + B * x) / D
        norm = math.sqrt(sin_theta3**2 + cos_theta3**2)
        if norm < 1e-8:
            continue
        sin_theta3 /= norm
        cos_theta3 /= norm
        theta3 = math.atan2(sin_theta3, cos_theta3)
        
        # Verify the wrist solution by reconstructing x and z.
        x_calc = A * math.sin(theta3) - a * s4 * math.cos(theta3)
        z_calc = A * math.cos(theta3) + a * s4 * math.sin(theta3)
        error = (x_calc - x)**2 + (z_calc - z)**2

        if error < best_error:
            best_error = error
            # Set joint 5 (θ5) to zero as per our simplification.
            best_solution = (theta3, theta4, 0.0)

    if best_solution is None:
        raise ValueError("Target position is unreachable for the wrist sub-chain.")
    theta3, theta4, theta5 = best_solution

    return (theta1, theta2, theta3, theta4, theta5)