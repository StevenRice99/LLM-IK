def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float, float]:
    import math

    # Unpack the target TCP position.
    px, py, pz = p

    # --- Redundancy resolution ---
    # For a unique solution we fix:
    q3 = 0.0
    q4 = 1.0
    q5 = 0.0

    # --- Robot geometric constants (from the URDF data) ---
    # Revolute 2 translation (x,y,z): [0, -0.1197, 0.425]
    d2 = 0.425       # Use the z translation for the planar (x,z) problem.
    # Revolute 3 translation: [0, 0, 0.39225]
    d3 = 0.39225
    # Revolute 4 translation: [0, 0.093, 0] (only affects y)
    # Revolute 5 translation: [0, 0, 0.09465]
    d5 = 0.09465
    # TCP translation: [0, 0.0823, 0] (only affects y except through rotation of joint 4)
    tcp_offset = 0.0823

    # With q4 fixed at 1.0 and q5=0, the contributions from Revolute 4, Revolute 5, and the TCP
    # along the x–z plane are captured by the following effective constants:
    #
    #   Let A = tcp_offset * sin(q4)
    #       B = d3 + d5
    #
    # These appear in the effective (local) x–z displacement (before being rotated by q1)
    # coming from Revolute 2 onward:
    #
    #   X_eff = –A*cos(q2) + B*sin(q2)
    #   Z_eff = d2 + A*sin(q2) + B*cos(q2)
    #
    # After joint 1’s rotation about Y (by q1), the global x–z coordinates become:
    #
    #   px = cos(q1)*X_eff + sin(q1)*Z_eff
    #   pz = –sin(q1)*X_eff + cos(q1)*Z_eff
    #
    # Because the rotation by q1 does not change the magnitude in the x–z plane, we have:
    #   r_target² = X_eff² + Z_eff²
    #
    # Expanding, one obtains:
    #   r_target² = (A²+B²+d2²) + 2*d2*(A*sin(q2)+B*cos(q2))
    #
    # We define:
    #   constant = A² + B² + d2²
    #   and let C(q2) = A*sin(q2) + B*cos(q2).
    #
    # Then:
    #   C(q2) = (r_target² – constant) / (2*d2)
    #
    # We can express C(q2) in amplitude–phase form:
    #   C(q2) = R_const * cos(q2 – φ)
    # where:
    #   R_const = sqrt(A²+B²)
    #   φ = atan2(A, B)
    #
    # One valid solution is:
    #   cos(q2 – φ) = [ (r_target² – constant)/(2*d2) ] / R_const,
    # so that:
    #   q2 = φ + acos(clamp( (r_target² – constant)/(2*d2*R_const), -1, 1 ))
    #

    A = tcp_offset * math.sin(q4)  # effective contribution from the TCP offset (≈ tcp_offset*sin(1.0))
    B = d3 + d5                    # combined length from Revolute 3 and 5
    R_const = math.sqrt(A**2 + B**2)
    phi = math.atan2(A, B)

    # The target distance in the x-z plane.
    r_target = math.sqrt(px**2 + pz**2)
    constant = A**2 + B**2 + d2**2
    C_target = (r_target**2 - constant) / (2 * d2)

    ratio = C_target / R_const
    # Clamp the ratio to avoid numerical errors.
    if ratio > 1.0:
        ratio = 1.0
    elif ratio < -1.0:
        ratio = -1.0

    q2 = phi + math.acos(ratio)

    # With q2 determined, compute the effective displacements.
    X_eff = -A * math.cos(q2) + B * math.sin(q2)
    Z_eff = d2 + A * math.sin(q2) + B * math.cos(q2)

    # Solve for q1 by "undoing" the rotation about Y:
    # The equations are:
    #   px = cos(q1)*X_eff + sin(q1)*Z_eff
    #   pz = -sin(q1)*X_eff + cos(q1)*Z_eff
    #
    # Hence, q1 can be computed as:
    q1 = math.atan2(px, pz) - math.atan2(X_eff, Z_eff)

    return (q1, q2, q3, q4, q5)