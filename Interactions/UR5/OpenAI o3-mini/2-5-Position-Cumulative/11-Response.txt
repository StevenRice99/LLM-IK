def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closed‐form inverse kinematics solution for a 4‑DOF serial manipulator.
    
    The robot’s kinematic chain is:
      • Revolute 1: rotates about Y (no translation).
      • Revolute 2: rotates about Y; translation along Z by 0.39225.
      • Revolute 3: rotates about Z; translation along Y by 0.093.
      • Revolute 4: rotates about Y; translation along Z by 0.09465.
      • TCP offset: [0, 0.0823, 0].
      
    The vertical (Y) coordinate of the TCP is given by:
         y = 0.0823 * cos(theta3) + 0.093,
    which implies:
         theta3 = arccos((y - 0.093) / 0.0823).

    For the planar (X-Z) portion:
      • Define K = 0.0823 * sin(theta3) (contribution from the TCP offset rotated by theta3),
        L = 0.09465 (translation from joint 4), and
        D = 0.39225 (translation from joint 2).
      • The effective planar coordinates after joints 2, 3, and 4 are:
             p2_x = -K*cos(theta2) + L*sin(theta2)
             p2_z =  K*sin(theta2) + L*cos(theta2) + D.
      • The target projection in the X-Z plane has magnitude:
             r = sqrt(x^2 + z^2)
        and it satisfies:
             r^2 = K^2 + L^2 + D^2 + 2*D*(L*cos(theta2) + K*sin(theta2)).
      • With E defined as:
             E = (r^2 - (K^2 + L^2 + D^2))/(2*D),
        note that L*cos(theta2)+K*sin(theta2) can be written as:
             sqrt(L^2+K^2)*cos(theta2 - α)
        with α = atan2(K, L), so that:
             theta2 = α + arccos(E / sqrt(L^2+K^2)).
             
    Finally, Revolute 1 (theta1) rotates the resulting planar subchain.
    Let:
           φ = atan2(p2_z, p2_x)   and   δ = atan2(z, x),
    then the required joint value is:
           theta1 = φ - δ.
    
    Joint 4 does not affect the TCP position (since the TCP offset is only along Y),
    so we set:
           theta4 = 0.
    
    :param p: Target TCP position as a tuple (x, y, z) in meters.
    :return: A tuple (theta1, theta2, theta3, theta4) with joint angles in radians.
    """
    import math

    # Unpack the target position.
    x, y, z = p

    # Solve for joint 3 using the vertical (Y) constraint.
    # y = 0.0823*cos(theta3) + 0.093  =>  theta3 = arccos((y - 0.093)/0.0823)
    theta3 = math.acos((y - 0.093) / 0.0823)

    # Define constants for the planar (X-Z) subchain.
    K = 0.0823 * math.sin(theta3)  # Effect of theta3 on the TCP offset.
    L = 0.09465                   # Translation from joint 4.
    D = 0.39225                   # Translation from joint 2.

    # Compute the target projection magnitude in the X-Z plane.
    r = math.sqrt(x**2 + z**2)

    # Solve for joint 2 from the planar relationship.
    # r^2 = K^2 + L^2 + D^2 + 2*D*(L*cos(theta2) + K*sin(theta2))
    # Define E = (r^2 - (K^2 + L^2 + D^2))/(2*D)
    E = (r**2 - (K**2 + L**2 + D**2)) / (2 * D)
    R_val = math.sqrt(L**2 + K**2)
    alpha = math.atan2(K, L)
    theta2 = alpha + math.acos(E / R_val)

    # Compute the effective local (X-Z) position after joints 2, 3, and 4.
    p2_x = -K * math.cos(theta2) + L * math.sin(theta2)
    p2_z = K * math.sin(theta2) + L * math.cos(theta2) + D

    # Determine joint 1 by aligning the subchain with the target.
    phi = math.atan2(p2_z, p2_x)
    delta = math.atan2(z, x)
    theta1 = phi - delta

    # Joint 4 is redundant in terms of TCP position; set it to 0.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)