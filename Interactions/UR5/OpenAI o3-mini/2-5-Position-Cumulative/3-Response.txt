We can â€œdecoupleâ€ the (position-only) inverse kinematics into a â€œverticalâ€ constraint (the yâ€‘coordinate) and a â€œplanarâ€ constraint (the projection onto the xâ€“z plane). In our robot the only link that â€œliftsâ€ the TCP (in y) is the (fixed) sum of two yâ€‘offsets, one coming from the translation on joint 3 and one from the TCP offset. In fact, if you write the forward kinematics (see the table) you find that

â€ƒâ€ƒpy = 0.0823Â·cos(Î¸â‚ƒ) + 0.093

so that
â€ƒâ€ƒÎ¸â‚ƒ = arccos((py â€“ 0.093)/0.0823).

Once Î¸â‚ƒ is known the â€œplanarâ€ problem (in xâ€“z) depends on joints 1, 2, and 4. (Because the TCP offset of [0, 0.0823, 0] is purely in y it turns out the fourth joint does not affect the TCP position and so may be set at a nominal valueâ€”in our solution we choose Î¸â‚„ = 0.)

Defining
â€ƒâ€ƒK = 0.0823Â·sin(Î¸â‚ƒ)
â€ƒâ€ƒL = 0.09465â€ƒâ€ƒâ€ƒâ€ƒâ€ƒ (translation from joint 4)
â€ƒâ€ƒD = 0.39225â€ƒâ€ƒâ€ƒâ€ƒâ€ƒ (translation from joint 2)
one may show that the effective position (in the â€œsubchainâ€ after joint 1) is
â€ƒâ€ƒpâ‚‚â‚â‚“â‚ = â€“KÂ·cos(Î¸â‚‚) + LÂ·sin(Î¸â‚‚)
â€ƒâ€ƒpâ‚‚â‚ğ‘§â‚ =â€ƒKÂ·sin(Î¸â‚‚) + LÂ·cos(Î¸â‚‚) + D.
Then (after a rotation by joint 1) the TCP â€œplanarâ€ position (px, pz) is
â€ƒâ€ƒpx = cos(Î¸â‚)Â·pâ‚‚â‚â‚“â‚ + sin(Î¸â‚)Â·pâ‚‚â‚ğ‘§â‚ 
â€ƒâ€ƒpz = â€“sin(Î¸â‚)Â·pâ‚‚â‚â‚“â‚ + cos(Î¸â‚)Â·pâ‚‚â‚ğ‘§â‚.
A short calculation shows that (because rotations preserve length) the magnitude
â€ƒâ€ƒr = âˆš(pxÂ² + pzÂ²)
satisfies
â€ƒâ€ƒrÂ² = KÂ² + LÂ² + DÂ² + 2Â·D Â· (LÂ·cos(Î¸â‚‚) + KÂ·sin(Î¸â‚‚)).
Thus one may solve for Î¸â‚‚ by writing
â€ƒâ€ƒLÂ·cos(Î¸â‚‚) + KÂ·sin(Î¸â‚‚) = Eâ€ƒâ€ƒâ€ƒwithâ€ƒE = (rÂ² â€“ (KÂ² + LÂ² + DÂ²))/(2Â·D).
Writing
â€ƒâ€ƒâˆš(LÂ² + KÂ²) Â· cos(Î¸â‚‚ â€“ Î±) = Eâ€ƒâ€ƒâ€ƒwithâ€ƒÎ± = atan2(K, L)
yields the solution for Î¸â‚‚ (choosing the branch that recovers the â€œforwardâ€ value):
â€ƒâ€ƒÎ¸â‚‚ = Î± + arccos(E/âˆš(LÂ² + KÂ²)).

Finally, the â€œbaseâ€ joint (Î¸â‚) simply reorients the subchainâ€™s xâ€“z vector. Writing the (x,z) components of pâ‚‚ as
â€ƒâ€ƒpâ‚‚ = (pâ‚‚â‚â‚“â‚, pâ‚‚â‚ğ‘§â‚)
one may express that the rotation by Î¸â‚ sends that vector into (px, pz). In particular if we write the polar angles
â€ƒâ€ƒÏ• = atan2(pâ‚‚â‚ğ‘§â‚, pâ‚‚â‚â‚“â‚)â€ƒâ€ƒandâ€ƒÎ´ = atan2(pz, px),
then the rotation by Î¸â‚ must â€œundoâ€ the difference so that
â€ƒâ€ƒÎ¸â‚ = Ï• â€“ Î´.
Since the TCP position is independent of Î¸â‚„ we set
â€ƒâ€ƒÎ¸â‚„ = 0.

Below is the complete Python function implementing the above closedâ€form solution. (Remember: we assume that the target is reachable so no extra error checking is included.)

------------------------------------------------
def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p".
    The robot chain is as follows (length units in meters):
      â€¢ Revolute 1 : rotates about Y.
      â€¢ Revolute 2 : rotates about Y and has a translation of [0, 0, 0.39225].
      â€¢ Revolute 3 : rotates about Z and has a translation of [0, 0.093, 0].
      â€¢ Revolute 4 : rotates about Y and has a translation of [0, 0, 0.09465].
      â€¢ TCP offset             : [0, 0.0823, 0].
    The overall TCP yâ€position is given by:
         py = 0.0823 * cos(Î¸â‚ƒ) + 0.093,
    so that Î¸â‚ƒ = arccos((py - 0.093)/0.0823).
    The remaining joints (Î¸â‚ and Î¸â‚‚) are solved from the xâ€“z location (with
    the effective translations coming from joint 2 and joint 4) and the overall rotation.
    Joint 4 does not affect the position and is set to 0.
    
    :param p: The target TCP position in the form [x, y, z].
    :return: A tuple of the joint values (Î¸â‚, Î¸â‚‚, Î¸â‚ƒ, Î¸â‚„).
    """
    import math

    # Unpack target TCP position.
    px, py, pz = p

    # --- Solve for joint 3 using the vertical (y) constraint.
    # py = 0.0823*cos(theta3) + 0.093  =>  theta3 = arccos((py - 0.093)/0.0823)
    theta3 = math.acos((py - 0.093) / 0.0823)

    # --- Define constants for the planar chain.
    # Let K = 0.0823*sin(theta3) comes from the effect of joint 3 rotation.
    # L = 0.09465 is the translation from joint 4.
    # D = 0.39225 is the translation from joint 2.
    K = 0.0823 * math.sin(theta3)
    L = 0.09465
    D = 0.39225

    # The projection of the TCP in the x-z plane must satisfy |(px, pz)| = r.
    r = math.sqrt(px**2 + pz**2)

    # --- Solve for joint 2 from the planar chain.
    # In the 2D subchain (after joint 1) one can show that:
    # r^2 = K^2 + L^2 + D^2 + 2*D*(L*cos(theta2) + K*sin(theta2))
    # Define E = (r^2 - (K^2 + L^2 + D^2)) / (2*D) so that:
    # L*cos(theta2) + K*sin(theta2) = E.
    # Write the left-hand side as sqrt(L^2 + K^2) * cos(theta2 - alpha),
    # with alpha = atan2(K, L). Then:
    # cos(theta2 - alpha) = E / sqrt(L^2 + K^2),
    # so that:
    # theta2 = alpha + arccos(E / sqrt(L^2 + K^2)).
    R_val = math.sqrt(L**2 + K**2)
    E = (r**2 - (K**2 + L**2 + D**2)) / (2 * D)
    alpha = math.atan2(K, L)
    theta2 = alpha + math.acos(E / R_val)

    # --- Compute the effective translation from joints 2, 3, and 4.
    # After joint 2 the effective x and z contributions are:
    p2_x = -K * math.cos(theta2) + L * math.sin(theta2)
    p2_z = K * math.sin(theta2) + L * math.cos(theta2) + D

    # --- Solve for joint 1 from the rotation in the xâ€“z plane.
    # The effect of joint 1 (rotation about Y) is to rotate p2 = (p2_x, p2_z) into (px, pz).
    # Writing the polar angles (in the xâ€“z plane) as:
    #   Ï• = atan2(p2_z, p2_x) and Î´ = atan2(pz, px),
    # the required joint 1 value is:
    #   theta1 = Ï• - Î´.
    phi = math.atan2(p2_z, p2_x)
    delta = math.atan2(pz, px)
    theta1 = phi - delta

    # --- Joint 4 does not affect the position (because the TCP offset is purely along y)
    # so we assign it an arbitrary value (here 0).
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)

------------------------------------------------

Explanation:

1. The vertical â€œyâ€constraintâ€ determines Î¸â‚ƒ uniquely:
â€ƒâ€ƒÎ¸â‚ƒ = arccos((py â€“ 0.093)/0.0823).

2. The combined effect of joints 2 and 4 (whose translations are along the local z axis) appears in the xâ€“z plane. After some algebra one finds that the magnitude of the planar projection (r = âˆš(pxÂ² + pzÂ²)) relates to Î¸â‚‚ by
â€ƒâ€ƒrÂ² = KÂ² + LÂ² + DÂ² + 2Â·DÂ·(LÂ·cosÎ¸â‚‚ + KÂ·sinÎ¸â‚‚).
We solve this for Î¸â‚‚ by writing LÂ·cosÎ¸â‚‚ + KÂ·sinÎ¸â‚‚ in the form R_valÂ·cos(Î¸â‚‚ â€“ Î±).

3. Finally, a rotation Î¸â‚ will â€œreorientâ€ the planar vector to match (px, pz); writing its polar angles Ï• (of the subchain) and Î´ (of the target) gives
â€ƒâ€ƒÎ¸â‚ = Ï• â€“ Î´.

4. Joint 4 is redundant for positioning so we set Î¸â‚„ = 0.

This completes the closedâ€form inverse kinematics solution for the 4â€‘DOF chain when only position is specified.