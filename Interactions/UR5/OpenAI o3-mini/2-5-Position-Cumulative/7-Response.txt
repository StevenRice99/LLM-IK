def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closedâ€form inverse kinematics solution for a 4â€‘DOF serial manipulator.
    
    Kinematic chain details (in meters and radians):
      â€¢ Revolute 1: rotation about Y. (No translation)
      â€¢ Revolute 2: rotation about Y; translation [0, 0, 0.39225].
      â€¢ Revolute 3: rotation about Z; translation [0, 0.093, 0].
      â€¢ Revolute 4: rotation about Y; translation [0, 0, 0.09465].
      â€¢ TCP offset: [0, 0.0823, 0] (with given fixed orientation).
    
    The TCPâ€™s vertical (y) coordinate is given by:
         y = 0.0823 * cos(theta3) + 0.093,
    so that:
         theta3 = arccos((y - 0.093)/0.0823).
    
    For the planar (xâ€“z) portion, define:
         K = 0.0823 * sin(theta3)
         L = 0.09465    (translation from joint 4)
         D = 0.39225    (translation from joint 2)
         
    After joints 2, 3, and 4, the effective (local) coordinates are:
         pâ‚‚â‚â‚“â‚Ž = -K*cos(theta2) + L*sin(theta2)
         pâ‚‚â‚ð‘§â‚Ž =  K*sin(theta2) + L*cos(theta2) + D.
    The targetâ€™s projection in the xâ€“z plane has magnitude:
         r = sqrt(xÂ² + zÂ²).
    A short derivation shows that:
         rÂ² = KÂ² + LÂ² + DÂ² + 2*D*(L*cos(theta2) + K*sin(theta2)).
    Define:
         E = (rÂ² - (KÂ² + LÂ² + DÂ²))/(2*D).
    Noting that L*cos(theta2) + K*sin(theta2) can be written as:
         sqrt(LÂ²+KÂ²)*cos(theta2 - Î±),
    where Î± = atan2(K, L), we obtain:
         theta2 = Î± + arccos(E/sqrt(LÂ²+KÂ²)).
    
    Finally, joint 1 rotates the entire planar subchain. Writing the (local) subchain vector 
    in the xâ€“z plane as (pâ‚‚â‚â‚“â‚Ž, pâ‚‚â‚ð‘§â‚Ž) with polar angle Ï† = atan2(pâ‚‚â‚ð‘§â‚Ž, pâ‚‚â‚â‚“â‚Ž), and the targetâ€™s
    corresponding polar angle as Î´ = atan2(z, x), we have:
         theta1 = Ï† - Î´.
    
    Joint 4 does not affect the TCPâ€™s position (its TCP offset is purely in y) so we choose:
         theta4 = 0.
    
    :param p: The target TCP position as a tuple (x, y, z) in meters.
    :return: A tuple (theta1, theta2, theta3, theta4) with joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # --- Solve for joint 3 using the vertical (y) constraint.
    # TCP y: y = 0.0823*cos(theta3) + 0.093  => theta3 = arccos((y - 0.093)/0.0823)
    theta3 = math.acos((y - 0.093) / 0.0823)

    # --- Define constants for the planar subchain.
    K = 0.0823 * math.sin(theta3)   # Contribution of the TCP offset in xâ€“z due to theta3.
    L = 0.09465                     # Translation along z from joint 4.
    D = 0.39225                     # Translation along z from joint 2.

    # --- Compute the magnitude of the target projection in the xâ€“z plane.
    r = math.sqrt(x**2 + z**2)

    # --- Solve for joint 2 using the planar relationship.
    # rÂ² = KÂ² + LÂ² + DÂ² + 2*D*(L*cos(theta2) + K*sin(theta2))
    # Solve: L*cos(theta2) + K*sin(theta2) = E, with
    E = (r**2 - (K**2 + L**2 + D**2)) / (2 * D)
    R_val = math.sqrt(L**2 + K**2)
    alpha = math.atan2(K, L)
    theta2 = alpha + math.acos(E / R_val)

    # --- Compute the effective (local) position (pâ‚‚) in the xâ€“z plane after joints 2,3, and 4.
    p2_x = -K * math.cos(theta2) + L * math.sin(theta2)
    p2_z =  K * math.sin(theta2) + L * math.cos(theta2) + D

    # --- Determine joint 1 by aligning the rotated subchain with the target.
    phi = math.atan2(p2_z, p2_x)
    delta = math.atan2(z, x)
    theta1 = phi - delta

    # --- Joint 4 is redundant for positioning; set to 0.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)