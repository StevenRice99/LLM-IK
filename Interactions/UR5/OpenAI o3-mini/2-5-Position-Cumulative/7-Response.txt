def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the closed‐form inverse kinematics solution for a 4‑DOF serial manipulator.
    
    Kinematic chain details (in meters and radians):
      • Revolute 1: rotation about Y. (No translation)
      • Revolute 2: rotation about Y; translation [0, 0, 0.39225].
      • Revolute 3: rotation about Z; translation [0, 0.093, 0].
      • Revolute 4: rotation about Y; translation [0, 0, 0.09465].
      • TCP offset: [0, 0.0823, 0] (with given fixed orientation).
    
    The TCP’s vertical (y) coordinate is given by:
         y = 0.0823 * cos(theta3) + 0.093,
    so that:
         theta3 = arccos((y - 0.093)/0.0823).
    
    For the planar (x–z) portion, define:
         K = 0.0823 * sin(theta3)
         L = 0.09465    (translation from joint 4)
         D = 0.39225    (translation from joint 2)
         
    After joints 2, 3, and 4, the effective (local) coordinates are:
         p₂₍ₓ₎ = -K*cos(theta2) + L*sin(theta2)
         p₂₍𝑧₎ =  K*sin(theta2) + L*cos(theta2) + D.
    The target’s projection in the x–z plane has magnitude:
         r = sqrt(x² + z²).
    A short derivation shows that:
         r² = K² + L² + D² + 2*D*(L*cos(theta2) + K*sin(theta2)).
    Define:
         E = (r² - (K² + L² + D²))/(2*D).
    Noting that L*cos(theta2) + K*sin(theta2) can be written as:
         sqrt(L²+K²)*cos(theta2 - α),
    where α = atan2(K, L), we obtain:
         theta2 = α + arccos(E/sqrt(L²+K²)).
    
    Finally, joint 1 rotates the entire planar subchain. Writing the (local) subchain vector 
    in the x–z plane as (p₂₍ₓ₎, p₂₍𝑧₎) with polar angle φ = atan2(p₂₍𝑧₎, p₂₍ₓ₎), and the target’s
    corresponding polar angle as δ = atan2(z, x), we have:
         theta1 = φ - δ.
    
    Joint 4 does not affect the TCP’s position (its TCP offset is purely in y) so we choose:
         theta4 = 0.
    
    :param p: The target TCP position as a tuple (x, y, z) in meters.
    :return: A tuple (theta1, theta2, theta3, theta4) with joint angles in radians.
    """
    import math

    # Unpack the target TCP position.
    x, y, z = p

    # --- Solve for joint 3 using the vertical (y) constraint.
    # TCP y: y = 0.0823*cos(theta3) + 0.093  => theta3 = arccos((y - 0.093)/0.0823)
    theta3 = math.acos((y - 0.093) / 0.0823)

    # --- Define constants for the planar subchain.
    K = 0.0823 * math.sin(theta3)   # Contribution of the TCP offset in x–z due to theta3.
    L = 0.09465                     # Translation along z from joint 4.
    D = 0.39225                     # Translation along z from joint 2.

    # --- Compute the magnitude of the target projection in the x–z plane.
    r = math.sqrt(x**2 + z**2)

    # --- Solve for joint 2 using the planar relationship.
    # r² = K² + L² + D² + 2*D*(L*cos(theta2) + K*sin(theta2))
    # Solve: L*cos(theta2) + K*sin(theta2) = E, with
    E = (r**2 - (K**2 + L**2 + D**2)) / (2 * D)
    R_val = math.sqrt(L**2 + K**2)
    alpha = math.atan2(K, L)
    theta2 = alpha + math.acos(E / R_val)

    # --- Compute the effective (local) position (p₂) in the x–z plane after joints 2,3, and 4.
    p2_x = -K * math.cos(theta2) + L * math.sin(theta2)
    p2_z =  K * math.sin(theta2) + L * math.cos(theta2) + D

    # --- Determine joint 1 by aligning the rotated subchain with the target.
    phi = math.atan2(p2_z, p2_x)
    delta = math.atan2(z, x)
    theta1 = phi - delta

    # --- Joint 4 is redundant for positioning; set to 0.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)