def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math
    x, y, z = p

    # Solve for joint 3 from the vertical (y) constraint:
    #     y = 0.093 + 0.0823*cos(theta3)
    # so  theta3 = arccos((y - 0.093)/0.0823)
    theta3 = math.acos((y - 0.093) / 0.0823)

    # Define constants used for the planar (x-z) portion:
    # K captures the x contribution from the TCP offset rotated by theta3;
    # L is the translation along z from joint 4; D is the translation along z from joint 2.
    K = 0.0823 * math.sin(theta3)
    L = 0.09465
    D = 0.39225

    # The target projection in the x-z plane:
    r = math.sqrt(x ** 2 + z ** 2)

    # In the planar subchain, one can show that:
    #     r² = K² + L² + D² + 2*D*(L*cos(theta2) + K*sin(theta2)).
    # Rearranging gives:
    #     L*cos(theta2) + K*sin(theta2) = E,  where
    #     E = (r² - (K² + L² + D²)) / (2*D).
    # Writing the LHS as sqrt(L²+K²)*cos(theta2 - alpha) with alpha = atan2(K, L),
    # we solve for theta2:
    #     theta2 = alpha + arccos(E / sqrt(L² + K²))
    E = (r ** 2 - (K ** 2 + L ** 2 + D ** 2)) / (2 * D)
    R_val = math.sqrt(L ** 2 + K ** 2)
    alpha = math.atan2(K, L)
    theta2 = alpha + math.acos(E / R_val)

    # After joint2 (and joint4 translation), the effective local x-z coordinates are:
    p2_x = -K * math.cos(theta2) + L * math.sin(theta2)
    p2_z = K * math.sin(theta2) + L * math.cos(theta2) + D

    # Joint 1 rotates the subchain in the x-z plane. Define:
    #    phi = atan2(p2_z, p2_x)  and  delta = atan2(z, x),
    # so that the required base rotation is:
    theta1 = phi - delta = math.atan2(p2_z, p2_x) - math.atan2(z, x)

    # Joint 4 does not affect position; assign a nominal value.
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)