def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math

    # Unpack target TCP position.
    p_x, p_y, p_z = p

    # Solve for q3 using the y-coordinate:
    # p_y = 0.093 + 0.0823*cos(q3)  =>  cos(q3) = (p_y - 0.093) / 0.0823
    cos_q3 = (p_y - 0.093) / 0.0823
    if abs(cos_q3) > 1.0:
        raise ValueError("Target unreachable: invalid y component.")
    q3 = math.acos(cos_q3)
    sin_q3 = math.sqrt(max(0.0, 1 - cos_q3**2))

    # Solve for q2 using the planar (x,z) chain.
    d = 0.39225  # Fixed translation along z (from Revolute 2)
    D = math.sqrt(p_x**2 + p_z**2)  # Effective distance in the x-z plane
    a1 = 0.09465  # Link length from Revolute 4â€™s T_z translation
    a2 = 0.0823 * sin_q3  # Contribution from TCP offset rotated by q3

    # Law-of-cosines relation for the effective 2R chain:
    #    a1*cos(q2) + a2*sin(q2) = K, where K = (D^2 - (a1^2 + a2^2 + d^2)) / (2*d)
    K = (D**2 - (a1**2 + a2**2 + d**2)) / (2 * d)
    R_val = math.sqrt(a1**2 + a2**2)
    if abs(K / R_val) > 1.0:
        raise ValueError("Target unreachable: invalid planar subproblem.")
    alpha = math.atan2(a2, a1)
    # Choose the elbow-up solution.
    q2 = alpha + math.acos(K / R_val)

    # Solve for q1 using the (x,z) contributions.
    A = -0.0823 * math.cos(q2) * sin_q3 + 0.09465 * math.sin(q2)
    B =  0.0823 * math.sin(q2) * sin_q3 + 0.09465 * math.cos(q2) + d
    # (x,z) equations: p_x = cos(q1)*A + sin(q1)*B,  p_z = -sin(q1)*A + cos(q1)*B
    q1 = math.atan2(p_x * B - A * p_z, B * p_z + A * p_x)

    # Joint 4 is redundant for position; set q4 to zero.
    q4 = 0.0

    return (q1, q2, q3, q4)