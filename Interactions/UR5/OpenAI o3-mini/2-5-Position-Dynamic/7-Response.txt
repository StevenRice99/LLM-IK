def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles [q1, q2, q3, q4] required for the TCP position p = (p_x, p_y, p_z)
    of a 4-DOF manipulator with the following chain (all dimensions in meters, angles in radians):

      Revolute 1: origin [0, 0, 0], axis Y.
      Revolute 2: origin [0, 0, 0.39225], axis Y.
      Revolute 3: origin [0, 0.093, 0], axis Z.
      Revolute 4: origin [0, 0, 0.09465], axis Y.
      TCP:        origin [0, 0.0823, 0].

    The inverse kinematic solution is obtained in closed form in the following steps:

      1. The TCP y-coordinate (p_y) comes solely from the fixed offset 0.093 (from joint 3’s translation)
         and the TCP’s offset 0.0823 rotated by joint 3 about Z:
              p_y = 0.093 + 0.0823*cos(q3)
         so that:
              q3 = acos((p_y - 0.093) / 0.0823)

      2. In the x–z plane, letting D = sqrt(p_x^2 + p_z^2), an effective 2R chain can be defined.
         Here the parameters are:
              a1 = 0.09465   (translation from Revolute 4)
              a2 = 0.0823*sin(q3)  (TCP offset contribution, entering via the sine term)
         and the translation from Revolute 2 along z is:
              d = 0.39225.
         It can be shown that q2 must satisfy:
              a1*cos(q2) + a2*sin(q2) = K   where   K = (D^2 - (a1^2 + a2^2 + d^2)) / (2*d)
         Expressing the left-hand side as R*cos(q2 - alpha) with:
              R = sqrt(a1^2 + a2^2)   and   alpha = atan2(a2, a1),
         we pick the “elbow–up” solution:
              q2 = alpha + acos(K / R)

      3. Next, define intermediate quantities A and B that capture the contribution (after joints 2,3,4)
         in the x–z plane:
              A = -0.0823*cos(q2)*sin(q3) + 0.09465*sin(q2)
              B =  0.0823*sin(q2)*sin(q3) + 0.09465*cos(q2) + d
         The x–z coordinates are then:
              p_x = cos(q1)*A + sin(q1)*B
              p_z = -sin(q1)*A + cos(q1)*B
         Solving for q1 yields:
              q1 = atan2(p_x*B - A*p_z, B*p_z + A*p_x)

      4. Since joint 4 (rotation about Y) does not influence the TCP position (its TCP offset is along Y),
         we set:
              q4 = 0.
      
    Any target p is assumed reachable.
    """
    import math

    # Unpack target coordinates.
    p_x, p_y, p_z = p

    # Step 1: Solve for q3 from the TCP y-coordinate.
    # p_y = 0.093 + 0.0823*cos(q3)  -> cos(q3) = (p_y - 0.093) / 0.0823
    cos_q3 = (p_y - 0.093) / 0.0823
    if abs(cos_q3) > 1.0:
        raise ValueError("Target position unreachable in y dimension.")
    q3 = math.acos(cos_q3)
    sin_q3 = math.sqrt(max(0.0, 1.0 - cos_q3**2))

    # Step 2: Solve for q2 using the planar (x,z) chain.
    d = 0.39225      # translation along z from joint 2
    a1 = 0.09465     # translation from joint 4 (T_z)
    a2 = 0.0823 * sin_q3  # TCP offset contribution via sin(q3)
    D = math.sqrt(p_x**2 + p_z**2)
    K = (D**2 - (a1**2 + a2**2 + d**2)) / (2 * d)
    R_val = math.sqrt(a1**2 + a2**2)
    ratio = K / R_val
    if abs(ratio) > 1.0:
        raise ValueError("Target position unreachable in planar sub-problem.")
    alpha = math.atan2(a2, a1)
    # Choose the elbow-up solution.
    q2 = alpha + math.acos(ratio)

    # Step 3: Solve for q1 from the (x,z) equations.
    A = -0.0823 * math.cos(q2) * sin_q3 + 0.09465 * math.sin(q2)
    B =  0.0823 * math.sin(q2) * sin_q3 + 0.09465 * math.cos(q2) + d
    q1 = math.atan2(p_x * B - A * p_z, B * p_z + A * p_x)

    # Step 4: Joint 4 is redundant with respect to position.
    q4 = 0.0

    return (q1, q2, q3, q4)