def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math

    # Unpack target TCP position: p = (p_x, p_y, p_z)
    p_x, p_y, p_z = p

    # Step 1: Solve for q3 using the y-coordinate.
    # TCP y is given by: p_y = 0.093 + 0.0823*cos(q3)
    cos_q3 = (p_y - 0.093) / 0.0823
    if abs(cos_q3) > 1.0:
        raise ValueError("Target position unreachable in y.")
    q3 = math.acos(cos_q3)
    sin_q3 = math.sqrt(1 - cos_q3**2)

    # Step 2: Solve for q2 using the planar (x, z) chain.
    # Remove fixed offset d = 0.39225 along z from joint 2.
    D = math.sqrt(p_x**2 + p_z**2)  # effective distance in (x, z) plane
    d = 0.39225                 

    # Define effective link parameters:
    a1 = 0.09465              # translation from joint 4 (T_z)
    a2 = 0.0823 * sin_q3      # effect of TCP offset rotated by q3

    # The law-of-cosines relation:
    #   a1*cos(q2) + a2*sin(q2) = K, where K = (D^2 - (a1^2 + a2^2 + d^2))/(2*d)
    K = (D**2 - (a1**2 + a2**2 + d**2)) / (2 * d)
    R_val = math.sqrt(a1**2 + a2**2)
    ratio = K / R_val
    if abs(ratio) > 1.0:
        raise ValueError("Target position unreachable in the planar subchain.")
    alpha = math.atan2(a2, a1)
    # Choosing the elbow-up solution:
    q2 = alpha + math.acos(ratio)

    # Step 3: Solve for q1 using the contributions in the (x, z) plane.
    # Intermediate variables A and B are defined as:
    A = -0.0823 * math.cos(q2) * sin_q3 + 0.09465 * math.sin(q2)
    B =  0.0823 * math.sin(q2) * sin_q3 + 0.09465 * math.cos(q2) + d
    # The (x, z) equations become:
    #   p_x = cos(q1)*A + sin(q1)*B
    #   p_z = -sin(q1)*A + cos(q1)*B
    # These are solved by:
    q1 = math.atan2(p_x * B - A * p_z, B * p_z + A * p_x)

    # Step 4: q4 is redundant for position. Set it to 0.
    q4 = 0.0

    return (q1, q2, q3, q4)