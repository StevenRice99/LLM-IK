def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    import math
    x, y, z = p

    # Define the two effective link lengths that determine the horizontal (x, z) position.
    L1 = 0.39225  # Translation along z from Revolute 1 to Revolute 2.
    L2 = 0.09465  # Translation along z from Revolute 3 to Revolute 4.

    # The TCP's horizontal position is given by:
    #   x = L1*sin(theta1) + L2*sin(theta1 + theta2)
    #   z = L1*cos(theta1) + L2*cos(theta1 + theta2)
    #
    # Compute the horizontal distance from the origin:
    r = math.sqrt(x**2 + z**2)
    
    # Use the law of cosines to determine theta2:
    cos_theta2 = (r**2 - L1**2 - L2**2) / (2 * L1 * L2)
    theta2 = math.acos(cos_theta2)
    
    # Define an intermediate angle phi for decoupling theta1.
    # Observe that:
    #   A = L1 + L2*cos(theta2)  and  B = L2*sin(theta2)
    # Rewrite the x and z equations as:
    #   x = A*sin(theta1) + B*cos(theta1)
    #   z = A*cos(theta1) - B*sin(theta1)
    # Using an angle sum identity, we recognize that if we let phi = atan2(B, A),
    # then:
    #   x = R*sin(theta1 + phi)  and  z = R*cos(theta1 + phi)
    # where R = sqrt(A^2+B^2). Therefore, theta1 + phi = atan2(x, z) and
    # theta1 = atan2(x, z) - phi.
    A = L1 + L2 * math.cos(theta2)
    B = L2 * math.sin(theta2)
    phi = math.atan2(B, A)
    theta1 = math.atan2(x, z) - phi

    # The remaining two joints affect only orientation; choose them as zero.
    theta3 = 0.0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)