def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of a 4-DOF serial manipulator.
    
    The robotâ€™s kinematic chain is as follows:
    
      - Revolute 1: rotates about Y; its transformation sets the base orientation.
      - Revolute 2: rotates about Y; after a translation of 0.39225 along the local z-axis.
      - Revolute 3: rotates about Z; after a translation of 0.093 along the local y-axis.
      - Revolute 4: rotates about Y; after a translation of 0.09465 along the local z-axis.
      - TCP: has a fixed offset of [0, 0.0823, 0] (i.e. an additional shift along y) 
      
    In the resulting forward kinematics, the horizontal (x, z) position of the TCP can be expressed as:
    
         x = 0.39225*sin(theta1) + 0.09465*sin(theta1 + theta2)
         z = 0.39225*cos(theta1) + 0.09465*cos(theta1 + theta2)
    
    Meanwhile, the translations in the y-direction (0.093 from joint 3 and 0.0823 from the TCP offset)
    yield a constant TCP y-coordinate of 0.1753.
    
    Since the rotations at joints 3 (about Z) and 4 (about Y) do not affect the TCP's x and z position,
    we choose theta3 and theta4 to be zero. 
    
    This method assumes that any given target p = [x, y, z] is reachable and that its y value equals 0.1753.
    
    :param p: The target TCP position as a tuple (x, y, z).
    :return: A tuple (theta1, theta2, theta3, theta4) representing the required joint angles in radians.
    """
    import math

    # Unpack the target position.
    x_target, y_target, z_target = p

    # Link lengths that affect the horizontal (x,z) positioning.
    L1 = 0.39225  # Translation from Revolute 1 to Revolute 2 along z of frame 1.
    L2 = 0.09465  # Translation from Revolute 3 to Revolute 4 along z of frame 3.

    # The horizontal position (x, z) of the TCP is given by:
    #   x_target = L1 * sin(theta1) + L2 * sin(theta1 + theta2)
    #   z_target = L1 * cos(theta1) + L2 * cos(theta1 + theta2)
    # Using the law-of-cosines on the equivalent 2R planar arm:
    r_sq = x_target**2 + z_target**2
    cos_theta2 = (r_sq - L1**2 - L2**2) / (2 * L1 * L2)
    # Compute theta2; note: for reachable positions, |cos_theta2|<=1.
    theta2 = math.acos(cos_theta2)

    # Set up intermediate variables to solve for theta1.
    # Define:
    #   A = L1 + L2*cos(theta2)
    #   B = L2*sin(theta2)
    A = L1 + L2 * math.cos(theta2)
    B = L2 * math.sin(theta2)
    
    # The following relationships hold:
    #    A*x_target - B*z_target = (A^2+B^2) * sin(theta1)
    #    B*x_target + A*z_target = (A^2+B^2) * cos(theta1)
    denom = A**2 + B**2  # This is always positive.
    sin_theta1 = (A * x_target - B * z_target) / denom
    cos_theta1 = (B * x_target + A * z_target) / denom
    theta1 = math.atan2(sin_theta1, cos_theta1)
    
    # Since neither joint 3 (rotation about Z) nor joint 4 (rotation about Y) affect the TCP's x,z position,
    # we can choose:
    theta3 = 0.0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)