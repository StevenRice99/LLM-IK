def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed-form analytical solution for the inverse kinematics of a 4-DOF serial manipulator.
    
    The manipulator is defined as follows:
      - Joint 1 (Revolute): Located at [0, 0, 0], rotates about Y.
      - Joint 2 (Revolute): After a translation of 0.39225 along z, rotates about Y.
      - Joint 3 (Revolute): After a translation of 0.093 along y, rotates about Z.
      - Joint 4 (Revolute): After a translation of 0.09465 along z, rotates about Y.
      - TCP: Offset [0, 0.0823, 0] from the final joint, with fixed orientation.
      
    From the forward kinematics we can deduce that the TCPâ€™s horizontal (x, z) position is given by:
         x = 0.39225*sin(theta1) + 0.09465*sin(theta1 + theta2)
         z = 0.39225*cos(theta1) + 0.09465*cos(theta1 + theta2)
    while the vertical y position is fixed:
         y = 0.093 + 0.0823 = 0.1753.
    
    Since the rotations at joints 3 and 4 do not affect the TCP's position (only its orientation),
    we choose theta3 and theta4 to be zero.
    
    This function assumes that the target position p is reachable (i.e. x and z are consistent with some
    solution of the above equations, and y is 0.1753).
    
    :param p: A tuple (x, y, z) representing the desired TCP position.
    :return: A tuple (theta1, theta2, theta3, theta4) with the required joint angles in radians.
    """
    import math

    # Unpack target TCP position.
    x_target, y_target, z_target = p

    # Define the two effective "arm" lengths that affect the horizontal (x,z) positioning.
    L1 = 0.39225  # Translation along z from joint 1 to joint 2.
    L2 = 0.09465  # Translation along z from joint 3 to joint 4.

    # Compute the squared horizontal reach.
    r_sq = x_target**2 + z_target**2

    # Use the law-of-cosines to solve for theta2.
    cos_theta2 = (r_sq - L1**2 - L2**2) / (2 * L1 * L2)
    theta2 = math.acos(cos_theta2)

    # Define intermediate variables:
    # A = L1 + L2*cos(theta2)
    # B = L2*sin(theta2)
    A = L1 + L2 * math.cos(theta2)
    B = L2 * math.sin(theta2)
    
    # Solve for theta1.
    # The horizontal equations can be reformulated as:
    #    x_target = A*sin(theta1) + B*cos(theta1)
    #    z_target = A*cos(theta1) - B*sin(theta1)
    #
    # These can be solved by writing:
    #    sin(theta1) = (A*x_target - B*z_target) / (A**2 + B**2)
    #    cos(theta1) = (A*z_target + B*x_target) / (A**2 + B**2)
    denom = A**2 + B**2
    sin_theta1 = (A * x_target - B * z_target) / denom
    cos_theta1 = (A * z_target + B * x_target) / denom
    theta1 = math.atan2(sin_theta1, cos_theta1)

    # The remaining joints do not affect the TCP's position.
    theta3 = 0.0
    theta4 = 0.0

    return (theta1, theta2, theta3, theta4)