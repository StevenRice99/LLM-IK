def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Gets the joint values needed to reach position "p" using an analytical, closed‐form solution.
    This solution “fixes” the redundant degree of freedom by choosing q3 = 0.5 and q4 = 0.
    
    The kinematic chain (all values in meters and radians) is defined by:
      - Revolute 1: Translation [0, 0, 0], rotation about Y (q1).
      - Revolute 2: Translation [0, 0, 0.39225], rotation about Y (q2).
      - Revolute 3: Translation [0, 0.093, 0], rotation about Z (q3).
      - Revolute 4: Translation [0, 0, 0.09465], rotation about Y (q4).
      - TCP: Translation [0, 0.0823, 0] with a fixed rotation about Z (1.570796325), which does not affect the position.
    
    In the resulting forward position, the TCP lies at:
        p = R_y(q1) * Q
    where Q is the intermediate vector computed from joints 2–4:
        Q = [ Qx, Qy, Qz ]ᵀ = d2 + R_y(q2) { d3 + R_z(q3) [ d4 + d_tcp ] }
    with:
         d2      = [ 0,     0,     L ]         where L = 0.39225
         d3      = [ 0,  0.093,     0 ]
         d4      = [ 0,     0, 0.09465 ]
         d_tcp   = [ 0, 0.0823,     0 ]
         
    Notice that the y-component is given by:
         Qy = 0.093 + 0.0823*cos(q3)
    and by fixing q3 = 0.5, Qy ≈ 0.093 + 0.0823*cos(0.5) ≈ 0.165225.
    
    The x–z part of Q is affected by d2, q2, and the contributions of d4 and d_tcp. In particular,
    defining:
         a = 0.0823*sin(q3)   (contribution from TCP offset in the x–z plane)
         b = 0.09465          (translation from d4 along z)
    we find that the planar distance r (from the origin projected onto the x–z plane) satisfies:
         r² = (a² + b² + L²) + 2L [ a*sin(q2) + b*cos(q2) ]
    Writing a*sin(q2) + b*cos(q2) = R_val*sin(q2 + φ) (with R_val = √(a²+b²) and φ = atan2(b, a)),
    we solve for q2 as:
         q2 = asin( (r² - (a²+b²+L²))/(2L*R_val) ) - φ
         
    Finally, since p = R_y(q1)*[Qx, Qy, Qz]ᵀ and only the x–z components are affected by q1,
    if we compute the intermediate x–z vector:
         Qx = -a*cos(q2) + b*sin(q2)
         Qz = L + a*sin(q2) + b*cos(q2)
    then q1 is obtained from aligning the rotated Q:
         q1 = atan2(p_x, p_z) - atan2(Qx, Qz)
    
    :param p: The target TCP position [x, y, z]. (Assume p[1] is 0.093 + 0.0823*cos(0.5) ≈ 0.165225.)
    :return: Joint angles (q1, q2, q3, q4) in radians.
    """
    import math

    x, y, z = p
    # Compute the radial distance in the x–z plane.
    r = math.sqrt(x * x + z * z)

    # Fix the redundant joints by choosing:
    q3 = 0.5
    q4 = 0.0

    # Constant from revolute 2 (translation along z)
    L = 0.39225

    # For revolute 3, the translation along y is 0.093, and the TCP adds 0.0823 along y.
    # With q3 fixed, the y-offset becomes:
    #   p_y = 0.093 + 0.0823*cos(q3) ≈ 0.165225.
    # (We assume the provided target p agrees with this.)

    # For the x–z plane, the TCP offset d_tcp along y contributes via rotation (q3) yielding:
    a = 0.0823 * math.sin(q3)  # influence of TCP translation in the x–z plane
    b = 0.09465              # from translation of revolute 4 along z

    # The constant term from the chain that does not depend on q2:
    constant = a * a + b * b + L * L

    # From the forward kinematics, we deduce:
    #   r² = constant + 2L [ a*sin(q2) + b*cos(q2) ]
    # Let D = a*sin(q2) + b*cos(q2) = (r² - constant)/(2L)
    D = (r * r - constant) / (2 * L)

    # Write a*sin(q2) + b*cos(q2) = R_val*sin(q2+φ)
    R_val = math.sqrt(a * a + b * b)
    phi = math.atan2(b, a)

    # Compute q2 from:
    #   sin(q2 + φ) = D / R_val
    ratio = D / R_val
    # Clamp ratio to [-1,1] to account for potential numerical issues.
    ratio = max(min(ratio, 1.0), -1.0)
    q2 = math.asin(ratio) - phi

    # Compute the intermediate vector in the x–z plane from joints 2–4.
    Qx = -a * math.cos(q2) + b * math.sin(q2)
    Qz = L + a * math.sin(q2) + b * math.cos(q2)

    # Finally, determine the base joint (revolute 1) angle q1 from the rotation needed to align [Qx, Qz] with [x, z].
    q1 = math.atan2(x, z) - math.atan2(Qx, Qz)

    return (q1, q2, q3, q4)