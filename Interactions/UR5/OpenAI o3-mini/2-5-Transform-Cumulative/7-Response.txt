def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4) for the 4-DOF serial manipulator
    given the desired TCP position p and orientation r.
    
    Kinematic chain (all units in meters & radians):
      • Revolute 1: Located at [0, 0, 0] with no fixed translation; 
           rotates about Y.
      • Revolute 2: Has a fixed translation of [0, 0, 0.39225] (along Z) preceding it;
           rotates about Y.
      • Revolute 3: Has an additional translation of [0, 0.093, 0] (typically a shift in Y);
           rotates about Z.
      • Revolute 4: Has a fixed translation of [0, 0, 0.09465] (along Z) preceding it;
           rotates about Y.
      • TCP: Finally, there is a fixed TCP offset translation of [0, 0.0823, 0] and a fixed 
           rotation R_tcp_off = R_z(1.570796325) applied.
    
    In this analytical (closed-form) solution the inverse kinematics problem is decoupled into a 
    position part (to solve for joints 1 and 2) and an orientation part (to solve for joints 3 and 4).
    
    The procedure is as follows:
      1) Build the target rotation matrix R_target from the provided roll–pitch–yaw r (using the
         convention R_target = R_z(rz) · R_y(ry) · R_x(rx)).
      2) Since joints 1 and 2 both rotate about Y they collectively provide a rotation about Y 
         by an angle phi = theta1 + theta2. We “recover” phi from the target z–axis direction:
               phi = atan2(R_target[0,2], R_target[2,2])
      3) Joint 4’s translation (L4 = 0.09465) along its (local) z–axis affects the x–z position.
         We “remove” that offset from the target’s x and z coordinates:
                 x_adj = x_target − L4·sin(phi)
                 z_adj = z_target − L4·cos(phi)
         and then solve for theta1 as
                 theta1 = atan2(x_adj, z_adj)
         with theta2 = phi − theta1.
      4) Joint 3 (rotation about Z) is recovered from the target’s “side‐view” by
                 theta3 = atan2(R_target[1,0], R_target[1,1])
      5) Finally, after joints 1–3 the remaining rotation (about Y provided by joint 4) must 
         account for the TCP fixed rotation R_tcp_off = R_z(1.570796325). In forward kinematics the 
         overall rotation is given by:
                 R_total = R_y(theta1+theta2) · R_z(theta3) · R_y(theta4) · R_tcp_off.
         Equate R_total with R_target and solve for theta4:
                 R_y(theta4) = (R_y(theta1+theta2)·R_z(theta3))⁻¹ · R_target · (R_tcp_off)⁻¹
         Since a rotation about Y has the form:
                 [ cosθ    0    sinθ ]
                 [   0     1     0   ]
                 [ -sinθ   0    cosθ ]
         we extract theta4 as:
                 theta4 = atan2(M[0,2], M[0,0])
         where M = (R_0_3)⁻¹ · R_target · (R_tcp_off)⁻¹ and R_0_3 = R_y(theta1+theta2) · R_z(theta3).
    
    It is assumed that the provided target (p, r) is reachable.
    
    :param p: The desired TCP position as a tuple (x, y, z).
    :param r: The desired TCP orientation (roll, pitch, yaw) in radians.
    :return: A tuple (theta1, theta2, theta3, theta4) of joint angles in radians.
    """
    import math
    import numpy as np

    # Define basic rotation matrices
    def rot_x(angle: float) -> np.ndarray:
        return np.array([[1, 0, 0],
                         [0, math.cos(angle), -math.sin(angle)],
                         [0, math.sin(angle),  math.cos(angle)]])
    
    def rot_y(angle: float) -> np.ndarray:
        return np.array([[ math.cos(angle), 0, math.sin(angle)],
                         [0,               1,              0],
                         [-math.sin(angle), 0, math.cos(angle)]])
    
    def rot_z(angle: float) -> np.ndarray:
        return np.array([[math.cos(angle), -math.sin(angle), 0],
                         [math.sin(angle),  math.cos(angle), 0],
                         [0,                           0,      1]])
    
    # Unpack desired TCP position and orientation (roll, pitch, yaw)
    x_target, y_target, z_target = p
    rx, ry, rz = r

    # (1) Build the target rotation matrix R_target.
    # Using the roll-pitch-yaw convention: R_target = R_z(rz) · R_y(ry) · R_x(rx)
    R_target = rot_z(rz) @ rot_y(ry) @ rot_x(rx)
    
    # (2) Account for the TCP fixed rotation offset.
    # TCP has a constant rotation R_tcp_off = R_z(1.570796325)
    R_tcp_off = rot_z(1.570796325)
    
    # (3) Decouple joints 1 and 2.
    # Their combined rotation about Y (phi = theta1 + theta2) is recovered from the target’s z-axis:
    phi = math.atan2(R_target[0, 2], R_target[2, 2])
    
    # (4) Remove the effect of joint 4’s translation.
    # Joint 4 has a fixed translation along its local z-axis (L4 = 0.09465).
    L4 = 0.09465
    x_adj = x_target - L4 * math.sin(phi)
    z_adj = z_target - L4 * math.cos(phi)
    
    # Solve for theta1 (rotation about Y) from the adjusted x–z position.
    theta1 = math.atan2(x_adj, z_adj)
    # Then joint 2 is given by:
    theta2 = phi - theta1
    
    # (5) Solve for joint 3.
    # Joint 3 rotates about Z. A common choice is to extract theta3 from the elements in the Y row.
    theta3 = math.atan2(R_target[1, 0], R_target[1, 1])
    
    # (6) Solve for joint 4 using the remaining rotation.
    # The rotation produced by joints 1 through 3 is:
    R_y12 = rot_y(theta1 + theta2)  # R_y(theta1+theta2)
    R_z3 = rot_z(theta3)           # R_z(theta3)
    R_0_3 = R_y12 @ R_z3           # Combined rotation from base to joint 3.
    
    # The overall forward rotation is:
    #    R_total = R_0_3 · R_y(theta4) · R_tcp_off.
    # Equate with R_target, and solve for R_y(theta4):
    R_y_theta4 = np.linalg.inv(R_0_3) @ R_target @ np.linalg.inv(R_tcp_off)
    # For a pure rotation about Y we have:
    #    R_y(theta4) = [[cos(theta4), 0, sin(theta4)],
    #                   [     0,      1,      0     ],
    #                   [-sin(theta4),0, cos(theta4)]]
    theta4 = math.atan2(R_y_theta4[0, 2], R_y_theta4[0, 0])
    
    return (theta1, theta2, theta3, theta4)