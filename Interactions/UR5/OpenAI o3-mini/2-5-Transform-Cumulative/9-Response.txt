def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (theta1, theta2, theta3, theta4) for a 4-DOF serial manipulator
    given the desired end-effector (TCP) position and orientation.

    Kinematic chain details:
      - Revolute 1: Located at [0, 0, 0], rotates about Y.
      - Revolute 2: Offset by [0, 0, 0.39225] then rotates about Y.
      - Revolute 3: Offset by [0, 0.093, 0] then rotates about Z.
      - Revolute 4: Offset by [0, 0, 0.09465] then rotates about Y.
      - TCP: Offset by [0, 0.0823, 0] with a fixed rotation R_z(1.570796325).
      
    The solution decouples the kinematics:
      1. Use the desired TCP orientation (r given as roll, pitch, yaw) to build R_target.
      2. Recover the combined rotation from joints 1 and 2 (both about Y) via:
             phi = theta1 + theta2 = atan2(R_target[0,2], R_target[2,2])
      3. Remove the effect of the translation prior to joint 4. We subtract:
             L4 = 0.09465 along the direction phi in the x-z plane.
         Compute:
             x_adj = x_target - L4*sin(phi)
             z_adj = z_target - L4*cos(phi)
         Then:
             theta1 = atan2(x_adj, z_adj)
             theta2 = phi - theta1
      4. Solve for joint 3 (rotation about Z) from elements of R_target:
             theta3 = atan2(R_target[1,0], R_target[1,1])
      5. The remaining rotation provided by joint 4 (about Y) is computed from:
             R_total = R_y(theta1+theta2) · R_z(theta3) · R_y(theta4) · R_tcp_off = R_target
         Rearranging, we get:
             R_y(theta4) = (R_y(theta1+theta2)·R_z(theta3))⁻¹ · R_target · (R_tcp_off)⁻¹
         For a rotation about Y, we extract:
             theta4 = atan2(M[0,2], M[0,0])
         where M is as above and R_tcp_off = R_z(1.570796325).

    It is assumed that the given target (p, r) is reachable.
    
    :param p: Desired TCP position as (x, y, z).
    :param r: Desired TCP orientation (roll, pitch, yaw) in radians.
    :return: A tuple (theta1, theta2, theta3, theta4) with the joint angles in radians.
    """
    import math
    import numpy as np

    # Unpack TCP position and orientation (roll, pitch, yaw)
    x_target, y_target, z_target = p
    rx, ry, rz = r

    # Define rotation matrices about X, Y, and Z axes.
    def rot_x(angle: float) -> np.ndarray:
        return np.array([[1, 0, 0],
                         [0, math.cos(angle), -math.sin(angle)],
                         [0, math.sin(angle),  math.cos(angle)]])
    
    def rot_y(angle: float) -> np.ndarray:
        return np.array([[ math.cos(angle), 0, math.sin(angle)],
                         [0,               1,              0],
                         [-math.sin(angle), 0, math.cos(angle)]])
    
    def rot_z(angle: float) -> np.ndarray:
        return np.array([[math.cos(angle), -math.sin(angle), 0],
                         [math.sin(angle),  math.cos(angle), 0],
                         [0,                           0,      1]])
    
    # (1) Compute the target rotation matrix R_target using roll, pitch, yaw.
    # Convention: R_target = R_z(rz) * R_y(ry) * R_x(rx)
    R_target = rot_z(rz) @ rot_y(ry) @ rot_x(rx)
    
    # (2) Joints 1 and 2 both rotate about Y which combine additively.
    # Their combined rotation angle is:
    phi = math.atan2(R_target[0, 2], R_target[2, 2])
    
    # (3) Remove the effect of the translation preceding joint 4.
    # Joint 4's translation along its local z-axis is L4.
    L4 = 0.09465
    x_adj = x_target - L4 * math.sin(phi)
    z_adj = z_target - L4 * math.cos(phi)
    
    # Solve for theta1 (rotation about Y) from the adjusted x-z position.
    theta1 = math.atan2(x_adj, z_adj)
    # Then joint 2 is:
    theta2 = phi - theta1

    # (4) Solve for theta3 which rotates about Z.
    theta3 = math.atan2(R_target[1, 0], R_target[1, 1])

    # (5) Compute the rotation due to joints 1-3.
    # Since joints 1 and 2 both rotate about Y, R_y(theta1)*R_y(theta2) = R_y(theta1+theta2).
    R_0_3 = rot_y(theta1 + theta2) @ rot_z(theta3)
    
    # The TCP has a fixed rotation offset R_tcp_off given by a rotation about Z.
    R_tcp_off = rot_z(1.570796325)
    
    # The overall rotation from the base to the TCP is:
    #   R_total = R_0_3 · R_y(theta4) · R_tcp_off
    # Equate this to the target rotation R_target and solve for the residual rotation:
    M = np.linalg.inv(R_0_3) @ R_target @ np.linalg.inv(R_tcp_off)
    # For a rotation solely about Y, M has the form:
    #   [ cos(theta4)   0   sin(theta4) ]
    #   [      0        1       0       ]
    #   [ -sin(theta4)  0   cos(theta4) ]
    theta4 = math.atan2(M[0, 2], M[0, 0])
    
    return (theta1, theta2, theta3, theta4)