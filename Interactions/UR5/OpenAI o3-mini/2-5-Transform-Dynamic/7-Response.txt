def inverse_kinematics(p: tuple[float, float, float],
                       r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes a closed‐form analytical inverse kinematics solution for a 4-dof serial manipulator.
    
    Robot details (all units in meters and angles in radians):
      • Revolute 1: at [0,0,0] with rotation about Y.
      • Revolute 2: after a translation [0, 0, 0.39225] with rotation about Y.
      • Revolute 3: after a translation [0, 0.093, 0] with rotation about Z.
      • Revolute 4: after a translation [0, 0, 0.09465] with rotation about Y.
      • TCP: fixed translation [0, 0.0823, 0] and a fixed rotation about Z by 90°.
      
    The decoupled approach is:
      1. Solve for joint 1 (q1) using the (x,z) projection of the target TCP position.
      2. Remove the known translation along y (subtracting 0.093) to form a planar 2-link problem with 
         effective link lengths L1 = 0.0823 and L2 = 0.09465. The cosine law yields two candidate solutions 
         (via acos) for the joint at Revolute 3.
      3. For each candidate (which we label as theta2), solve a 2x2 linear system to obtain an intermediate 
         angle (theta1) that serves as the Revolute 2 joint angle.
      4. Compute the remaining joint (q4) – a rotation about Y – by comparing the residual orientation to the target.
      5. Out of the two candidate solutions for joints 2–4, choose the one that minimizes the overall orientation error.
      
    :param p: Desired TCP position as (x, y, z).
    :param r: Desired TCP orientation as (roll, pitch, yaw) (radians).
    :return: A 4-tuple (q1, q2, q3, q4) of joint angles in radians.
    """
    import math
    import numpy as np

    # ----- Step 1. Solve for Joint 1 (Revolute 1: rotation about Y) -----
    x, y, z = p
    q1 = math.atan2(x, z)
    
    # ----- Step 2. Set up the wrist inverse kinematics for joints 2 to 4 -----
    # Note: Before Joint 3 there is an offset in y of 0.093 m and the TCP provides a final y-offset of 0.0823 m.
    # Compute the effective y-offset to be “closed” by the planar geometry.
    px, py, pz = p
    y_offset = py - 0.093
    if abs(y_offset) > 0.0823:
        raise ValueError("Target y-coordinate unreachable (|py - 0.093| > 0.0823).")
        
    # Two possible candidate solutions for the joint at Revolute 3 (rotation about Z), via the cosine law.
    # (The effective link length for closure is L1 = 0.0823.)
    try:
        candidate_angle = math.acos(y_offset / 0.0823)
    except ValueError:
        # Although target is assumed reachable, numerical issues may arise.
        raise ValueError("Numerical error computing acos; check target y-coordinate.")
    possible_theta2 = [candidate_angle, -candidate_angle]  # these will serve as candidate values for joint 3
    
    # Build target rotation matrix R_target from roll, pitch, yaw.
    # Using the ZYX Euler angle convention.
    roll, pitch, yaw = r
    cr, sr = math.cos(roll), math.sin(roll)
    cp, sp = math.cos(pitch), math.sin(pitch)
    cy, sy = math.cos(yaw), math.sin(yaw)
    R_target = np.array([
        [cy * cp,           cy * sp * sr - sy * cr,    cy * sp * cr + sy * sr],
        [sy * cp,           sy * sp * sr + cy * cr,    sy * sp * cr - cy * sr],
        [   -sp,                         cp * sr,               cp * cr     ]
    ])
    
    # The TCP has an additional fixed rotation: 90° about Z.
    R_tcp = np.array([[0, -1, 0],
                      [1,  0, 0],
                      [0,  0, 1]])
    R_tcp_inv = R_tcp.T  # inverse of a rotation matrix is its transpose

    # Helper functions for rotation matrices about Y and Z:
    def rotY(theta: float) -> np.ndarray:
        return np.array([
            [math.cos(theta), 0, math.sin(theta)],
            [0, 1, 0],
            [-math.sin(theta), 0, math.cos(theta)]
        ])
    
    def rotZ(theta: float) -> np.ndarray:
        return np.array([
            [math.cos(theta), -math.sin(theta), 0],
            [math.sin(theta),  math.cos(theta), 0],
            [0, 0, 1]
        ])
    
    # Effective link lengths for the planar problem (in meters).
    L1 = 0.0823    # from Revolute 3 to TCP y-offset
    L2 = 0.09465   # translation from Revolute 4

    solutions = []  # to collect candidate solutions for joints 2–4
    # Loop over both candidate values for joint 3 (we label these as theta2 here).
    for theta2 in possible_theta2:
        sin_theta2 = math.sin(theta2)
        # Set up coefficients for the 2x2 system that arises from the planar geometry.
        A = -L1 * sin_theta2
        B = L2
        C =  L1 * sin_theta2
        D = L2
        det = B * D - A * C
        if abs(det) < 1e-6:
            continue  # skip this candidate if the system is nearly singular
        # Solve the 2x2 system for an intermediate angle, labeled theta1.
        sin_theta1 = (D * px - A * pz) / det
        cos_theta1 = (-C * px + B * pz) / det
        theta1 = math.atan2(sin_theta1, cos_theta1)
        # Here, theta1 (obtained from the linear system) will be assigned to Revolute 2.
        # And theta2 (the candidate) is assigned to Revolute 3.
        # The composite rotation due to joints 2 and 3 is then:
        R2 = rotY(theta1)    # rotation about Y for Joint 2
        R3 = rotZ(theta2)    # rotation about Z for Joint 3
        R_23 = R2 @ R3

        # ----- Step 3. Solve for Joint 4 (Revolute 4: rotation about Y) -----
        # The overall orientation must satisfy:
        #         R_23 * (rotY(q4)) * R_tcp = R_target.
        # Rearranging gives:
        #         rotY(q4) = inv(R_23) * (R_target * inv(R_tcp))
        R_desired = R_target @ R_tcp_inv
        R_remaining = np.linalg.inv(R_23) @ R_desired
        # For a rotation about Y, the rotation matrix is:
        #         [[cos(q4), 0, sin(q4)],
        #          [   0,    1,    0   ],
        #          [-sin(q4),0, cos(q4)]]
        # A simple extraction is:
        q4_candidate = math.atan2(R_remaining[0, 2], R_remaining[0, 0])
        
        # Compute the overall achieved orientation from joints 2–4:
        R4 = rotY(q4_candidate)
        R_achieved = R_23 @ R4 @ R_tcp
        orientation_error = np.linalg.norm(R_achieved - R_target)
        solutions.append((theta1, theta2, q4_candidate, orientation_error))
    
    if not solutions:
        # If no candidate solution was found (should not occur for reachable targets)
        return (q1, 0.0, 0.0, 0.0)
    
    # Select the candidate with the smallest orientation error.
    solutions.sort(key=lambda sol: sol[3])
    best_theta1, best_theta2, best_q4, _ = solutions[0]
    
    # Map the intermediate angles to the actual joint assignments:
    #   q1: Revolute 1 (about Y) computed above.
    #   q2: Revolute 2 (about Y) is given by best_theta1.
    #   q3: Revolute 3 (about Z) is given by best_theta2.
    #   q4: Revolute 4 (about Y) is best_q4.
    return (q1, best_theta1, best_theta2, best_q4)