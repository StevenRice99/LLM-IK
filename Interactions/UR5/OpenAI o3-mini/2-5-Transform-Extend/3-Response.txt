def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 4-DOF serial manipulator to reach a TCP position p 
    and orientation r (given in roll-pitch-yaw).

    Link frames from the URDF:
      - Revolute 1: Position [0, 0, 0], Orientation [0, 0, 0], rotates about Y.
      - Revolute 2: Position [0, 0, 0.39225], Orientation [0, 0, 0], rotates about Y.
      - Revolute 3: Position [0, 0.093, 0], Orientation [0, 0, 0], rotates about Z.
      - Revolute 4: Position [0, 0, 0.09465], Orientation [0, 0, 0], rotates about Y.
      - TCP:      Position [0, 0.0823, 0], Orientation [0, 0, 1.570796325].

    The complete forward kinematics is given by:
        R_total = Ry(θ1) · Ry(θ2) · Rz(θ3) · Ry(θ4) · Rz(1.570796325)
    where the TCP fixed offset is applied after joint 4.
    
    This method first solves the 3-DOF sub-chain (joints 1–3) by “backing off” the translational offset
    due to link 4, then computes the fourth joint angle required to match the desired end-effector orientation.
    
    :param p: The target TCP position in the form (x, y, z).
    :param r: The target TCP orientation as roll-pitch-yaw (rx, ry, rz) in radians.
    :return: A tuple (θ1, θ2, θ3, θ4) of joint angles in radians.
    """
    import numpy as np

    # Unpack the target position and orientation (rpy)
    x_target, y_target, z_target = p
    rx, ry, rz = r

    # Build the target rotation matrix R_target from roll (X), pitch (Y), & yaw (Z)
    R_roll = np.array([
        [1, 0, 0],
        [0, np.cos(rx), -np.sin(rx)],
        [0, np.sin(rx),  np.cos(rx)]
    ])
    R_pitch = np.array([
        [ np.cos(ry), 0, np.sin(ry)],
        [         0, 1,         0],
        [-np.sin(ry), 0, np.cos(ry)]
    ])
    R_yaw = np.array([
        [np.cos(rz), -np.sin(rz), 0],
        [np.sin(rz),  np.cos(rz), 0],
        [         0,           0, 1]
    ])
    R_target = R_yaw @ R_pitch @ R_roll

    # Given constants from the manipulator design:
    A = 0.39225  # Translation along z after revolute 1 (from link 2)
    B = 0.09465  # Translation along z from the fourth link (back-off for the TCP)

    # ----- Solve the 3-DOF sub-chain (Revolute 1-3) -----
    # The approach is to use the z-axis direction (embedded in R_target) to estimate the combined angle.
    # The sum angle (theta_sum) is defined by the target rotation matrix’s (0,2) and (2,2) elements.
    theta_sum = np.arctan2(R_target[0, 2], R_target[2, 2])
    
    # Adjust the target position to account for the translation due to joint 4 (back-off)
    theta1 = np.arctan2(x_target - B * np.sin(theta_sum),
                        z_target - B * np.cos(theta_sum))
    theta2 = theta_sum - theta1

    # For revolute 3 (rotation about Z), we extract the angle from the corresponding rotation elements.
    theta3 = np.arctan2(R_target[1, 0], R_target[1, 1])

    # ----- Solve for the fourth joint (Revolute 4) -----
    # The full kinematics chain applies:
    #   R_total = Ry(θ1) · Ry(θ2) · Rz(θ3) · Ry(θ4) · Rz(1.570796325)
    # To isolate R_y(θ4), rearrange:
    #   Ry(θ4) = (Ry(θ1) · Ry(θ2) · Rz(θ3))⁻¹ · R_target · Rz(–1.570796325)

    # Helper functions for rotations about y and z
    def Ry(angle):
        return np.array([
            [ np.cos(angle), 0, np.sin(angle)],
            [             0, 1,             0],
            [-np.sin(angle), 0, np.cos(angle)]
        ])

    def Rz(angle):
        return np.array([
            [ np.cos(angle), -np.sin(angle), 0],
            [ np.sin(angle),  np.cos(angle), 0],
            [             0,              0, 1]
        ])

    # Compute the cumulative rotation from joints 1 to 3.
    R_arm = Ry(theta1) @ Ry(theta2) @ Rz(theta3)

    # Remove the arm's rotation and the TCP fixed rotation to isolate the effect of joint 4.
    R_temp = np.linalg.inv(R_arm) @ R_target @ Rz(-1.570796325)

    # Since joint 4 rotates about Y, its rotation matrix is:
    #   Ry(θ4) = [ [cosθ4, 0, sinθ4],
    #              [   0,   1,   0   ],
    #              [-sinθ4, 0, cosθ4] ]
    # We can extract θ4 using:
    theta4 = np.arctan2(R_temp[0, 2], R_temp[2, 2])

    return (theta1, theta2, theta3, theta4)