def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (in radians) for a 4-DOF serial manipulator to reach a TCP 
    position p and orientation r given in roll-pitch-yaw.

    Manipulator details:
      • Revolute 1: origin [0, 0, 0], rotates about Y.
      • Revolute 2: origin [0, 0, 0.39225], rotates about Y.
      • Revolute 3: origin [0, 0.093, 0], rotates about Z.
      • Revolute 4: origin [0, 0, 0.09465], rotates about Y.
      • TCP:      translation [0, 0.0823, 0] and fixed rotation about Z by 1.570796325.

    The forward kinematics can be written as:
       R_total = Ry(θ1) · Ry(θ2) · Rz(θ3) · Ry(θ4) · Rz(1.570796325)
    where Ry(θ) and Rz(θ) are the rotation matrices about the Y and Z axes respectively.

    The approach is to:
      1. Build the target rotation matrix R_target from the provided roll, pitch, and yaw.
      2. Solve for the first three joint angles (θ1, θ2, θ3) using the 3-DOF sub-chain
         by “backing off” the TCP offset along z (B = 0.09465).
      3. Compute the fourth joint angle (θ4) by isolating its contribution from the full rotation.
    
    :param p: A tuple (x, y, z) representing the desired TCP position.
    :param r: A tuple (rx, ry, rz) for the desired TCP orientation in roll-pitch-yaw (radians).
    :return: A tuple (θ1, θ2, θ3, θ4) of joint angles in radians.
    """
    import numpy as np

    # Unpack target TCP position and orientation (rpy)
    x_target, y_target, z_target = p
    rx, ry, rz = r

    # Build the target rotation matrix from roll, pitch, yaw.
    # Note: Rotation order: roll (X-axis), then pitch (Y-axis), then yaw (Z-axis).
    R_roll = np.array([
        [1, 0, 0],
        [0, np.cos(rx), -np.sin(rx)],
        [0, np.sin(rx),  np.cos(rx)]
    ])
    R_pitch = np.array([
        [ np.cos(ry), 0, np.sin(ry)],
        [         0, 1,         0],
        [-np.sin(ry), 0, np.cos(ry)]
    ])
    R_yaw = np.array([
        [np.cos(rz), -np.sin(rz), 0],
        [np.sin(rz),  np.cos(rz), 0],
        [         0,           0, 1]
    ])
    R_target = R_yaw @ R_pitch @ R_roll

    # Constants from the manipulator design:
    # A = 0.39225 is the translation along z after revolute 1 (link 2), but for the sub-chain
    # we only need to “back off” by the offset B of link 4.
    B = 0.09465  # back-off translation along z from revolute 4

    # ----- Solve the 3-DOF sub-chain (Revolute 1-3) -----
    # The sum angle (theta_sum) is taken from the target rotation's x- and z-axis components.
    theta_sum = np.arctan2(R_target[0, 2], R_target[2, 2])
    
    # Adjust the target x and z positions to "back off" the TCP offset along z (B)
    theta1 = np.arctan2(x_target - B * np.sin(theta_sum),
                        z_target - B * np.cos(theta_sum))
    theta2 = theta_sum - theta1

    # For the third joint (rotation about Z), extract the angle from R_target.
    theta3 = np.arctan2(R_target[1, 0], R_target[1, 1])

    # ----- Solve for the fourth joint (Revolute 4) -----
    # Full rotation from joints 1-4 (before the fixed TCP rotation) satisfies:
    #   R_total = Ry(θ1) · Ry(θ2) · Rz(θ3) · Ry(θ4) · Rz(1.570796325)
    # To isolate Ry(θ4):
    #   Ry(θ4) = (Ry(θ1)·Ry(θ2)·Rz(θ3))⁻¹ · R_target · Rz(–1.570796325)

    # Define rotation matrices about Y and Z.
    def Ry(angle):
        return np.array([
            [ np.cos(angle), 0, np.sin(angle)],
            [             0, 1,             0],
            [-np.sin(angle), 0, np.cos(angle)]
        ])

    def Rz(angle):
        return np.array([
            [ np.cos(angle), -np.sin(angle), 0],
            [ np.sin(angle),  np.cos(angle), 0],
            [             0,              0, 1]
        ])

    # Calculate the rotation contributed by joints 1-3.
    R_arm = Ry(theta1) @ Ry(theta2) @ Rz(theta3)
    # Remove the arm's contribution and the fixed TCP rotation Rz(1.570796325)
    R_temp = np.linalg.inv(R_arm) @ R_target @ Rz(-1.570796325)

    # Since joint 4 rotates about Y, its rotation matrix is Ry(θ4):
    #   [cos(θ4)   0   sin(θ4)]
    #   [   0      1      0   ]
    #   [-sin(θ4)  0   cos(θ4)]
    # We extract θ4 from the (0,2) and (2,2) elements.
    theta4 = np.arctan2(R_temp[0, 2], R_temp[2, 2])

    return (theta1, theta2, theta3, theta4)