def inverse_kinematics(p, r):
    """
    Computes the joint angles (q1, q2, q3, q4) for the 4-DOF serial manipulator so that the
    tool center point (TCP) reaches the target position p and orientation r.

    Kinematic chain:
      T = R_y(q1) · T_z(0.39225) · R_y(q2) · T_y(0.093) · R_z(q3) · 
          T_z(0.09465) · R_y(q4) · T_y(0.0823) · R_z(1.570796325)

    Here the parameters are:
      A = 0.39225         (translation along z from Revolute 1->2)
      B = 0.093           (translation along y from Revolute 2->3)
      C = 0.09465         (translation along z from Revolute 3->4)
      D = 0.0823          (TCP translation along y)
      theta_offset = 1.570796325  (fixed TCP rotation about z)

    The solution procedure is as follows:
      1. Use the y-coordinate, which depends only on q3, to compute:
             y = B + D*cos(q3)
         so that
             q3 = -acos((y - B) / D)
         (the negative branch is chosen to match the forward kinematics convention).

      2. Define S = -sin(q3) (so that S ≥ 0) and let M = D * S.
         The x and z coordinates then satisfy:
             x = A*sin(q1) + [C*sin(β) + M*cos(β)]
             z = A*cos(q1) + [C*cos(β) - M*sin(β)]
         where β = q1 + q2. Define the offset:
             x_offset = C*sin(β) + M*cos(β)
             z_offset = C*cos(β) - M*sin(β)
         and the residuals:
             x' = x - x_offset = A*sin(q1)
             z' = z - z_offset = A*cos(q1).

      3. An algebraic manipulation yields the relation:
             E*sin(β) + F*cos(β) = -K,
         with:
             E = x * C - z * M,
             F = x * M + z * C,
             K = (A*A - x*x - z*z - C*C - M*M) / 2.
         Write R_val = sqrt(E²+F²) and define φ = atan2(F, E). Then
             sin(β + φ) = (-K) / R_val.
         Two solutions for β exist; here we select the one corresponding to the “elbow‐up” configuration.
      
      4. Once β is determined, recover q1 using:
             q1 = atan2( x - (C*sin(β) + M*cos(β)),
                         z - (C*cos(β) - M*sin(β)) )
         and then q2 = β - q1.
      
      5. Finally, the overall orientation is given by:
             R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset)
         Define X = R_y(q1+q2) · R_z(q3) so that
             R_temp = Xᵀ · R_target · R_z(-theta_offset) = R_y(q4).
         For a pure rotation about y,
             q4 = atan2( R_temp[0,2], R_temp[0,0] ).

    The input orientation r is given as Euler angles (roll, pitch, yaw) in radians
    with intrinsic rotations in the order: Rx, then Ry, then Rz.

    :param p: Tuple (x, y, z) for the target TCP position.
    :param r: Tuple (roll, pitch, yaw) for the target TCP orientation.
    :return: Tuple (q1, q2, q3, q4) of joint angles in radians.
    """
    import numpy as np
    from math import acos, asin, atan2, sqrt, pi

    # Unpack the target position.
    x, y, z = p

    # Define constant link parameters.
    A = 0.39225         # Translation along z from Revolute 1 -> 2
    B = 0.093           # Translation along y from Revolute 2 -> 3
    C = 0.09465         # Translation along z from Revolute 3 -> 4
    D = 0.0823          # TCP translation along y
    theta_offset = 1.570796325  # Fixed TCP rotation about z

    # --- Step 1: Solve for q3 using the y-coordinate.
    # From y = B + D*cos(q3):
    cos_q3 = (y - B) / D
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    q3 = -acos(cos_q3)
    sin_q3 = np.sin(q3)
    S = -sin_q3  # S is ensured to be nonnegative
    M = D * S

    # --- Step 2: Solve for q1 and q2.
    # Let beta = q1 + q2. The x, z equations become:
    #   x = A*sin(q1) + (C*sin(beta) + M*cos(beta))
    #   z = A*cos(q1) + (C*cos(beta) - M*sin(beta))
    # Rearranged, we define:
    E = x * C - z * M
    F = x * M + z * C
    K = (A**2 - x**2 - z**2 - C**2 - M**2) / 2.0  # so that E*sin(beta) + F*cos(beta) = -K
    Kp = -K
    R_val = sqrt(E*E + F*F)
    if R_val < 1e-8:
        R_val = 1e-8
    phi = atan2(F, E)
    ratio = np.clip(Kp / R_val, -1.0, 1.0)
    beta_candidate1 = asin(ratio) - phi
    beta_candidate2 = pi - asin(ratio) - phi
    # Choose the candidate corresponding to elbow-up configuration.
    beta = beta_candidate2 if beta_candidate2 > beta_candidate1 else beta_candidate1

    # Recover q1 using the residuals.
    x_prime = x - (C * np.sin(beta) + M * np.cos(beta))
    z_prime = z - (C * np.cos(beta) - M * np.sin(beta))
    q1 = atan2(x_prime, z_prime)
    q2 = beta - q1

    # --- Step 3: Solve for q4 using the orientation.
    # Define rotation matrices.
    def Rot_y(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0, 1, 0],
                         [-np.sin(angle), 0, np.cos(angle)]])
    def Rot_z(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0, 0, 1]])
    X = Rot_y(q1 + q2) @ Rot_z(q3)
    # Convert Euler angles (roll, pitch, yaw) to rotation matrix.
    def Rx(angle):
        return np.array([[1, 0, 0],
                         [0, np.cos(angle), -np.sin(angle)],
                         [0, np.sin(angle),  np.cos(angle)]])
    def Ry(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0, 1, 0],
                         [-np.sin(angle), 0, np.cos(angle)]])
    def Rz(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0, 0, 1]])
    R_target = Rx(r[0]) @ Ry(r[1]) @ Rz(r[2])
    R_temp = X.T @ R_target @ Rot_z(-theta_offset)
    q4 = atan2(R_temp[0, 2], R_temp[0, 0])

    return (q1, q2, q3, q4)