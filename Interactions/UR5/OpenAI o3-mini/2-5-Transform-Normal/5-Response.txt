def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (q1, q2, q3, q4) for the 4-DOF serial manipulator 
    so that its tool center point reaches the target position p and orientation r.
    
    The overall transformation chain is modeled as:
      T = R_y(q1) · Tz(A) · R_y(q2) · Ty(B) · R_z(q3) · Tz(C) · R_y(q4) · Ty(D) · R_z(theta_offset)
    where:
      A = 0.39225   (Revolute 2 translation along z)
      B = 0.093     (Translation along y between Revolute 2 and 3)
      C = 0.09465   (Revolute 4 translation along z)
      D = 0.0823    (TCP translation along y)
      theta_offset = 1.570796325 (TCP fixed rotation about z)
    
    The joint rotation axes are:
      q1, q2, q4 about Y and q3 about Z.
    
    The solution proceeds by:
      1. Using the y component to solve for q3.
      2. Expressing the x–z position equations in terms of q1 and beta=q1+q2.
      3. Solving for beta from a linear combination of sin(beta) and cos(beta).
      4. Recovering q1 from the residual x–z sub-problem and q2 = beta - q1.
      5. Using the given overall orientation and the computed X = R_y(q1+q2)·R_z(q3) to solve for q4.
    
    The target orientation r is given as Euler angles (roll, pitch, yaw) applied in the order
    Rx, then Ry, then Rz.
    
    :param p: Target position as (x, y, z)
    :param r: Target orientation as Euler angles (roll, pitch, yaw) in radians
    :return: A tuple (q1, q2, q3, q4) of joint angles in radians.
    """
    import numpy as np
    from math import acos, asin, atan2, pi

    # Unpack target position.
    x, y, z = p

    # Define constant link parameters from table.
    A = 0.39225          # Translation along z from Revolute 1->2
    B = 0.093            # Translation along y from Revolute 2->3
    C = 0.09465          # Translation along z from Revolute 3->4
    D = 0.0823           # TCP translation along y
    theta_offset = 1.570796325  # Fixed TCP rotation about z

    # ----------------------------
    # Step 1: Solve for q3 using the y coordinate.
    # The y component of the overall translation (before any rotations that affect y)
    # comes solely from the translations Ty(B) and Ty(D). The structure causes:
    #      y = B + D * cos(q3)
    # (Note: The q3-dependent contribution arises after the rotation R_z(q3) in the kinematic chain.)
    cos_q3 = (y - B) / D
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    # Choosing the branch that matches FK testing – q3 is taken as negative.
    q3 = -acos(cos_q3)
    sin_q3 = np.sin(q3)
    # Define S = -sin(q3) so that S >= 0; also define M = D * S.
    S = -sin_q3
    M = D * S

    # ----------------------------
    # Step 2: Solve for q1 and q2.
    # The x and z components are given by:
    #  x = A*sin(q1) + [C*sin(q1+q2) + M*cos(q1+q2)]
    #  z = A*cos(q1) + [C*cos(q1+q2) - M*sin(q1+q2)]
    # Define beta = q1 + q2.
    #
    # Rearranging:
    #  x' = x - (C*sin(beta) + M*cos(beta)) = A*sin(q1)
    #  z' = z - (C*cos(beta) - M*sin(beta)) = A*cos(q1)
    #
    # Squaring and adding gives (x')^2 + (z')^2 = A^2.
    # An algebraic manipulation leads to a relation:
    #    E*sin(beta) + F*cos(beta) = Kp,
    # where:
    E = x * C - z * M
    F = x * M + z * C
    # And K is defined as:
    #    K = (A^2 - x^2 - z^2 - C^2 - M^2) / 2
    # so that we write the equation as:
    #    E*sin(beta) + F*cos(beta) = -K   (hence, Kp = -K)
    K = (A*A - x*x - z*z - C*C - M*M) / 2.0
    Kp = -K

    R_val = np.sqrt(E**2 + F**2)
    if R_val < 1e-8:
        R_val = 1e-8  # prevent division by zero
    # Write E*sin(beta)+F*cos(beta) as R_val*sin(beta+phi)
    phi = np.arctan2(F, E)
    ratio = np.clip(Kp / R_val, -1.0, 1.0)
    # Two candidate solutions exist; here we choose the one (elbow-up) that provides the larger beta.
    beta_candidate1 = np.arcsin(ratio) - phi
    beta_candidate2 = np.pi - np.arcsin(ratio) - phi
    beta = beta_candidate2 if beta_candidate2 > beta_candidate1 else beta_candidate1

    # With beta known, recover q1 from the residual x–z equations.
    x_prime = x - (C * np.sin(beta) + M * np.cos(beta))
    z_prime = z - (C * np.cos(beta) - M * np.sin(beta))
    q1 = atan2(x_prime, z_prime)
    q2 = beta - q1

    # ----------------------------
    # Step 3: Solve for q4 using the orientation.
    # The overall rotational relationship is:
    #   R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset)
    # Let X = R_y(q1+q2) · R_z(q3). Then:
    #   R_target = X · [R_y(q4) · R_z(theta_offset)]
    # Premultiply by X^T and right-multiply by R_z(-theta_offset):
    #   X^T·R_target·R_z(-theta_offset) = R_y(q4)
    #
    # For a rotation about the y-axis:
    #   R_y(q4) = [[ cos(q4), 0, sin(q4)],
    #              [      0, 1,      0],
    #              [-sin(q4), 0, cos(q4)]],
    # so we can extract q4 from the (0,2) and (0,0) elements.
    def Rot_y(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0,             1,             0],
                         [-np.sin(angle),0, np.cos(angle)]])
    
    def Rot_z(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0,             0,              1]])
    
    X = Rot_y(q1 + q2) @ Rot_z(q3)
    
    # Convert Euler angles (roll, pitch, yaw) to a rotation matrix.
    # Here the Euler angles are assumed to be applied in the order: Rx, then Ry, then Rz.
    def Rx(angle):
        return np.array([[1, 0, 0],
                         [0, np.cos(angle), -np.sin(angle)],
                         [0, np.sin(angle),  np.cos(angle)]])
    
    def Ry(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0,             1, 0],
                         [-np.sin(angle),0, np.cos(angle)]])
    
    def Rz(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0,             0,              1]])
    
    R_target = Rx(r[0]) @ Ry(r[1]) @ Rz(r[2])
    
    R_temp = X.T @ R_target @ Rot_z(-theta_offset)
    q4 = atan2(R_temp[0, 2], R_temp[0, 0])
    
    return (q1, q2, q3, q4)