def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (q1, q2, q3, q4) for the 4-DOF serial manipulator so that 
    the tool center point (TCP) reaches the target position p and orientation r.
    
    This solution is based on the kinematic chain:
      T = R_y(q1) · T_z(A) · R_y(q2) · T_y(B) · R_z(q3) · T_z(C) · R_y(q4) · T_y(D) · R_z(theta_offset)
    where the constants (from the provided table) are:
      A = 0.39225         (translation along z from Revolute 1 to 2)
      B = 0.093           (translation along y from Revolute 2 to 3)
      C = 0.09465         (translation along z from Revolute 3 to 4)
      D = 0.0823          (translation along y from Revolute 4 to TCP)
      theta_offset = 1.570796325 (fixed TCP rotation about z)
      
    The joint rotation axes are:
      q1, q2, q4 about Y, and q3 about Z.
      
    The overall (rotation-only) kinematics is then:
      R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset)
      
    The inverse kinematics is computed as follows:
      1. Use the fact that, in the chain, only the revolute joint q3 influences the TCP's y coordinate.
         In our derivation the TCP y coordinate is:
             y = B + D*cos(q3)
         Hence, with proper branch selection:
             q3 = -acos((y - B) / D)
      2. Define S = -sin(q3) (so S ≥ 0) and M = D·S.
         Then the TCP’s x and z coordinates satisfy:
             x = A*sin(q1) + [C*sin(beta) + M*cos(beta)]
             z = A*cos(q1) + [C*cos(beta) - M*sin(beta)]
         where beta = q1 + q2.
         Subtracting the offset due to the distal joint yields:
             x' = x - (C*sin(beta) + M*cos(beta)) = A*sin(q1)
             z' = z - (C*cos(beta) - M*sin(beta)) = A*cos(q1)
      3. By appropriate algebra one obtains an equation of the form:
             E*sin(beta) + F*cos(beta) = -K
         with:
             E = x * C - z * M
             F = x * M + z * C
             K = (A*A - x*x - z*z - C*C - M*M) / 2
         Writing R = sqrt(E²+F²) and φ = arctan2(F,E), we solve:
             sin(beta + φ) = (-K)/R
         Two solutions exist for beta; here we choose the one corresponding to the “elbow‐up” configuration.
      4. Once beta is determined, q1 is recovered by:
             q1 = arctan2(x - (C*sin(beta) + M*cos(beta)),  z - (C*cos(beta) - M*sin(beta)))
         and q2 = beta - q1.
      5. Lastly, q4 is solved from the orientation:
         With X = R_y(q1+q2)·R_z(q3), we have
             R_target = X · [R_y(q4) · R_z(theta_offset)]
         and so:
             Xᵀ · R_target · R_z(–theta_offset) = R_y(q4).
         For a rotation about y,
             R_y(q4) = [[cos(q4), 0, sin(q4)],
                        [0, 1, 0],
                        [–sin(q4), 0, cos(q4)]],
         so we extract:
             q4 = arctan2( (R_temp[0,2]), (R_temp[0,0]) )
         where R_temp = Xᵀ · R_target · R_z(–theta_offset).
    
    The target orientation r is given as Euler angles (roll, pitch, yaw) with intrinsic rotations applied in the order Rx, Ry, Rz.
    
    :param p: The target position as a tuple (x, y, z).
    :param r: The target orientation as Euler angles (roll, pitch, yaw) in radians.
    :return: A tuple (q1, q2, q3, q4) with the computed joint angles in radians.
    """
    import numpy as np
    from math import acos, asin, atan2, pi, sqrt

    # Unpack target position.
    x, y, z = p

    # Define link constant parameters.
    A = 0.39225         # from Revolute 2 translation along z
    B = 0.093           # from Revolute 3 translation along y
    C = 0.09465         # from Revolute 4 translation along z
    D = 0.0823          # TCP translation along y
    theta_offset = 1.570796325  # TCP fixed rotation about z

    # ----- Step 1. Solve for q3 using the y-coordinate.
    # The kinematics yields: y = B + D*cos(q3)
    cos_q3 = (y - B) / D
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    # Choose branch such that q3 is negative (matching FK test results).
    q3 = -acos(cos_q3)
    sin_q3 = np.sin(q3)
    # Define S = -sin(q3) so that S is nonnegative.
    S = -sin_q3
    M = D * S

    # ----- Step 2. Solve for q1 and q2.
    # The x and z equations are:
    #    x = A*sin(q1) + [C*sin(beta) + M*cos(beta)]
    #    z = A*cos(q1) + [C*cos(beta) - M*sin(beta)]
    # where beta = q1 + q2.
    # Define the intermediate variables:
    E = x * C - z * M
    F = x * M + z * C
    K = (A*A - x*x - z*z - C*C - M*M) / 2.0  # from rearrangement of the kinematics equations
    Kp = -K  # we express the relation as E*sin(beta)+F*cos(beta)=Kp
    R_val = sqrt(E*E + F*F)
    if R_val < 1e-8:
        R_val = 1e-8  # avoid division by zero
    phi = atan2(F, E)
    ratio = np.clip(Kp / R_val, -1.0, 1.0)

    # Two solutions exist for beta; choose the one corresponding to the “elbow‐up” configuration.
    beta_candidate1 = asin(ratio) - phi
    beta_candidate2 = pi - asin(ratio) - phi
    beta = beta_candidate2 if beta_candidate2 > beta_candidate1 else beta_candidate1

    # Now recover q1 from:
    #    x' = x - (C*sin(beta) + M*cos(beta)) = A*sin(q1)
    #    z' = z - (C*cos(beta) - M*sin(beta)) = A*cos(q1)
    x_prime = x - (C * np.sin(beta) + M * np.cos(beta))
    z_prime = z - (C * np.cos(beta) - M * np.sin(beta))
    q1 = atan2(x_prime, z_prime)
    q2 = beta - q1

    # ----- Step 3. Solve for q4 using orientation.
    # The overall orientation is:
    #   R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset)
    # Let X = R_y(q1+q2) · R_z(q3), so that:
    #   R_target = X · [R_y(q4) · R_z(theta_offset)]
    # Then, pre-multiplying by Xᵀ and post-multiplying by R_z(–theta_offset):
    #   R_temp = Xᵀ · R_target · R_z(–theta_offset) = R_y(q4)
    #
    # For a rotation about the y axis:
    #   R_y(q4) = [[ cos(q4), 0, sin(q4)],
    #              [      0, 1,      0],
    #              [–sin(q4), 0, cos(q4)]]
    # so we extract:
    #   q4 = atan2( R_temp[0,2], R_temp[0,0] )
    def Rot_y(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0,             1, 0],
                         [-np.sin(angle), 0, np.cos(angle)]])
    def Rot_z(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0,             0,              1]])
    
    X = Rot_y(q1 + q2) @ Rot_z(q3)
    
    # Convert the target Euler angles (roll, pitch, yaw) to a rotation matrix.
    # Euler angles are assumed to be intrinsic rotations in the order: Rx, then Ry, then Rz.
    def Rx(angle):
        return np.array([[1, 0, 0],
                         [0, np.cos(angle), -np.sin(angle)],
                         [0, np.sin(angle),  np.cos(angle)]])
    def Ry(angle):
        return np.array([[np.cos(angle), 0, np.sin(angle)],
                         [0, 1, 0],
                         [-np.sin(angle), 0, np.cos(angle)]])
    def Rz(angle):
        return np.array([[np.cos(angle), -np.sin(angle), 0],
                         [np.sin(angle),  np.cos(angle), 0],
                         [0,             0,              1]])
    
    R_target = Rx(r[0]) @ Ry(r[1]) @ Rz(r[2])
    R_temp = X.T @ R_target @ Rot_z(-theta_offset)
    q4 = atan2(R_temp[0, 2], R_temp[0, 0])
    
    return (q1, q2, q3, q4)