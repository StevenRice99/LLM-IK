def inverse_kinematics(p: tuple[float, float, float], r: tuple[float, float, float]) -> tuple[float, float, float, float]:
    """
    Computes the joint angles (q1, q2, q3, q4) for a 4-DOF serial manipulator so that
    the tool center point (TCP) reaches the target position p and orientation r.

    Kinematic chain (using parameters from the given table):
      T = R_y(q1) · T_z(0.39225) · R_y(q2) · T_y(0.093) · R_z(q3) · 
          T_z(0.09465) · R_y(q4) · T_y(0.0823) · R_z(1.570796325)

    Here, the constants are:
      A = 0.39225         (translation along z from Revolute 1 to 2)
      B = 0.093           (translation along y from Revolute 2 to 3)
      C = 0.09465         (translation along z from Revolute 3 to 4)
      D = 0.0823          (translation along y from Revolute 4 to TCP)
      theta_offset = 1.570796325  (fixed TCP rotation about z)

    The solution uses the following steps:
      1. Using the y-coordinate (which depends only on q3), solve:
             y = B + D·cos(q3)
         so that:
             q3 = -acos((y - B) / D)
         (Branch chosen to be consistent with forward kinematics.)
      2. Define S = -sin(q3) (so that S ≥ 0) and M = D · S.
         Then the x and z coordinates satisfy:
             x = A·sin(q1) + [C·sin(β) + M·cos(β)]
             z = A·cos(q1) + [C·cos(β) - M·sin(β)]
         where β = q1 + q2.
      3. Algebraic manipulation yields a relation:
             E·sin(β) + F·cos(β) = -K,
         with:
             E = x·C - z·M,
             F = x·M + z·C,
             K = (A² - x² - z² - C² - M²) / 2.
         Writing R_val = sqrt(E² + F²) and φ = arctan2(F, E), we solve:
             sin(β + φ) = (-K) / R_val.
         Two solutions for β exist; here the “elbow‐up” solution is chosen.
      4. With β determined, q1 is recovered from:
             x' = x - (C·sin(β) + M·cos(β)) = A·sin(q1)
             z' = z - (C·cos(β) - M·sin(β)) = A·cos(q1),
         so that q1 = arctan2(x', z') and q2 = β - q1.
      5. Finally, the overall orientation satisfies:
             R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset).
         Defining X = R_y(q1+q2) · R_z(q3), then:
             Xᵀ · R_target · R_z(–theta_offset) = R_y(q4).
         For a rotation about the y‑axis, q4 can be extracted as:
             q4 = arctan2( [0,2]-element, [0,0]-element ).
    
    The target orientation r is specified as Euler angles (roll, pitch, yaw) in radians,
    assumed to be applied in the order: Rx, then Ry, then Rz.
    
    :param p: Target position (x, y, z).
    :param r: Target orientation as Euler angles (roll, pitch, yaw) in radians.
    :return: Tuple of joint angles (q1, q2, q3, q4) in radians.
    """
    import numpy as np
    from math import acos, asin, atan2, sqrt, pi

    # Unpack the target position.
    x, y, z = p

    # Define the link constants.
    A = 0.39225         # from Revolute 2 translation along z
    B = 0.093           # from Revolute 3 translation along y
    C = 0.09465         # from Revolute 4 translation along z
    D = 0.0823          # TCP translation along y
    theta_offset = 1.570796325  # TCP fixed rotation about z

    # -------------------------
    # Step 1: Solve for q3 using the y-coordinate.
    # y = B + D*cos(q3)  ==>  cos(q3) = (y - B)/D
    cos_q3 = (y - B) / D
    cos_q3 = np.clip(cos_q3, -1.0, 1.0)
    
    # Choose the branch so that q3 is negative (to match the FK test).
    q3 = -acos(cos_q3)
    sin_q3 = np.sin(q3)
    
    # Define S = -sin(q3) (ensuring S ≥ 0) and M = D * S.
    S = -sin_q3
    M = D * S

    # -------------------------
    # Step 2: Solve for q1 and q2 using the x-z equations.
    # Expressing:
    #   x = A*sin(q1) + [C*sin(β) + M*cos(β)]
    #   z = A*cos(q1) + [C*cos(β) - M*sin(β)]
    # where β = q1 + q2.
    # The distal contribution is:
    #   x_offset = C*sin(β) + M*cos(β)
    #   z_offset = C*cos(β) - M*sin(β)
    # Subtract these to get:
    #   x' = x - x_offset = A*sin(q1)
    #   z' = z - z_offset = A*cos(q1)
    #
    # To determine β we derive the relation:
    #   E*sin(β) + F*cos(β) = -K,
    # with:
    E = x * C - z * M
    F = x * M + z * C
    K = (A**2 - x**2 - z**2 - C**2 - M**2) / 2.0  # so that equation becomes: E*sin(β)+F*cos(β) = -K
    Kp = -K  # for clarity
    
    R_val = sqrt(E**2 + F**2)
    if R_val < 1e-8:
        R_val = 1e-8
    phi = atan2(F, E)
    ratio = np.clip(Kp / R_val, -1.0, 1.0)
    
    # Two candidate solutions for β exist; choose the one corresponding to the “elbow-up” configuration.
    beta_candidate1 = asin(ratio) - phi
    beta_candidate2 = pi - asin(ratio) - phi
    beta = beta_candidate2 if beta_candidate2 > beta_candidate1 else beta_candidate1

    # Recover q1 from:
    #   x' = A*sin(q1),   z' = A*cos(q1)
    x_prime = x - (C * np.sin(beta) + M * np.cos(beta))
    z_prime = z - (C * np.cos(beta) - M * np.sin(beta))
    q1 = atan2(x_prime, z_prime)
    q2 = beta - q1

    # -------------------------
    # Step 3: Solve for q4 using the orientation.
    # The overall rotation is given by:
    #   R_target = R_y(q1+q2) · R_z(q3) · R_y(q4) · R_z(theta_offset)
    # Let X = R_y(q1+q2) · R_z(q3). Then:
    #   R_target = X · [R_y(q4) · R_z(theta_offset)]
    # Premultiply by Xᵀ and postmultiply by R_z(–theta_offset):
    #   R_temp = Xᵀ · R_target · R_z(–theta_offset) = R_y(q4)
    #
    # For a rotation about y:
    #   R_y(q4) = [[ cos(q4), 0, sin(q4)],
    #              [    0,    1,   0    ],
    #              [–sin(q4), 0, cos(q4)]]
    # Thus, q4 = atan2( R_temp[0,2], R_temp[0,0] ).
    def Rot_y(angle):
        return np.array([
            [np.cos(angle), 0, np.sin(angle)],
            [0, 1, 0],
            [-np.sin(angle), 0, np.cos(angle)]
        ])
    
    def Rot_z(angle):
        return np.array([
            [np.cos(angle), -np.sin(angle), 0],
            [np.sin(angle),  np.cos(angle), 0],
            [0, 0, 1]
        ])
    
    X = Rot_y(q1 + q2) @ Rot_z(q3)
    
    # Convert Euler angles (roll, pitch, yaw) to a rotation matrix.
    # Assumes intrinsic rotations in the order: Rx, then Ry, then Rz.
    def Rx(angle):
        return np.array([
            [1, 0, 0],
            [0, np.cos(angle), -np.sin(angle)],
            [0, np.sin(angle),  np.cos(angle)]
        ])
    
    def Ry(angle):
        return np.array([
            [np.cos(angle), 0, np.sin(angle)],
            [0, 1, 0],
            [-np.sin(angle), 0, np.cos(angle)]
        ])
    
    def Rz(angle):
        return np.array([
            [np.cos(angle), -np.sin(angle), 0],
            [np.sin(angle),  np.cos(angle), 0],
            [0, 0, 1]
        ])
    
    R_target = Rx(r[0]) @ Ry(r[1]) @ Rz(r[2])
    R_temp = X.T @ R_target @ Rot_z(-theta_offset)
    q4 = atan2(R_temp[0, 2], R_temp[0, 0])
    
    return (q1, q2, q3, q4)