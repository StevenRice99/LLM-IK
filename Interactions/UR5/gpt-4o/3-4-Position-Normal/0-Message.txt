<INSTRUCTIONS>
You are tasked with producing a closed-form analytical solution for the inverse kinematics of the 2 degrees-of-freedom serial manipulator solving for the position of the TCP as detailed in the "DETAILS" section by completing the Python function provided in the "CODE" section. The "Position" and "Orientation" columns represent link coordinates in local space relative to their parent link. The positions are from the "xyx" attribute and the orientations are the "rpy" attribute from each link's "origin" element parsed from the URDF. The "Axis" column in the table represents the rotational axis of the revolute links; return their values in radians. and their limits are in radians. You are to respond with only the code for the completed inverse kinematics method with no additional text. Do not write any code to run the method for testing. You may use any methods included in Python, NumPy, SymPy, and SciPy to write your solution except for any interative optimization methods.
</INSTRUCTIONS>
<DETAILS>
 Link       | Position        | Orientation   | Axis   | Limits
------------+-----------------+---------------+--------+-------------------------
 Revolute 1 | [0, 0, 0]       | [0, 0, 0]     | Y      | [-6.2831853, 6.2831853]
 Revolute 2 | [0, 0.093, 0]   | [0, 0, 0]     | Z      | [-6.2831853, 6.2831853]
 TCP        | [0, 0, 0.09465] | [0, 0, 0]     |        |
</DETAILS>
<CODE>
def inverse_kinematics(p: tuple[float, float, float]) -> tuple[float, float]:
    """
    Gets the joint values needed to reach position "p".
    :param p :The position to reach in the form [x, y, z].
    :return: A list of the values to set the links to for reaching position "p".
    """
</CODE>